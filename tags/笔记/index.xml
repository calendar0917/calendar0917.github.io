<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>笔记 on Calendar&#39;s Blog</title>
        <link>https://calendar0917.github.io/tags/%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 笔记 on Calendar&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Calendar</copyright>
        <lastBuildDate>Sat, 15 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://calendar0917.github.io/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>操作系统</title>
        <link>https://calendar0917.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Fri, 07 Nov 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h2 id=&#34;操作系统概述&#34;&gt;操作系统概述
&lt;/h2&gt;&lt;p&gt;1940s 的计算机（ENIAC）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑门：真空电子管&lt;/li&gt;
&lt;li&gt;延迟线内存通过 “抛球” 来扩大存储空间&lt;/li&gt;
&lt;li&gt;没有操作系统！只需要执行程序即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1950s：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁芯内存&lt;/li&gt;
&lt;li&gt;可以执行更复杂的任务，希望调用 API 而不是直接访问设备&lt;/li&gt;
&lt;li&gt;在只有一个 CPU 的情况下，需要管理多个程序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1960s：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存更大，意味着可以放多个程序到内存里&lt;/li&gt;
&lt;li&gt;需要操作系统介入，实现多程序同时运行&lt;/li&gt;
&lt;li&gt;还需要硬件变化，在多个地址隔离的程序间切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1970s+：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本现代化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序和编译器&#34;&gt;程序和编译器
&lt;/h3&gt;&lt;p&gt;状态机：&lt;strong&gt;数字逻辑电路&lt;/strong&gt;的模拟器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器存储 + 运行逻辑 + 按照时间周期运行 &amp;ndash;&amp;gt; 状态转换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序就是状态机！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序的状态有什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量？全局 or 局部？&lt;/li&gt;
&lt;li&gt;函数调用、函数返回是什么？ &amp;ndash;&amp;gt; 栈帧的处理，调用是PUSH，返回是 POP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序 = 计算 + syscall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加上了系统调用，将操作权交给系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化可优化的部分，转义不可优化的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;状态机的初始状态（lib-64-linux/&amp;hellip;）等等都有定义，都建立在确定的基础上。&lt;/p&gt;
&lt;p&gt;gdb、strace、binutils 追踪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;并发&#34;&gt;并发
&lt;/h2&gt;&lt;h3 id=&#34;多处理器编程&#34;&gt;多处理器编程
&lt;/h3&gt;&lt;h4 id=&#34;原子性&#34;&gt;原子性
&lt;/h4&gt;&lt;p&gt;并发的基础：多线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享内存、具有独立堆栈&lt;/li&gt;
&lt;li&gt;如何验证？ &amp;ndash;&amp;gt; strace……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带来的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程共用变量时，发生冲突&lt;/li&gt;
&lt;li&gt;基本假设不再成立：程序不再独占处理器执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决：实现原子性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大人物切分为可以并行的小任务&lt;/li&gt;
&lt;li&gt;用 worker thread 去锁保护的队列里取任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;顺序&#34;&gt;顺序
&lt;/h4&gt;&lt;p&gt;编译器默认程序时顺序执行的，以进行优化；但是多线程时顺序不一定成立&lt;/p&gt;
&lt;h4 id=&#34;可见性&#34;&gt;可见性
&lt;/h4&gt;&lt;p&gt;处理器同时也是编译器，能够同时执行一个线程的指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即便是汇编，也可能产生步骤乱序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要放弃对旧的“程序”的理解&lt;/p&gt;
&lt;h3 id=&#34;理解并发程序执行&#34;&gt;理解并发程序执行
&lt;/h3&gt;&lt;h4 id=&#34;peterson-算法&#34;&gt;Peterson 算法
&lt;/h4&gt;&lt;p&gt;举旗，两个共享变量实现并发？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107184802806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107184802806&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用贴对方的标签来竞争&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何证明正确性？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画状态机？枚举所有可能性&lt;/li&gt;
&lt;li&gt;PC 的含义 &amp;ndash;&amp;gt; 指令的步骤++&lt;/li&gt;
&lt;li&gt;用 python 来检测！选对语言&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;py 的特性，yield&lt;/p&gt;
&lt;p&gt;只要能位系统建立模型，就能证明正确 / 找到错误&lt;/p&gt;
&lt;p&gt;将问题转化为图论问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;在多处理器上实现线程隔离&#34;&gt;在多处理器上实现线程隔离
&lt;/h3&gt;&lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;把物理计算机 “抽象” 成 “虚拟计算机”
&lt;ul&gt;
&lt;li&gt;程序好像独占计算机运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序和进程&#34;&gt;程序和进程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序是状态机的静态描述
&lt;ul&gt;
&lt;li&gt;描述了所有可能的程序状态&lt;/li&gt;
&lt;li&gt;程序 (动态) 运行起来，就成了&lt;strong&gt;进程&lt;/strong&gt; (进行中的程序)&lt;/li&gt;
&lt;li&gt;可以使用文件 API (“everything is a file”) 访问当前进程的 ID、状态信息、命令行参数和工作目录等元数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程状态机管理&#34;&gt;进程（状态机）管理
&lt;/h3&gt;&lt;p&gt;操作系统 = 状态机的管理者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建状态机：spawn(path, argv)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;销毁状态机: _exit()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制状态机: fork()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完整复制&lt;/strong&gt;状态机；新创建的状态机返回值为 0，执行 fork() 的进程会返回子进程的进程号。&lt;/li&gt;
&lt;li&gt;pritf 的输出机制，输出到缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位状态机: execve()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数 path、argv、evnp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;windows 与 Unix 管理进程的 API 不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程的地址空间&#34;&gt;进程的地址空间
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程的初始状态&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ABI 中规定了 initial state&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只规定了部分寄存器和栈 (argv 和 envp 中的字符串保存在栈中)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary 中指定的 PT_LOAD 段
&lt;ul&gt;
&lt;li&gt;内存是分成 “一段一段” 的&lt;/li&gt;
&lt;li&gt;每一段有访问权限 (rwx)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只有&lt;strong&gt;ELF 文件里声明的&lt;/strong&gt;内存和一些操作系统分配的内存
&lt;ul&gt;
&lt;li&gt;任何其他指针的访问都是非法的&lt;/li&gt;
&lt;li&gt;所以需要能够动态分配！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程的地址空间管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在状态机状态上增加/删除/修改一段可访问的内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MAP_ANONYMOUS: 匿名 (申请) 内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fd: 把文件 “搬到” 进程地址空间中 (例子：加载器)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 映射
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;off_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;munmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 修改映射权限
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mprotect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以用 pmap 命令查看进程的地址空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;瞬间完成内存分配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mmap/munmap 为 malloc/free 提供了机制&lt;/li&gt;
&lt;li&gt;libc 的大 malloc 会直接调用一次 mmap 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt; 命令通过读取 &lt;code&gt;/proc/[pid]/maps&lt;/code&gt; 和 &lt;code&gt;/proc/[pid]/smaps&lt;/code&gt; 文件来获取进程的内存映射信息。Linux 内核将这些信息以文本形式暴露在 &lt;code&gt;/proc&lt;/code&gt; 文件系统中，&lt;code&gt;pmap&lt;/code&gt; 通过解析这些文件实现功能，而无需直接调用特定的系统调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入侵地址空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gdb 的实现原理，可以任意观测、修改程序状态&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;小时候用的游戏修改器，需要多次读取数据，筛选后修改。原理就是监控游戏的整块内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;访问操作系统对象&#34;&gt;访问操作系统对象
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;先回顾一下操作系统创建的流程：一开始只有一个进程，然后通过 fork 产生出子进程，接着用 execve 来替换子进程为目标进程，再用 mmap 来分配空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是指向操作系统对象的 “指针”——系统调用通过这个指针 (fd) 确定进程希望访问操作系统中的哪个对象。我们有 open, close, read/write, lseek, dup 管理文件描述符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象的访问都需要指针
&lt;ul&gt;
&lt;li&gt;open, close, read/write (解引用), lseek (指针内赋值/运算), dup (指针间赋值)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 fork 的时候，文件描述符继承吗？
&lt;ul&gt;
&lt;li&gt;继承（UNIX中），方便但是危险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;文件&amp;rdquo;：有名字的数据对象，Everything is a file&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作系统中的对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;真实的设备
&lt;ul&gt;
&lt;li&gt;/dev/sda&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟的设备（文件）
&lt;ul&gt;
&lt;li&gt;/dev/urandom，/dev/null，并没有实际文件，但是操作系统为它们实现了特别的read、write操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管道：特殊的文件流
&lt;ul&gt;
&lt;li&gt;读口支持 read，写口支持 write&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;整合起来，就是所有的基础知识：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork, execve, waitpid, exit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mmap, munmap, mprotect, msync&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文件管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open, close, read, write, lseek, dup&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;一切皆文件的利弊：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一套 API 可以访问所有对象,便捷
&lt;ul&gt;
&lt;li&gt;一切都可以 | grep&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是涉及多义性、复杂项目下不便、耦合度高、高速设备不友好&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;终端和-unix-shell&#34;&gt;终端和 UNIX shell
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;终端的历史，其实就是直接控制硬件（打字机、繁重而昂贵的操作系统）的输入 - 输出互动的窗口&lt;/p&gt;
&lt;p&gt;今天则用伪终端（Pseudo Terminal）来模拟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户登录的起点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统启动 (内核 → init → getty)&lt;/li&gt;
&lt;li&gt;远程登录 (sshd → fork → openpty)
&lt;ul&gt;
&lt;li&gt;stdin, stdout, stderr 都会指向分配的终端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vscode (fork → openpty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;login 程序继承分配的终端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(是的，login 是一个程序)&lt;/li&gt;
&lt;li&gt;fork() 会继承文件描述符 (指针)
&lt;ul&gt;
&lt;li&gt;因此，子进程也会指向同一个终端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;终端的机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎么确定要控制的是那个终端/进程？（比如Ctrl + C）&lt;/li&gt;
&lt;li&gt;只管传输字符 &amp;ndash;&amp;gt; 由操作系统来决定如何对“当前”进程采取行动&lt;/li&gt;
&lt;li&gt;历史遗留问题，局限性：无法预知软件的未来
&lt;ul&gt;
&lt;li&gt;要做的是进行抽象，不要在把高层“意图”翻译成低层“规程”上花费脑力和时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Shell&lt;/strong&gt;编程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于文本替换的极简编程语言！
&lt;ul&gt;
&lt;li&gt;预处理: &lt;code&gt;$()&lt;/code&gt;, &lt;code&gt;&amp;lt;()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重定向: &lt;code&gt;cmd &amp;gt; file &amp;lt; file 2&amp;gt; /dev/null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;顺序结构: &lt;code&gt;cmd1; cmd2&lt;/code&gt;, &lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;, &lt;code&gt;cmd1 || cmd2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管道:&lt;code&gt;cmd1 | cmd2&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;这些&lt;strong&gt;命令&lt;/strong&gt;被翻译成&lt;strong&gt;系统调用&lt;/strong&gt;序列 (open, dup, pipe, fork, execve, waitpid, &amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-标准库和实现&#34;&gt;C 标准库和实现
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;API 的设计有一个有趣的原则：“非必要不实现” (“机制与策略分离”、“最小完备性原则”)：但凡应用程序能自己搞定的功能，操作系统就不需要提供——在一定程度上，这样的设计能防止 “包揽一切” 导致代码膨胀，甚至在长期演化的过程中成为历史的包袱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C 是一种 “高级汇编语言”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为对比，C++ 更&lt;strong&gt;好用&lt;/strong&gt;，但也更&lt;strong&gt;难移植&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统调用的一层 “浅封装”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;libc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分可以用 C 语言本身实现&lt;/li&gt;
&lt;li&gt;少部分需要一些 “底层支持”
&lt;ul&gt;
&lt;li&gt;例子：体系结构相关的内联汇编&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“最小完备性原则” 和 “机制策略分离” 的反面教材&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“每一个 malloc 在任何可能路径上都必有一次配对的 free，且之后不再使用”&lt;/li&gt;
&lt;li&gt;在复杂系统里太难保证了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;脱离 workload 做优化就是耍流氓&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在开始考虑性能之前，理解你需要考虑什么样的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;可执行文件&#34;&gt;可执行文件
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;是什么&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ELF 是 Executable and Linkable Format 的缩写，是 Linux 系统上的一种可执行文件格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个操作系统中的对象 (文件)&lt;/li&gt;
&lt;li&gt;一个字节序列 (我们可以把它当字符串编辑)&lt;/li&gt;
&lt;li&gt;一个描述了状态机初始状态的&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需要什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个头 (类似 7f 45 4c 46; 这是一个 jg 71)&lt;/li&gt;
&lt;li&gt;一段 Trampoline Code (PIC)
&lt;ul&gt;
&lt;li&gt;操作系统会给一个文件描述符 (指向文件本身)&lt;/li&gt;
&lt;li&gt;这段代码直接执行 hardcoded mmap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(就能实现 “加载” 的功能)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;反思&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ELF 不是一个人类友好的 “状态机数据结构描述”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了性能，彻底&lt;strong&gt;违背了可读&lt;/strong&gt; (“信息局部性”) 原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crash (SIGSEGV, SIGABRT, SIGILL, &amp;hellip;) 时会做 core dump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ulimit -c unlimited&lt;/code&gt;&lt;/strong&gt;：启用 Core Dump 的命令（或设一个合理的大小限制），确保程序崩溃时能生成 Core 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适合于 production systems&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过设置 core dump size，我们可以在程序发生 core dump 时保存到文件系统，并且在后续使用 gdb 调试它,但是 GDB 无法基于它继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 CRIU （Checkpoint/Restore In Userspace）解决&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;自己设计可执行文件？&lt;/p&gt;
&lt;p&gt;满足回归链接和加载中的核心概念：&lt;strong&gt;代码、符号、重定位&lt;/strong&gt;，就可以了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;生成可执行文件地过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;源代码 (.c) → 源代码 (.i)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ctrl-C &amp;amp; Ctrl-V (#include)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;今天：我们有&lt;a class=&#34;link&#34; href=&#34;https://doc.rust-lang.org/reference/procedural-macros.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;过程宏&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源代码 (.i) → 汇编代码 (.s)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“高级状态机” 到 “低级状态机” 的翻译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终生成带标注的指令序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编代码 (.s) → 目标文件 (.o)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件 = sections (.text, .data, .rodata.str.1, &amp;hellip;)
&lt;ul&gt;
&lt;li&gt;对于 ELF，每个 section 有它的权限、内存对齐等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;section 中的三要素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码&lt;/strong&gt; (字节序列)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号&lt;/strong&gt;：标记 “当前” 的位置&lt;/li&gt;
&lt;li&gt;重定位：暂时不能确定的数值 (链接时确定)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个目标文件 (.o) → 可执行文件 (a.out)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并所有的 sections
&lt;ul&gt;
&lt;li&gt;分别合并 .text, .data, .bss 中的代码&lt;/li&gt;
&lt;li&gt;把 sections “平铺” 成字节序列&lt;/li&gt;
&lt;li&gt;确定所有符号的位置&lt;/li&gt;
&lt;li&gt;解析全部重定位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;得到一个&lt;strong&gt;可执行文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，把字节序列搬到内存，执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;操作系统和加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;execve(path, argv, envp)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统内核解析 path、完成加载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 注释的作用 -&amp;gt; 指示解释器路径&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Fri, 07 Nov 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;p&gt;参考：https://jyywiki.cn/OS/&lt;/p&gt;
&lt;h2 id=&#34;操作系统概述&#34;&gt;操作系统概述
&lt;/h2&gt;&lt;p&gt;1940s 的计算机（ENIAC）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑门：真空电子管&lt;/li&gt;
&lt;li&gt;延迟线内存通过 “抛球” 来扩大存储空间&lt;/li&gt;
&lt;li&gt;没有操作系统！只需要执行程序即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1950s：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁芯内存&lt;/li&gt;
&lt;li&gt;可以执行更复杂的任务，希望调用 API 而不是直接访问设备&lt;/li&gt;
&lt;li&gt;在只有一个 CPU 的情况下，需要管理多个程序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1960s：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存更大，意味着可以放多个程序到内存里&lt;/li&gt;
&lt;li&gt;需要操作系统介入，实现多程序同时运行&lt;/li&gt;
&lt;li&gt;还需要硬件变化，在多个地址隔离的程序间切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1970s+：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本现代化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序和编译器&#34;&gt;程序和编译器
&lt;/h3&gt;&lt;p&gt;状态机：&lt;strong&gt;数字逻辑电路&lt;/strong&gt;的模拟器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器存储 + 运行逻辑 + 按照时间周期运行 &amp;ndash;&amp;gt; 状态转换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序就是状态机！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序的状态有什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量？全局 or 局部？&lt;/li&gt;
&lt;li&gt;函数调用、函数返回是什么？ &amp;ndash;&amp;gt; 栈帧的处理，调用是PUSH，返回是 POP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序 = 计算 + syscall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加上了系统调用，将操作权交给系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化可优化的部分，转义不可优化的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;状态机的初始状态（lib-64-linux/&amp;hellip;）等等都有定义，都建立在确定的基础上。&lt;/p&gt;
&lt;p&gt;gdb、strace、binutils 追踪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;并发&#34;&gt;并发
&lt;/h2&gt;&lt;h3 id=&#34;多处理器编程&#34;&gt;多处理器编程
&lt;/h3&gt;&lt;h4 id=&#34;原子性&#34;&gt;原子性
&lt;/h4&gt;&lt;p&gt;并发的基础：多线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享内存、具有独立堆栈&lt;/li&gt;
&lt;li&gt;如何验证？ &amp;ndash;&amp;gt; strace……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带来的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程共用变量时，发生冲突&lt;/li&gt;
&lt;li&gt;基本假设不再成立：程序不再独占处理器执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决：实现原子性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大人物切分为可以并行的小任务&lt;/li&gt;
&lt;li&gt;用 worker thread 去锁保护的队列里取任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;顺序&#34;&gt;顺序
&lt;/h4&gt;&lt;p&gt;编译器默认程序时顺序执行的，以进行优化；但是多线程时顺序不一定成立&lt;/p&gt;
&lt;h4 id=&#34;可见性&#34;&gt;可见性
&lt;/h4&gt;&lt;p&gt;处理器同时也是编译器，能够同时执行一个线程的指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即便是汇编，也可能产生步骤乱序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要放弃对旧的“程序”的理解&lt;/p&gt;
&lt;h3 id=&#34;理解并发程序执行&#34;&gt;理解并发程序执行
&lt;/h3&gt;&lt;h4 id=&#34;peterson-算法&#34;&gt;Peterson 算法
&lt;/h4&gt;&lt;p&gt;举旗，两个共享变量实现并发？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107184802806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107184802806&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用贴对方的标签来竞争&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何证明正确性？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画状态机？枚举所有可能性&lt;/li&gt;
&lt;li&gt;PC 的含义 &amp;ndash;&amp;gt; 指令的步骤++&lt;/li&gt;
&lt;li&gt;用 python 来检测！选对语言&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;py 的特性，yield&lt;/p&gt;
&lt;p&gt;只要能位系统建立模型，就能证明正确 / 找到错误&lt;/p&gt;
&lt;p&gt;将问题转化为图论问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;在多处理器上实现线程隔离&#34;&gt;在多处理器上实现线程隔离
&lt;/h3&gt;&lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化
&lt;/h2&gt;&lt;h3 id=&#34;程序和进程&#34;&gt;程序和进程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序是状态机的静态描述
&lt;ul&gt;
&lt;li&gt;描述了所有可能的程序状态&lt;/li&gt;
&lt;li&gt;程序 (动态) 运行起来，就成了&lt;strong&gt;进程&lt;/strong&gt; (进行中的程序)&lt;/li&gt;
&lt;li&gt;可以使用文件 API (“everything is a file”) 访问当前进程的 ID、状态信息、命令行参数和工作目录等元数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程状态机管理&#34;&gt;进程（状态机）管理
&lt;/h3&gt;&lt;p&gt;操作系统 = 状态机的管理者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建状态机：spawn(path, argv)&lt;/li&gt;
&lt;li&gt;销毁状态机: _exit()&lt;/li&gt;
&lt;li&gt;复制状态机: fork()
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完整复制&lt;/strong&gt;状态机；新创建的状态机返回值为 0，执行 fork() 的进程会返回子进程的进程号。&lt;/li&gt;
&lt;li&gt;pritf 的输出机制，输出到缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复位状态机: execve()
&lt;ul&gt;
&lt;li&gt;参数 path、argv、evnp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;windows 与 Unix 管理进程的 API 不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程的地址空间&#34;&gt;进程的地址空间
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程的初始状态&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ABI 中规定了 initial state&lt;/li&gt;
&lt;li&gt;只规定了部分寄存器和栈 (argv 和 envp 中的字符串保存在栈中)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Binary 中指定的 PT_LOAD 段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存是分成 “一段一段” 的&lt;/li&gt;
&lt;li&gt;每一段有访问权限 (rwx)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有&lt;/p&gt;
&lt;p&gt;ELF 文件里声明的&lt;/p&gt;
&lt;p&gt;内存和一些操作系统分配的内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何其他指针的访问都是非法的&lt;/li&gt;
&lt;li&gt;所以需要能够动态分配！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程的地址空间管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在状态机状态上增加/删除/修改一段可访问的内存
&lt;ul&gt;
&lt;li&gt;MAP_ANONYMOUS: 匿名 (申请) 内存&lt;/li&gt;
&lt;li&gt;fd: 把文件 “搬到” 进程地址空间中 (例子：加载器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 映射
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;off_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;munmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 修改映射权限
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mprotect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;可以用 pmap 命令查看进程的地址空间&lt;/li&gt;
&lt;li&gt;瞬间完成内存分配
&lt;ul&gt;
&lt;li&gt;mmap/munmap 为 malloc/free 提供了机制&lt;/li&gt;
&lt;li&gt;libc 的大 malloc 会直接调用一次 mmap 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt; 命令通过读取 &lt;code&gt;/proc/[pid]/maps&lt;/code&gt; 和 &lt;code&gt;/proc/[pid]/smaps&lt;/code&gt; 文件来获取进程的内存映射信息。Linux 内核将这些信息以文本形式暴露在 &lt;code&gt;/proc&lt;/code&gt; 文件系统中，&lt;code&gt;pmap&lt;/code&gt; 通过解析这些文件实现功能，而无需直接调用特定的系统调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入侵地址空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gdb 的实现原理，可以任意观测、修改程序状态&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;小时候用的游戏修改器，需要多次读取数据，筛选后修改。原理就是监控游戏的整块内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;访问操作系统对象&#34;&gt;访问操作系统对象
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;先回顾一下操作系统创建的流程：一开始只有一个进程，然后通过 fork 产生出子进程，接着用 execve 来替换子进程为目标进程，再用 mmap 来分配空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是指向操作系统对象的 “指针”——系统调用通过这个指针 (fd) 确定进程希望访问操作系统中的哪个对象。我们有 open, close, read/write, lseek, dup 管理文件描述符。
&lt;ul&gt;
&lt;li&gt;对象的访问都需要指针
&lt;ul&gt;
&lt;li&gt;open, close, read/write (解引用), lseek (指针内赋值/运算), dup (指针间赋值)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 fork 的时候，文件描述符继承吗？
&lt;ul&gt;
&lt;li&gt;继承（UNIX中），方便但是危险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“文件”：有名字的数据对象，Everything is a file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作系统中的对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;真实的设备
&lt;ul&gt;
&lt;li&gt;/dev/sda&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟的设备（文件）
&lt;ul&gt;
&lt;li&gt;/dev/urandom，/dev/null，并没有实际文件，但是操作系统为它们实现了特别的read、write操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管道：特殊的文件流
&lt;ul&gt;
&lt;li&gt;读口支持 read，写口支持 write&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;整合起来，就是所有的基础知识：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork, execve, waitpid, exit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mmap, munmap, mprotect, msync&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文件管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open, close, read, write, lseek, dup&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;一切皆文件的利弊：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一套 API 可以访问所有对象,便捷
&lt;ul&gt;
&lt;li&gt;一切都可以 | grep&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是涉及多义性、复杂项目下不便、耦合度高、高速设备不友好…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;终端和-unix-shell&#34;&gt;终端和 UNIX shell
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;终端的历史，其实就是直接控制硬件（打字机、繁重而昂贵的操作系统）的输入 - 输出互动的窗口&lt;/p&gt;
&lt;p&gt;今天则用伪终端（Pseudo Terminal）来模拟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户登录的起点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统启动 (内核 → init → getty)&lt;/li&gt;
&lt;li&gt;远程登录 (sshd → fork → openpty)
&lt;ul&gt;
&lt;li&gt;stdin, stdout, stderr 都会指向分配的终端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vscode (fork → openpty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;login 程序继承分配的终端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(是的，login 是一个程序)&lt;/li&gt;
&lt;li&gt;fork() 会继承文件描述符 (指针)
&lt;ul&gt;
&lt;li&gt;因此，子进程也会指向同一个终端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;终端的机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎么确定要控制的是那个终端/进程？（比如Ctrl + C）&lt;/li&gt;
&lt;li&gt;只管传输字符 –&amp;gt; 由操作系统来决定如何对“当前”进程采取行动&lt;/li&gt;
&lt;li&gt;历史遗留问题，局限性：无法预知软件的未来
&lt;ul&gt;
&lt;li&gt;要做的是进行抽象，不要在把高层“意图”翻译成低层“规程”上花费脑力和时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Shell&lt;/strong&gt;编程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于文本替换的极简编程语言！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预处理: &lt;code&gt;$()&lt;/code&gt;, &lt;code&gt;&amp;lt;()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重定向: &lt;code&gt;cmd &amp;gt; file &amp;lt; file 2&amp;gt; /dev/null&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序结构: &lt;code&gt;cmd1; cmd2&lt;/code&gt;, &lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;, &lt;code&gt;cmd1 || cmd2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管道:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmd1 | cmd2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这些&lt;strong&gt;命令&lt;/strong&gt;被翻译成&lt;strong&gt;系统调用&lt;/strong&gt;序列 (open, dup, pipe, fork, execve, waitpid, …)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-标准库和实现&#34;&gt;C 标准库和实现
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;API 的设计有一个有趣的原则：“非必要不实现” (“机制与策略分离”、“最小完备性原则”)：但凡应用程序能自己搞定的功能，操作系统就不需要提供——在一定程度上，这样的设计能防止 “包揽一切” 导致代码膨胀，甚至在长期演化的过程中成为历史的包袱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;C 是一种 “高级汇编语言”
&lt;ul&gt;
&lt;li&gt;作为对比，C++ 更&lt;strong&gt;好用&lt;/strong&gt;，但也更&lt;strong&gt;难移植&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用的一层 “浅封装”&lt;/li&gt;
&lt;li&gt;libc
&lt;ul&gt;
&lt;li&gt;大部分可以用 C 语言本身实现&lt;/li&gt;
&lt;li&gt;少部分需要一些 “底层支持”
&lt;ul&gt;
&lt;li&gt;例子：体系结构相关的内联汇编&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“最小完备性原则” 和 “机制策略分离” 的反面教材
&lt;ul&gt;
&lt;li&gt;“每一个 malloc 在任何可能路径上都必有一次配对的 free，且之后不再使用”&lt;/li&gt;
&lt;li&gt;在复杂系统里太难保证了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;脱离 workload 做优化就是耍流氓&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在开始考虑性能之前，理解你需要考虑什么样的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;可执行文件&#34;&gt;可执行文件
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;是什么&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ELF 是 Executable and Linkable Format 的缩写，是 Linux 系统上的一种可执行文件格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个操作系统中的对象 (文件)&lt;/li&gt;
&lt;li&gt;一个字节序列 (我们可以把它当字符串编辑)&lt;/li&gt;
&lt;li&gt;一个描述了状态机初始状态的&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需要什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个头 (类似 7f 45 4c 46; 这是一个 jg 71)&lt;/li&gt;
&lt;li&gt;一段 Trampoline Code (PIC)
&lt;ul&gt;
&lt;li&gt;操作系统会给一个文件描述符 (指向文件本身)&lt;/li&gt;
&lt;li&gt;这段代码直接执行 hardcoded mmap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(就能实现 “加载” 的功能)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;反思&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELF 不是一个人类友好的 “状态机数据结构描述”
&lt;ul&gt;
&lt;li&gt;为了性能，彻底&lt;strong&gt;违背了可读&lt;/strong&gt; (“信息局部性”) 原则&lt;/li&gt;
&lt;li&gt;Crash (SIGSEGV, SIGABRT, SIGILL, …) 时会做 core dump
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ulimit -c unlimited&lt;/code&gt;&lt;/strong&gt;：启用 Core Dump 的命令（或设一个合理的大小限制），确保程序崩溃时能生成 Core 文件&lt;/li&gt;
&lt;li&gt;适合于 production systems&lt;/li&gt;
&lt;li&gt;通过设置 core dump size，我们可以在程序发生 core dump 时保存到文件系统，并且在后续使用 gdb 调试它,但是 GDB 无法基于它继续执行&lt;/li&gt;
&lt;li&gt;用 CRIU （Checkpoint/Restore In Userspace）解决&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;自己设计可执行文件？&lt;/p&gt;
&lt;p&gt;满足回归链接和加载中的核心概念：&lt;strong&gt;代码、符号、重定位&lt;/strong&gt;，就可以了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;生成可执行文件地过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源代码 (.c) → 源代码 (.i)
&lt;ul&gt;
&lt;li&gt;Ctrl-C &amp;amp; Ctrl-V (#include)&lt;/li&gt;
&lt;li&gt;字符串替换&lt;/li&gt;
&lt;li&gt;今天：我们有&lt;a class=&#34;link&#34; href=&#34;https://doc.rust-lang.org/reference/procedural-macros.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;过程宏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;源代码 (.i) → 汇编代码 (.s)
&lt;ul&gt;
&lt;li&gt;“高级状态机” 到 “低级状态机” 的翻译&lt;/li&gt;
&lt;li&gt;最终生成带标注的指令序列&lt;/li&gt;
&lt;li&gt;汇编代码 (.s) → 目标文件 (.o)
&lt;ul&gt;
&lt;li&gt;文件 = sections (.text, .data, .rodata.str.1, …)
&lt;ul&gt;
&lt;li&gt;对于 ELF，每个 section 有它的权限、内存对齐等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;section 中的三要素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码&lt;/strong&gt; (字节序列)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号&lt;/strong&gt;：标记 “当前” 的位置&lt;/li&gt;
&lt;li&gt;重定位：暂时不能确定的数值 (链接时确定)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多个目标文件 (.o) → 可执行文件 (a.out)
&lt;ul&gt;
&lt;li&gt;合并所有的 sections
&lt;ul&gt;
&lt;li&gt;分别合并 .text, .data, .bss 中的代码&lt;/li&gt;
&lt;li&gt;把 sections “平铺” 成字节序列&lt;/li&gt;
&lt;li&gt;确定所有符号的位置&lt;/li&gt;
&lt;li&gt;解析全部重定位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;得到一个&lt;strong&gt;可执行文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后，把字节序列搬到内存，执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;操作系统和加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;execve(path, argv, envp)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统内核解析 path、完成加载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 注释的作用 -&amp;gt; 指示解释器路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链接和加载&#34;&gt;链接和加载
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当开发者希望把库函数和应用程序 “分离” 开，但又希望库函数可以被调用，此时就需要动态链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态链接：机制&lt;/p&gt;
&lt;h1 id=&#34;&#34;&gt;
&lt;/h1&gt;&lt;p&gt;实现运行库和应用代码分离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用之间的库共享&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个程序都需要 glibc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但系统里只需要&lt;/p&gt;
&lt;p&gt;一个副本&lt;/p&gt;
&lt;p&gt;就可以了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是的，我们可以用 ldd 命令查看&lt;/li&gt;
&lt;li&gt;运行库和应用代码还可以分别独立升级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大型项目的分解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改一行代码不用重新链接 2GB 的文件&lt;/li&gt;
&lt;li&gt;libjvm.so, libart.so, &amp;hellip;共享库文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只读方式 mmap 同一个文件，物理内存中只有一个副本&lt;/strong&gt;，分页的机制，使得内存的处理更灵活，无需多个物理副本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题：怎么判断是否需要链接进来共享库？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态链接的本质是 “运行时绑定地址”，&lt;code&gt;PLT/GOT&lt;/code&gt; 是实现这一逻辑的底层表；环境变量 &lt;code&gt;LD_PRELOAD&lt;/code&gt; 则是利用动态链接的加载顺序，实现库的 “运行时替换”（加入本地的库）。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>密码学</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
        <pubDate>Sat, 25 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%AF%86%E7%A0%81%E5%AD%A6/</guid>
        <description>&lt;h2 id=&#34;引言与古典密码体制&#34;&gt;引言与古典密码体制
&lt;/h2&gt;&lt;h3 id=&#34;基础知识&#34;&gt;基础知识
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密和公钥加密&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据消息发送方和接收方使用的&lt;strong&gt;加密和解密密钥是否相同&lt;/strong&gt;， 加密方案可分为对称加密和公钥加密。
&lt;ul&gt;
&lt;li&gt;==公加私解==&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息认证码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息发送方和接收方首先&lt;strong&gt;共享一个密钥&lt;/strong&gt;，发送方为待发送的消息产生一个标识，并将&lt;strong&gt;消息和标识一同发送&lt;/strong&gt;给接收方。&lt;/li&gt;
&lt;li&gt;用于标志消息息在传递过程中没有被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将任意长的消息&lt;strong&gt;映射&lt;/strong&gt;为一个“较短的” “定长的” 抗碰撞的”消息&lt;strong&gt;摘要&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于保护数据完整性，防篡改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字签名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在数字世界中实现了“手写签名”的功能，保证了被签名消息的完整性和不可否认性。&lt;/li&gt;
&lt;li&gt;案基于公钥密码体制：发送者使用自己的私钥对消息进行签名，接收者使用签名者的公钥验证数字签名的合法性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;现代密码学发展史&#34;&gt;现代密码学发展史
&lt;/h3&gt;&lt;p&gt;1940 ==香农==证明了一次一密的安全性&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;K 密钥空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M 明文空间：现代密码学中，M是二进制字符串的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 密文空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密方案(Gen; Enc; Dec)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gen ：K (概率性的) 密钥生成算法。&lt;/li&gt;
&lt;li&gt;Enc : K x M→C 加密算法。&lt;/li&gt;
&lt;li&gt;Dec : K x C →M 解密算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;科尔霍夫原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密码算法的安全性应该依赖于密钥k的保密性,而不应依赖于算法 Gen;Enc; Dec 的保密性。&lt;/li&gt;
&lt;li&gt;理由：
&lt;ul&gt;
&lt;li&gt;算法设计保密是不切实际的（逆向工程）。&lt;/li&gt;
&lt;li&gt;短密钥更容易保护、生成和替换。&lt;/li&gt;
&lt;li&gt;密码设计应该被公开讨论和分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;古典密码&#34;&gt;古典密码
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单表代换
&lt;ul&gt;
&lt;li&gt;移位密码：如凯撒密码、仿射密码&lt;/li&gt;
&lt;li&gt;密文空间小时，直接爆破&lt;/li&gt;
&lt;li&gt;密文空间大时，用字母频率猜测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025110458839.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025110458839&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多表代换
&lt;ul&gt;
&lt;li&gt;选择一串字符作为密钥，明文字符“加上”密钥字符得到密文字符&lt;/li&gt;
&lt;li&gt;多表代换密码是安全的：密钥长度等于明文长度&lt;/li&gt;
&lt;li&gt;当密钥长度小于明文长度时，多表代换密码易受到统计攻 击。
&lt;ul&gt;
&lt;li&gt;先确定密钥周期&lt;/li&gt;
&lt;li&gt;拆分部分，分别频率检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对称加密&#34;&gt;对称加密
&lt;/h2&gt;&lt;h3 id=&#34;完善保密性&#34;&gt;完善保密性
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高熵、均匀一致、随机&lt;/li&gt;
&lt;li&gt;现代随机数生成步骤：收集高熵数据、产生几乎独立无偏的比特串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完善保密性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取密文的行为不改变敌手对所发送的实际消息的知识&lt;/li&gt;
&lt;li&gt;密文不应泄露有关底层明文的额外信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251115084315412.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251115084315412&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识 vs 信息&lt;/p&gt;
&lt;p&gt;信息是公开可用的，可直观获取的。
知识是困难计算的结果，任何人都能有效获得的都不能称为知识。应用于公开可用信息的简单计算的结果不被认为是知识。应用于公共可用信息的难以计算的函数的结果是知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;&#34;&gt;
&lt;/h3&gt;&lt;h3 id=&#34;流密码和分组密码&#34;&gt;流密码和分组密码
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在实际中，PRG是使用流密码&lt;strong&gt;实例化&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;PRP是使用分组密码进行&lt;strong&gt;实例化&lt;/strong&gt;的。实际上，PRP也被称为分组密码。&lt;/li&gt;
&lt;li&gt;但是 Block cipher 不是一种加密方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;流密码&#34;&gt;流密码
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251115085905004.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251115085905004&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251115090331493.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251115090331493&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大致就是切分明文串来加密，密钥流是用单密钥随机产生的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种操作模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步模式
&lt;ul&gt;
&lt;li&gt;有状态，消息按顺序接收、加密&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步模式
&lt;ul&gt;
&lt;li&gt;无状态，每个块密钥流独立&lt;/li&gt;
&lt;li&gt;每个密钥流独立生成（有自己的生成器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251115091250140.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251115091250140&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;设计原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;混淆原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使密钥和密文之间的依赖关系尽可能模糊。即使敌手获取了一些&lt;strong&gt;密文的统计特性&lt;/strong&gt;,也无法推测密钥。常使用代替方法实现混淆。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩散原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使明文和密文的关系变得尽可能的复杂,即密文中的每 一位&lt;strong&gt;受明文中的许多位的影响&lt;/strong&gt;。常使用置换方法实现扩散&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乘积密码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也叫迭代密码,通过轮函数的多次迭代,对数据重复迭代操作,实现扩散与混淆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分组密码的迭代方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代换-置换SP网络(substitution-permutation)-Feistel网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>大学物理（下）</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</guid>
        <description>&lt;p&gt;参考视频：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1XJCzYyEcp/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=f329e64c57c95b7adedc05b814353e29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《大学物理-电磁学》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;电学&#34;&gt;电学
&lt;/h2&gt;&lt;h3 id=&#34;电场强度&#34;&gt;电场强度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;库伦定律：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170518198.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170518198&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场强度：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170530237.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170530237&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170718333.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170718333&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于圆弧来说：&lt;code&gt;dl = Rdθ&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一些结论：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171213318.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171213318&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电通量高斯定理&#34;&gt;电通量、高斯定理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电通量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171321846.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171321846&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静电场中高斯定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171356058.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171356058&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171439634.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171439634&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电势&#34;&gt;电势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电势&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171535545.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171535545&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电势能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171635919.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171635919&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场和电势的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171726047.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171726047&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171927866.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171927866&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;导体&#34;&gt;导体
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171823961.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171823961&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么内部场强为零？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;导体上的电荷可以自由移动，移动后形成电场，与外部场强相抵消&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内部包围有电荷 q 时，导体上电荷分布？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;导体内层会感应出 -q，外层变为 Q+q。由高斯定理配合导体内场强为零，可知导体内部的 E * S = 0，故 q + -q = 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;传导电流&#34;&gt;传导电流
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;若将导体的两端接到电源上, 导体中便有持续的电流，这种存在导体中的电流称为传导电流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;电流密度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095303355.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095303355&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欧姆定律的微分形式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095359037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095359037&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳恒电流
&lt;ul&gt;
&lt;li&gt;可推导出基尔霍夫定律&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095500684.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095500684&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电动势&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095617717.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095617717&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;电容器&#34;&gt;电容器
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182756902.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182756902&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串并联
&lt;ul&gt;
&lt;li&gt;串联时电荷相等&lt;/li&gt;
&lt;li&gt;并联时电压相等 C = C1 + …… + Cn&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182817615.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182817615&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182927084.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182927084&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电解质电场能&#34;&gt;电解质、电场能
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电介质高斯定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183119795.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183119795&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183208273.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183208273&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;磁学&#34;&gt;磁学
&lt;/h2&gt;&lt;h3 id=&#34;磁感应强度&#34;&gt;磁感应强度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;判断方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183346633.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183346633&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;毕奥萨法尔定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183609069.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183609069&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183630106.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183630106&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;安培环路定理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183711892.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183711892&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183817018.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183817018&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;磁通量高斯定理&#34;&gt;磁通量、高斯定理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184030312.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184030312&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184138965.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184138965&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安培力磁矩洛伦兹力&#34;&gt;安培力、磁矩、洛伦兹力
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安培力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184231717.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184231717&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁矩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184416546.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184416546&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;洛伦兹力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184541583.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184541583&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;磁介质磁场能&#34;&gt;磁介质、磁场能
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;磁介质&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184643080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184643080&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁场能量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184725420.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184725420&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>概率论</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%A6%82%E7%8E%87%E8%AE%BA/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%A6%82%E7%8E%87%E8%AE%BA/</guid>
        <description>&lt;p&gt;参考视频：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1N8BbY8E15/?p=2&amp;amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;amp;vd_source=f329e64c57c95b7adedc05b814353e29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;概率论四小时速成&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;随机事件与概率&#34;&gt;随机事件与概率
&lt;/h2&gt;&lt;h3 id=&#34;事件关系与运算率&#34;&gt;事件关系与运算率
&lt;/h3&gt;&lt;p&gt;事件关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075205102.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075205102&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;运算律：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075254990.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075254990&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;概率计算性质&#34;&gt;概率计算性质
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075336338.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075336338&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注意：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080231202.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080231202&#34;
	
	
&gt;对于多项依然成立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合并 == 概率 +&lt;/p&gt;
&lt;p&gt;集合且 == 概率 ·&lt;/p&gt;
&lt;p&gt;补充：容斥原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;条件概率&#34;&gt;条件概率
&lt;/h3&gt;&lt;p&gt;条件概率与乘法公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080612196.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080612196&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;事件的独立性&#34;&gt;事件的独立性
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080750938.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080750938&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;独立不互斥，互斥不独立&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080945953.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080945953&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多事件独立性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080829872.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080829872&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;全概率 - 贝叶斯公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081025058.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081025058&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;随机变量分布&#34;&gt;随机变量分布
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分布函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081325900.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081325900&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081339289.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081339289&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;概率 - 分布函数关系：配凑出范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081425038.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081425038&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分布函数的充要条件：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081621331.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081621331&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等号跟大于走，永远右连续&lt;/p&gt;
&lt;p&gt;根据规范性、右连续性，可以用极限解方程求参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常识结论：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081839150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081839150&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;离散型随机变量&#34;&gt;离散型随机变量
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081922286.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081922286&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布律可以写成表格的形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;古典概型：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082007258.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082007258&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据分布律写分布函数：
&lt;ul&gt;
&lt;li&gt;根据定义域划分范围，依次求和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;二项分布&#34;&gt;二项分布
&lt;/h4&gt;&lt;p&gt;独立重复、事件 A 发生的次数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082320081.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082320081&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082421022.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082421022&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;几何概型：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082537602.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082537602&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;几何分布&#34;&gt;几何分布
&lt;/h4&gt;&lt;p&gt;事件首次发生的概率&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082634533.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082634533&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;二项-01-分布&#34;&gt;二项 01 分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082836415.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082836415&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;泊松分布&#34;&gt;泊松分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084237766.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084237766&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一个代换：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084307855.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084307855&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;连续型随机变量&#34;&gt;连续型随机变量
&lt;/h3&gt;&lt;h4 id=&#34;概率密度&#34;&gt;概率密度：
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084626738.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084626738&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概率为 0 的事件可能发生&lt;/p&gt;
&lt;p&gt;概率密度的积分就成为概率 &amp;ndash;&amp;gt; 在哪求概率，就在哪求积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;充要条件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084813110.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084813110&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与分布函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085101165.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085101165&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分定义域求积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;均匀分布&#34;&gt;均匀分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085829523.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085829523&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;指数分布&#34;&gt;指数分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085945280.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085945280&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用指数分布的无记忆性，转换区间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;正态分布&#34;&gt;正态分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022090654026.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022090654026&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准化：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022090834007.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022090834007&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先变换为标准正态，再求概率（用标准正态的分布函数表示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022091436382.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022091436382&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据形式配凑&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022091554558.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022091554558&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;已知-x求-fx-的分布函数&#34;&gt;已知 X，求 f(X) 的分布函数
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022092554592.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022092554592&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关键在于根据 Y &amp;lt;= y 转换出 X ~ y 关系，用 X 的分布函数代换出 Y 的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二维随机变量&#34;&gt;二维随机变量
&lt;/h2&gt;&lt;h3 id=&#34;离散型&#34;&gt;离散型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;联合分布律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094458316.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094458316&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094526051.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094526051&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094540253.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094540253&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 p_ij = 0，一定不独立&lt;/p&gt;
&lt;p&gt;独立 == 各行（列）成比例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;连续型&#34;&gt;连续型
&lt;/h3&gt;&lt;h4 id=&#34;分布密度概率&#34;&gt;分布密度、概率
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094731080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094731080&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找区域，二重积分即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;独立性&#34;&gt;独立性
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022095256614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022095256614&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;边缘密度&#34;&gt;边缘密度
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022095512292.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022095512292&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对另一个变量积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;条件概率密度&#34;&gt;条件概率密度
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022100004051.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022100004051&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;固定某个参数后，概率密度只域另一个参数有关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;二位均匀&#34;&gt;二位均匀
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022100325862.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022100325862&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求面积之比即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;最大最小值分布&#34;&gt;最大、最小值分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022102611138.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022102611138&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;二维连续型函数分布&#34;&gt;二维连续型函数分布
&lt;/h4&gt;&lt;p&gt;分布函数法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022130118656.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022130118656&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;换元&lt;/li&gt;
&lt;li&gt;做正概区域范围 D_z 和 g(x,y) 观察交集&lt;/li&gt;
&lt;li&gt;根据 z 从负无穷到正无穷，对 x，y 积分（z 作为常数）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022130946531.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022130946531&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要可以反解出 y 才可使用，替换 x 或 y 以后，再乘上偏导&lt;/p&gt;
&lt;p&gt;注意定义域的选定&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>数据结构与算法</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;img src="https://raw.githubusercontent.com/calendar0917/images/master/20251022104404297.png" alt="Featured image of post 数据结构与算法" /&gt;&lt;h2 id=&#34;绪论&#34;&gt;绪论
&lt;/h2&gt;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形式定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构是一个四元组 &lt;code&gt;Data_Structure=（D,L,S,O）&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;D是数据元素的有限集&lt;/li&gt;
&lt;li&gt;L是D上客观存在的关系（&lt;strong&gt;逻辑结构&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;S是关系L在计算机中的存储表示（&lt;strong&gt;存储结构&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;O是D上规定的一组操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集合（set）—若干具有共同特征的事物的“聚合”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据（data) —所有能输入到计算机中的描述客观事物的符号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据元素（data element）—数据的基本单位，也称节点（node）或记录（record）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据项（data item）—有独立含义的数据最小单位，也称域(field)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键码（key）—数据元素中能起标识作用的数据项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 —集合中元素之间的某种相关性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性结构：一对一，线性表、栈、队列等&lt;/li&gt;
&lt;li&gt;树形结构&lt;/li&gt;
&lt;li&gt;图状结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序：借助相对位置表示元素间关系&lt;/li&gt;
&lt;li&gt;链式：借助指针&lt;/li&gt;
&lt;li&gt;散列：通过对关键字直接计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为了解决某类问题而规定的一个有限长的操作序列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特性：有穷、确定、可行、功能性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标：正确、可读、健壮、高效率与低存储量需求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;衡量方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间特性用执行基本操作次数来度量&lt;/li&gt;
&lt;li&gt;算法的空间特性用算法运行所需存储量的增长率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线性表栈与队列&#34;&gt;线性表、栈与队列
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线性结构特点：在数据元素的非空有限集中
&lt;ul&gt;
&lt;li&gt;存在唯一一个称作“&lt;strong&gt;第一个&lt;/strong&gt;”的数据元素&lt;/li&gt;
&lt;li&gt;存在唯一一个称作“&lt;strong&gt;最后一个&lt;/strong&gt;”的数据元素&lt;/li&gt;
&lt;li&gt;除第一个外，集合中的每个数据元素均&lt;strong&gt;只有一个前驱&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;除最后一个外，集合中的每个数据元素均&lt;strong&gt;只有一个后继&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线性表&#34;&gt;线性表
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：一个线性表是n个数据元素的有限序列
&lt;ul&gt;
&lt;li&gt;元素个数n = 表长度&lt;/li&gt;
&lt;li&gt;a_1 无直接前驱，a_n 无直接后继&lt;/li&gt;
&lt;li&gt;i 为 a_i 再线性表中的位序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;顺序存储&#34;&gt;顺序存储
&lt;/h4&gt;&lt;p&gt;逻辑上相邻 - 物理地址相邻&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入：复杂度 &lt;code&gt;n/2&lt;/code&gt;，算在 i 出的平均移动次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除：复杂度 &lt;code&gt;(n-1)/2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑相邻，物理相邻&lt;/li&gt;
&lt;li&gt;可随机存取任一元素&lt;/li&gt;
&lt;li&gt;存储空间使用紧凑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入、删除操作需要移动大量的元素&lt;/li&gt;
&lt;li&gt;预先分配空间需按最大空间分配，利用不充分&lt;/li&gt;
&lt;li&gt;表容量难以扩充&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;链式存储&#34;&gt;链式存储
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;用一组任意的存储单元存储线性表的数据元素，利用指针实现：&lt;strong&gt;用不相邻的存储单元存放逻辑上相邻的元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;单链表&#34;&gt;单链表
&lt;/h5&gt;&lt;p&gt;结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;ElemType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNodePtr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 生成新节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNodePtr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 回收节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入、删除：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态结构，整个存储空间为多个链表共用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需预先分配空间，指针额外存储空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能随机读取，查找慢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;循环链表&#34;&gt;循环链表
&lt;/h5&gt;&lt;p&gt;表中最后一个结点的指针指向头结点，使链表构成环状&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从表中任一结点出发均可找到表中其他结点， 提高查找效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;操作与单链表基本一致,循环条件不同：
&lt;ul&gt;
&lt;li&gt;单链表 p 或 &lt;code&gt;p-&amp;gt;next=NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环链表 &lt;code&gt;p-&amp;gt;next=h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;双向链表&#34;&gt;双向链表
&lt;/h5&gt;&lt;p&gt;解决单链表单向性的问题，存储前、后指针&lt;/p&gt;
&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;h4 id=&#34;顺序存储-1&#34;&gt;顺序存储
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义：
&lt;ul&gt;
&lt;li&gt;限定仅在表尾进行插入或删除操作的线性表，进行操作的一端称栈顶，固定的一端称栈底，不含元素的空表称空栈。&lt;/li&gt;
&lt;li&gt;先进后出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作：
&lt;ul&gt;
&lt;li&gt;用指针 &lt;code&gt;top&lt;/code&gt; 始终指向栈顶，初值为 -1 （栈空），终值为 M-1 （栈满）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define MAXSTACK 100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;StackEntry&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MAXSTACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;链式存储-1&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;top 始终指向下一个插入的位置，类似&lt;/p&gt;
&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;p&gt;限定只能在表的一端进行插入，在表的另一端进行删除的线性表，&lt;code&gt;先进先出&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;链式存储-2&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;设队首、队尾指针 front 和rear, front 指向头结点，rear 指向队尾&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列不满时假溢出、队列满时真溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;队首固定：需要频繁移动 X&lt;/li&gt;
&lt;li&gt;循环队列：将队列设计成环形，让 &lt;code&gt;让sq[0]&lt;/code&gt; 接在 &lt;code&gt;sq[M-1]&lt;/code&gt; 之后，若 rear == M，则令 rear = 0
&lt;ul&gt;
&lt;li&gt;问题：队空和队满标志一样&lt;/li&gt;
&lt;li&gt;解决：另设标志位、少用一个元素空间、用一个计数变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;优先队列&#34;&gt;优先队列
&lt;/h4&gt;&lt;p&gt;不完全遵守先进先出，设有优先级&lt;/p&gt;
&lt;h3 id=&#34;数组&#34;&gt;数组
&lt;/h3&gt;&lt;h4 id=&#34;顺序存储-2&#34;&gt;顺序存储：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要区分列主序、行主序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Loc (j1, j2, ... , jn )=Loc (0, 0, ... , 0)+(b2*b3*...*bn*j1 + b3*b4*...*bn*j2+ ...+bn*jn-1+ jn)*l&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三角矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025143824138.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025143824138&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三对角矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025143918477.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025143918477&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;稀疏矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025144028082.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025144028082&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;链式存储-3&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;表示矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组 + 链表&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025145127520.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025145127520&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;查找排序递归&#34;&gt;查找、排序、递归
&lt;/h2&gt;&lt;h3 id=&#34;递归&#34;&gt;递归
&lt;/h3&gt;&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个过程或函数出现调用本过程或本函数的成分,称之为递归。&lt;/li&gt;
&lt;li&gt;若调用自身,称之为&lt;strong&gt;直接递归&lt;/strong&gt;。若过程或函数p调用过程或函数q,而q又调用 p,称之为&lt;strong&gt;间接递归&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果一个递归过程或递归函数中递归调用语句是最后一条执行语句,则称这种递归调用为&lt;strong&gt;尾递归&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找
&lt;/h3&gt;&lt;h4 id=&#34;顺序表&#34;&gt;顺序表
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;顺序查找，改变 &lt;code&gt;R[0]&lt;/code&gt; 以控制结束：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seqsearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;折半查找，对于有序表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BinarySearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;c1&#34;&gt;//在长度为n的有序表SL中折半查找其关键字等于key的数据元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;//查找成功返回其在有序表中的位置，查找失败否返回0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;}&lt;/span&gt;              
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;索引表查找
&lt;ul&gt;
&lt;li&gt;基本思想：将&lt;strong&gt;原表分成若干块&lt;/strong&gt;，各块内部不一定有序，但表中的块是“&lt;strong&gt;分块有序&lt;/strong&gt;”的，&lt;strong&gt;抽取各块中的最大关键字&lt;/strong&gt;及其起始位置建立索引表。&lt;/li&gt;
&lt;li&gt;块间顺序：复杂度 &lt;code&gt;1/2 * (n/s + s) + 1&lt;/code&gt; (n 长度，分成 n/s 块)&lt;/li&gt;
&lt;li&gt;块间二分：&lt;code&gt;log_2(n/s + 1) + s/2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IndexSequelSearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IndexType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;c1&#34;&gt;//索引表中顺序查找关键字为key的记录。索引表为ls[0]-ls[m-1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//顺序表为s，块长为l
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//在索引表中顺序查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//块间查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;//在块内顺序查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                  &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Link&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Link&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                   &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;哈希表查找
&lt;ul&gt;
&lt;li&gt;以 &lt;code&gt;h(key) 哈希函数&lt;/code&gt; 作为 key 的记录在表中的位置，常见构造方法有：
&lt;ul&gt;
&lt;li&gt;直接哈希：适用于地址集合大小 == 关键字集合大小&lt;/li&gt;
&lt;li&gt;数字分析：取随机&lt;/li&gt;
&lt;li&gt;平方取中：取关键字平方后的中间几位&lt;/li&gt;
&lt;li&gt;折叠：关键字分割后求和&lt;/li&gt;
&lt;li&gt;除留取余：除某个不大于哈希表长度的数后取余&lt;/li&gt;
&lt;li&gt;随机数：取随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突处理方法：
&lt;ul&gt;
&lt;li&gt;开放地址：线性探测、平方探测、随机探测 再散列&lt;/li&gt;
&lt;li&gt;再哈希：将 n 个不同哈希函数排成序列，往下计算&lt;/li&gt;
&lt;li&gt;链地址：将关键字发生冲突的记录存储在一个线性链表中&lt;/li&gt;
&lt;li&gt;公共溢出：将发生冲突的放在冲突表中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ALS 影响因素：
&lt;ul&gt;
&lt;li&gt;选用的哈希函数&lt;/li&gt;
&lt;li&gt;冲突处理方法&lt;/li&gt;
&lt;li&gt;哈希表饱和度、装载因子 &lt;code&gt;n/m&lt;/code&gt; 的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序
&lt;/h3&gt;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;稳定性：对于任意的数据元素序列，以在排序前后&lt;strong&gt;相同关键字数据的相对位置&lt;/strong&gt;是否改变为依据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内外部：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需借助外存，称内部排序&lt;/li&gt;
&lt;li&gt;数据量巨大，需要借助外村，称外部排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;插入&#34;&gt;插入
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;直接插入：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;在&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;中查找&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的插入位置&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;err&#34;&gt;插入&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025154450647.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025154450647&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;折半插入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 &lt;code&gt;R[1..i-1]&lt;/code&gt; 是一个按关键字有序的有序序列，则可以利用折半查找实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希尔排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;strong&gt;n较大而且无序时&lt;/strong&gt;，直接插入排序效率就较低，这时，如果能&lt;strong&gt;将序列分成几个较小的序列&lt;/strong&gt;，对这些较小的序列先排序，然后再对较长的序列进行排序，可一定程度地提高排序效率。&lt;/li&gt;
&lt;li&gt;步骤：
&lt;ul&gt;
&lt;li&gt;先选取一个小于n的整数di（步长），然后把待排序的序列分成di个组&lt;/li&gt;
&lt;li&gt;第一趟完成之后，减小步长，再进行分组，再排序，如此知道 d=1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;交换&#34;&gt;交换
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;冒泡排序
&lt;ul&gt;
&lt;li&gt;基于两两比较及交换，直到某一趟没有发生数据的交换为止。&lt;/li&gt;
&lt;li&gt;改进：记下上次交换的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Bubble_Sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//对长度为n的序列R按升序进行冒泡排序，降序排序类似
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//交换标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 可以改进成 j&amp;lt;i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;不满足升序规则，交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//此趟冒泡没有发生交换，排序结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025160526177.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025160526177&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;图和贪心算法&#34;&gt;图和贪心算法
&lt;/h2&gt;&lt;h3 id=&#34;贪心&#34;&gt;贪心
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例：活动安排问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将输入的活动按结束时间的非降序排列，只需 O(n) 即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个问题的最优解包含其子问题的最优解时，称此问题具有&lt;strong&gt;最优子结构&lt;/strong&gt;性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。证明需用归纳证明。&lt;/p&gt;
&lt;p&gt;例：0-1 背包问题&lt;/p&gt;
&lt;p&gt;贪心不适用，应该比较选择 / 不选择该物品导致的最优方案&lt;/p&gt;
&lt;p&gt;例：多机调度问题&lt;/p&gt;
&lt;h3 id=&#34;图&#34;&gt;图
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;图G是由两个集合 V(G) 和 E(G) 组成的,记为G=(V,E)其中：V(G)是顶点的非空有限集、E(G)是边的有限集合，边是顶点的无序对或有序对&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一些基本概念，这里略过，参考离散数学&lt;/p&gt;
&lt;h4 id=&#34;存储结构&#34;&gt;存储结构
&lt;/h4&gt;&lt;h5 id=&#34;顺序结构&#34;&gt;顺序结构
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵&lt;/strong&gt;：表示顶点间关系的矩阵，即点*点的矩阵，若两点间有边相连，则标记为 1（或者有权值）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119113908302.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119113908302&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联矩阵&lt;/strong&gt;：表示顶点与边的关联关系，即点*边的矩阵，边的两顶点记为 1 或 -1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119114214398.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119114214398&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;链式存储-4&#34;&gt;链式存储
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;邻接表&lt;/strong&gt;：为图中每个顶点建立一个单链表，第 i 个单链表中的结点表示依附于顶点V的边（有向图中指以V为尾的弧）。即每条边对应一个非头节点，由头指向尾（反过来就是&lt;strong&gt;逆邻接表&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119114405412.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119114405412&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十字链表&lt;/strong&gt;：节点间以弧尾相同连接，包含弧尾、弧头位置以及弧尾弧头相同的下一条弧。&lt;/p&gt;
&lt;p&gt;定义：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119114640071.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119114640071&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119114709034.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119114709034&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一下弧头和弧尾的区分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;无向图邻接多重表&lt;/strong&gt;：节点间以顶点相同互相连接&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251119115152427.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119115152427&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;图的遍历&#34;&gt;图的遍历
&lt;/h4&gt;&lt;p&gt;深度优先（DFS）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法：从图的某一顶点Vo出发，访问此顶点，然后依次从Vo的未被访问的邻接点出发，深度优先遍历图直至图中有和V0相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;广度优先（BFS）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法：从图的某一顶点Vo出发，访问此顶点后，依次访问V0的各个未曾访问过的邻接点：然后分别从这些邻接点出发，广度优先遍历图，直至图中所有已被访问的顶点的邻接点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上迷过程，直至图中所有顶点都被访问为止&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>计算机组成原理</title>
        <link>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
        <pubDate>Fri, 03 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;hr&gt;
&lt;h2 id=&#34;第一章-计算机系统概述&#34;&gt;第一章 计算机系统概述
&lt;/h2&gt;&lt;h3 id=&#34;计算机系统的发展&#34;&gt;计算机系统的发展
&lt;/h3&gt;&lt;p&gt;计算机系统 = 硬件 + 软件&lt;/p&gt;
&lt;h4 id=&#34;软件&#34;&gt;软件
&lt;/h4&gt;&lt;p&gt;系统软件：用来管理整个计算机系统&lt;/p&gt;
&lt;p&gt;应用软件：按任务需要编制成的程序&lt;/p&gt;
&lt;h4 id=&#34;硬件&#34;&gt;硬件
&lt;/h4&gt;&lt;p&gt;第一台电子数字计算机：&lt;strong&gt;ENIAC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑元件（用于处理电信号的最小单元）：电子管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;十进制表示，手动编程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无冯 · 诺伊曼结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二代：晶体管&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带）&lt;/li&gt;
&lt;li&gt;特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。&lt;/li&gt;
&lt;li&gt;软件：使用高级语言，提供系统软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三代：中小规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件和主存储器均由&lt;strong&gt;集成电路&lt;/strong&gt;实现。&lt;/li&gt;
&lt;li&gt;特点：微程序控制，Cache，虚拟存储器，流水线。&lt;/li&gt;
&lt;li&gt;代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IBM 360（&lt;strong&gt;兼容机&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;相同/相似的指令集&amp;amp;操作系统。&lt;/p&gt;
&lt;p&gt;好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。&lt;/p&gt;
&lt;p&gt;保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;DEC PDP-8（&lt;strong&gt;采用总线结构&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第四代：大规模、超大规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半导体存储器，微处理器发展迅速。&lt;/li&gt;
&lt;li&gt;特点：共享存储器，分布式存储器以及大规模并行系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组成&#34;&gt;组成
&lt;/h3&gt;&lt;h4 id=&#34;冯诺依曼结构模型&#34;&gt;冯诺依曼结构模型
&lt;/h4&gt;&lt;p&gt;冯诺依曼提出&lt;strong&gt;存储程序&lt;/strong&gt;，取代手动接线。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冯诺依曼结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。&lt;/li&gt;
&lt;li&gt;各基本部件功能：
&lt;ol&gt;
&lt;li&gt;存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；&lt;/li&gt;
&lt;li&gt;控制器应能自动执行指令；&lt;/li&gt;
&lt;li&gt;运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；&lt;/li&gt;
&lt;li&gt;操作人员可以通过输入设备和输出设备与主机进行通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内部以&lt;strong&gt;二进制数&lt;/strong&gt;表述指令和数据
&lt;ol&gt;
&lt;li&gt;每条指令由&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;地址码&lt;/strong&gt;两部分组成。操作码指出操作的类型，地址码指出操作数的地址。&lt;/li&gt;
&lt;li&gt;由一串指令组成程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;工作方式
&lt;ol&gt;
&lt;li&gt;将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/20251003090538614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本部件及其功能&#34;&gt;基本部件及其功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;运算器（数据运算）：ALU、GPRs、标志寄存器等。&lt;/li&gt;
&lt;li&gt;存储器（数据存储）：存储阵列、地址译码器、读写控制电路&lt;/li&gt;
&lt;li&gt;总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线&lt;/li&gt;
&lt;li&gt;控制器（控制）：对指令译码生成控制信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU = 运算器 + 控制器&lt;/p&gt;
&lt;p&gt;主机 = CPU + 主存&lt;/p&gt;
&lt;h4 id=&#34;各硬件工作原理&#34;&gt;各硬件工作原理
&lt;/h4&gt;&lt;h5 id=&#34;主存储器&#34;&gt;主存储器
&lt;/h5&gt;&lt;p&gt;主存储器 = 存储体 + MAR + MDR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数&lt;/li&gt;
&lt;li&gt;Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令）&lt;/li&gt;
&lt;li&gt;存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1B = 1 byte ; 1 b = 1 bit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;MAR、MDR 逻辑上属于主存，但被集成到 CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;运算器&#34;&gt;运算器
&lt;/h5&gt;&lt;p&gt;实现算数运算、逻辑运算&lt;/p&gt;
&lt;p&gt;运算器 = ACC + ALU + MQ + X&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accumulator：累加器，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算&lt;/li&gt;
&lt;li&gt;X：通用的操作数寄存器，用于存放操作数&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;控制器&#34;&gt;控制器
&lt;/h5&gt;&lt;p&gt;控制器 = CU + IR +PC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Control Unit:控制单元，分析指令，给出控制信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instruction Register:指令寄存器，存放当前执行的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Program Counter:程序计数器，存放下一条指令地址，有自动加1功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配合&#34;&gt;配合
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003094316150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003094316150&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;指令和数据&#34;&gt;指令和数据
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序启动前，指令和数据都存储在存储器中，&lt;strong&gt;形式上没有区别&lt;/strong&gt;，都是 0/1 序列。&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。&lt;/li&gt;
&lt;li&gt;指令执行过程中，指令和数据从存储器取到 CPU，&lt;strong&gt;指令存在 IR 中，数据在 GPR 中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令需要给出的信息
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作码&lt;/strong&gt;：指令的操作，加减法等&lt;/li&gt;
&lt;li&gt;一个或多个&lt;strong&gt;源操作数&lt;/strong&gt;：立即数、寄存器编号、存储地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的操作数地址&lt;/strong&gt;：寄存器编号、存储地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;执行过程&#34;&gt;执行过程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序执行前
&lt;ul&gt;
&lt;li&gt;数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始执行程序
&lt;ul&gt;
&lt;li&gt;根据 PC &lt;strong&gt;取指&lt;/strong&gt;令送 IR：PC -&amp;gt; MAR -&amp;gt;存储器 -&amp;gt; MDR -&amp;gt; IR&lt;/li&gt;
&lt;li&gt;指令&lt;strong&gt;译码&lt;/strong&gt;：IR -&amp;gt; 控制器，控制器译码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取操作数&lt;/strong&gt;：GPRs 或存储器 -&amp;gt; ALU&lt;/li&gt;
&lt;li&gt;执行指令操作：ALU &lt;strong&gt;运算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回写&lt;/strong&gt;结果到 GPRs 或存储器&lt;/li&gt;
&lt;li&gt;修改 &lt;strong&gt;PC&lt;/strong&gt; 的值，使其指向&lt;strong&gt;下一条指令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;重复上述步骤直到程序完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;软件-1&#34;&gt;软件
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统软件——简化编程，&lt;strong&gt;使硬件资源被有效利用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：硬件资源管理，用户接口&lt;/li&gt;
&lt;li&gt;语言处理程序：翻译程序，Linker，Debug&amp;hellip;
&lt;ul&gt;
&lt;li&gt;翻译程序
&lt;ul&gt;
&lt;li&gt;汇编器（Assembler）：汇编语言源程序-&amp;gt;机器目标程序。或许叫汇编器更好理解？&lt;/li&gt;
&lt;li&gt;编译器（Complier）：高级语言程序-&amp;gt;汇编/机器目标程序。或许叫编译器更好理解？&lt;/li&gt;
&lt;li&gt;解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他实用程序：磁盘碎片整理、备份程序&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;机器语言：二进制代码&lt;/p&gt;
&lt;p&gt;汇编语言：助记符&lt;/p&gt;
&lt;p&gt;高级语言：C、C++、……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用软件——解决&lt;strong&gt;具体的应用&lt;/strong&gt;问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;层次结构&#34;&gt;层次结构
&lt;/h3&gt;&lt;h4 id=&#34;语言层次&#34;&gt;语言层次
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;微指令系统：直接控制硬件执行&lt;/li&gt;
&lt;li&gt;机器语言：传统机器M1，执行二进制机器指令&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作系统机器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编语言：虚拟机器M2，用汇编语言翻译成机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级语言：虚拟机器M3，需要编译成汇编、机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上两层视为硬件层&lt;/p&gt;
&lt;p&gt;计算机体系结构：讨论如何设计硬件与软件之间的接口&lt;/p&gt;
&lt;p&gt;计算机组成原理：讨论如何用硬件实现接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003100912264.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003100912264&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;isa&#34;&gt;ISA
&lt;/h4&gt;&lt;p&gt;指令集体系结构，其作为&lt;strong&gt;规约&lt;/strong&gt;，规定了&lt;strong&gt;如何使用硬件&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行的指令集合，包括&lt;strong&gt;指令格式&lt;/strong&gt;、&lt;strong&gt;操作种类&lt;/strong&gt;以及对应&lt;strong&gt;操作数&lt;/strong&gt;的规定。&lt;/li&gt;
&lt;li&gt;可以接受的&lt;strong&gt;操作数类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数存放的&lt;strong&gt;寄存器组结构&lt;/strong&gt;，例如寄存器名称、编号、长度和用途。&lt;/li&gt;
&lt;li&gt;操作数存放的存储空间的&lt;strong&gt;大小和编址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数在存储空间中按&lt;strong&gt;大/小端&lt;/strong&gt;方式存放。&lt;/li&gt;
&lt;li&gt;指令获得操作数的方式，即&lt;strong&gt;寻址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令执行过程的&lt;strong&gt;控制方式&lt;/strong&gt;，例如程序计数器，条件码定义等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ISA 是计算机系统中&lt;strong&gt;必不可少的抽象层&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;性能指标&#34;&gt;性能指标
&lt;/h3&gt;&lt;h4 id=&#34;存储器&#34;&gt;存储器
&lt;/h4&gt;&lt;p&gt;总容量 = 存储单元个数 * 存储字长(bit)&lt;/p&gt;
&lt;h4 id=&#34;cpu&#34;&gt;CPU
&lt;/h4&gt;&lt;h5 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主频：CPU内数字脉冲信号振荡的频率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;= 1 / 时钟周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPS：每秒执行多少个命令 = 主频 / 平均CPI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FLOPS：每秒执行多少次浮点运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;K=Kilo=千=10^3&lt;/p&gt;
&lt;p&gt;M=Million=百万=10^6&lt;/p&gt;
&lt;p&gt;G=Giga=十亿=10^9&lt;/p&gt;
&lt;p&gt;T=Tera=万亿=10^12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：单位时间内处理请求的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相应时间：CPU时间 + 等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准程序：用于测量的程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于&lt;strong&gt;单条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;MIPS 为平均值，其并没有考虑以上三个属性，并且由于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同机器指令集不同&lt;/li&gt;
&lt;li&gt;程序由不同指令混合而成&lt;/li&gt;
&lt;li&gt;指令的频率会动态变换&lt;/li&gt;
&lt;li&gt;厂家给出峰值 MIPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，MIPS 表示性能存在局限性。&lt;/p&gt;
&lt;p&gt;MFLOPS：每秒执行浮点运算多少百万次，着重在于&lt;strong&gt;浮点操作&lt;/strong&gt;本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;计算&#34;&gt;计算
&lt;/h5&gt;&lt;p&gt;CPU 执行时间=CPI×程序总指令条数×时钟周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003103925476.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003103925476&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二章-数据的机器级表示&#34;&gt;第二章 数据的机器级表示
&lt;/h2&gt;&lt;h3 id=&#34;信息二进制编码&#34;&gt;信息二进制编码
&lt;/h3&gt;&lt;p&gt;计算机内部数据：二进制表示&lt;/p&gt;
&lt;p&gt;机器级数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数值数据，无符号/带符号整数，浮点数，十进制数&lt;/li&gt;
&lt;li&gt;非数值数据，逻辑数，汉字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二进制编码原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;制造两个稳态的物理器件容易&lt;/li&gt;
&lt;li&gt;二进制编码、计数、运算规则简单。&lt;/li&gt;
&lt;li&gt;与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;机器数：0/1 编码的 0/1 内部 0/1 序列。&lt;/p&gt;
&lt;p&gt;真值：机器数真正的值&lt;/p&gt;
&lt;h4 id=&#34;数值数据表示方法&#34;&gt;数值数据表示方法
&lt;/h4&gt;&lt;p&gt;三要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位计数制：十进制，二进制等转换。&lt;/li&gt;
&lt;li&gt;定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示）&lt;/li&gt;
&lt;li&gt;编码：原码补码反码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若不知道三要素，那么便无法得知机器数的具体真值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进制转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制 -&amp;gt; 其他：划分位数，对应&lt;/li&gt;
&lt;li&gt;十六、八 -&amp;gt; 二：位数对应，补全&lt;/li&gt;
&lt;li&gt;十进制 -&amp;gt; 任意位数：求商取余&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定点数的表示&#34;&gt;定点数的表示
&lt;/h4&gt;&lt;p&gt;常规计数，小数点位置固定。整数、小数分开存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数：没有符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 +0、-0 两种表示形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正数与原码相同&lt;/li&gt;
&lt;li&gt;若符号位为1，则数值位全部取反&lt;/li&gt;
&lt;li&gt;依然有 +0、-0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将减法抓换为等价的加法（加上补数）&lt;/li&gt;
&lt;li&gt;= 原码除符号位外，取反后加一（即反码 + 1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移码： &lt;strong&gt;将每一个数值加上一个偏置常数（ bias）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一般来说，当编码位数为 n **时，bias 取 2^n 标准移码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要用移码来表示阶码？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便于浮点数加减运算时的对阶操作（比较大小）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与补码的关系：&lt;strong&gt;最高位相反，其余位相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c语言的解析&#34;&gt;C语言的解析
&lt;/h4&gt;&lt;p&gt;无符号数变为有符号：不改变数据内容，改变解释方式&lt;/p&gt;
&lt;p&gt;长变短：高位截断，保留地位&lt;/p&gt;
&lt;p&gt;短变长：符号扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负数补1，正数补0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ieee编码&#34;&gt;IEEE编码
&lt;/h3&gt;&lt;p&gt;规定了二进制浮点数算数标准，类似科学计数法简化计数&lt;/p&gt;
&lt;h4 id=&#34;二进制浮点数&#34;&gt;二进制浮点数
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号：决定数值的正负性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数：影响数值的精度。尾数的位数越多，精度越高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码：反映小数点的实际位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数：K进制通常默认基数为K&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格化：石确保尾数的最高位非0数位刚好在小数点之前&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;float型：32位单精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 8 + 23&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;double型：64位双精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 11 + 52&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;float单精度&#34;&gt;float单精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认存储规格化尾数，小数点前的1省略（隐含）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数规定为 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码用移码表示，规定偏置值为 127&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何将十进制真值转换为偏置值为M的移码？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将十进制真值+偏置值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按“无符号整数”规则转换为指定位数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;double双精度&#34;&gt;double双精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;偏置值为1023&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;表示范围&#34;&gt;表示范围
&lt;/h4&gt;&lt;h4 id=&#34;特殊状态&#34;&gt;特殊状态
&lt;/h4&gt;&lt;p&gt;阶码全 0，或阶码全 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码真值的取值范围为 -126 ~ 127（单精度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003161255970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003161255970&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据数轴，存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正上溢、正下溢、负上溢，负下移&lt;/li&gt;
&lt;li&gt;上溢置为无穷，下溢置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003160611584.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003160611584&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据表示&#34;&gt;数据表示
&lt;/h3&gt;&lt;h4 id=&#34;十进制数表示&#34;&gt;十进制数表示
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ASCII 码：就是把数字当作字符存储，&lt;strong&gt;0-9用30H-39H表示&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前分隔：&lt;strong&gt;正号用 2B  负号用 2D&lt;/strong&gt;  放在最前面&lt;/li&gt;
&lt;li&gt;后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。
&lt;ul&gt;
&lt;li&gt;正数不变；负数高 4 位变为 0111。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD 码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;西文字符表示&#34;&gt;西文字符表示：
&lt;/h4&gt;&lt;p&gt;复习要点中未提到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制数字：0/1/2…/9             10 个&lt;/li&gt;
&lt;li&gt;英文字母：A/B/…/Z/a/b/…/z    52 个&lt;/li&gt;
&lt;li&gt;专用符号：+/-/%/*/&amp;amp;/……        33 个&lt;/li&gt;
&lt;li&gt;控制字符（不可打印或显示）  33 个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;汉字表示&#34;&gt;汉字表示
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;输入码：用于输入汉字。&lt;/li&gt;
&lt;li&gt;内码：用于在系统中进行存储、查找、传送等处理&lt;/li&gt;
&lt;li&gt;字模点阵或轮廓描述：用于显示/打印&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据的宽度&#34;&gt;数据的宽度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bit&lt;/li&gt;
&lt;li&gt;字节：
&lt;ul&gt;
&lt;li&gt;现代计算机中，存储器按字节编址&lt;/li&gt;
&lt;li&gt;字节是最小可寻址单位 （addressable unit ）&lt;/li&gt;
&lt;li&gt;LSB 表示最低有效字节，MSB 表示最高有效字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字
&lt;ul&gt;
&lt;li&gt;表示被处理信息的单位，用来度量数据类型的宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字长
&lt;ul&gt;
&lt;li&gt;指某特定机器定点运算时数据通路的宽度。&lt;/li&gt;
&lt;li&gt;数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。&lt;/li&gt;
&lt;li&gt;等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据的存储和排列顺序&#34;&gt;数据的存储和排列顺序
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大小端
&lt;ul&gt;
&lt;li&gt;小端（ &lt;strong&gt;Little Endian&lt;/strong&gt;）:低字节放低地址&lt;/li&gt;
&lt;li&gt;大端（ &lt;strong&gt;Big Endian&lt;/strong&gt;）:高字节放低地址&lt;/li&gt;
&lt;li&gt;指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对齐：要求数据存放的地址必须是相应的边界地址
&lt;ul&gt;
&lt;li&gt;每次访存只能读写一个字&lt;/li&gt;
&lt;li&gt;浪费一定空间，换取存取时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003164347928.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003164347928&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据的检错与纠错&#34;&gt;数据的检错与纠错
&lt;/h3&gt;&lt;p&gt;大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码&lt;/li&gt;
&lt;li&gt;海明校验码&lt;/li&gt;
&lt;li&gt;循环冗余校验码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三章-运算方法和运算部件&#34;&gt;第三章 运算方法和运算部件
&lt;/h2&gt;&lt;h3 id=&#34;加法器&#34;&gt;加法器
&lt;/h3&gt;&lt;h4 id=&#34;串行进位&#34;&gt;串行进位
&lt;/h4&gt;&lt;p&gt;传递速度慢&lt;/p&gt;
&lt;h4 id=&#34;并行进位&#34;&gt;并行进位
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用先行进位优化，各进位之间无等待，相互独立并同时产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但全先行电路复杂，成本高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部先行进位加法器： &lt;strong&gt;组内并行、组间串行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用多个位数较少的 n 位全先行进位加法器进行串联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级先行进位加法器： &lt;strong&gt;组内并行、组间并行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alu的构成&#34;&gt;ALU的构成
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ALU 如何控制实现加、减、与、或等等各种功能；
&lt;ol&gt;
&lt;li&gt;无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。&lt;/li&gt;
&lt;li&gt;在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;零标志 ZF、&lt;strong&gt;&lt;strong&gt;溢出标志 OF&lt;/strong&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;进/借位标志 CF&lt;/strong&gt;&lt;/strong&gt;、符号标志 SF&lt;/strong&gt; 称为&lt;strong&gt;条件标志。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中&lt;/li&gt;
&lt;li&gt;存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003180007637.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003180007637&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;溢出条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无符号加、减溢出条件：CF=1&lt;/li&gt;
&lt;li&gt;带符号加、减溢出条件：OF=1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数运算&#34;&gt;定点数运算
&lt;/h3&gt;&lt;h4 id=&#34;移位&#34;&gt;移位
&lt;/h4&gt;&lt;p&gt;逻辑移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;针对无符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左移 n 位，即乘上位权的 n 次方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高位溢出丢弃，低位补 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算数移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左移与逻辑移位类似，但移到符号位结果更改&lt;/li&gt;
&lt;li&gt;右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;加减&#34;&gt;加减
&lt;/h4&gt;&lt;p&gt;原码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减法用减法器实现，1 变 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位可以一起参与运算&lt;/li&gt;
&lt;li&gt;[A+B]补=[A]补+ [B]补&lt;/li&gt;
&lt;li&gt;[A-B]补=[A]补+[-B]补&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;乘法&#34;&gt;乘法
&lt;/h4&gt;&lt;h5 id=&#34;无符号整数&#34;&gt;无符号整数：
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;模拟手算乘法即可，计算机还需拆分部分积&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003165328818.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003165328818&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;带符号整数&#34;&gt;带符号整数
&lt;/h5&gt;&lt;p&gt;给无符号整数乘法电路添加一辅助位，让符号位参与运算。&lt;/p&gt;
&lt;p&gt;计算机底层判断溢出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 2n 位的高 n + 1 位不均相同，则溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;实现方式&#34;&gt;实现方式
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ALU + 移位器 + 寄存器 + 控制逻辑&lt;/li&gt;
&lt;li&gt;阵列乘法器&lt;/li&gt;
&lt;li&gt;逻辑运算模拟&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浮点数运算&#34;&gt;浮点数运算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浮点数加减运算的对阶原则和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原则：小阶向大阶看齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算一个移码数减 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数规格化中的右规和左规方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码减 1 后要判断阶码是否下溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码加 1 后要判断阶码是否上溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阶码溢出异常处理：
&lt;ul&gt;
&lt;li&gt;阶码上溢，则结果溢出；&lt;/li&gt;
&lt;li&gt;阶码下溢，则结果为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乘法运算结果不需左规！最多右规 1 次！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;除法最多左规 1 次！不需右规！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数的舍入处理常用方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就近舍入：舍入为最近可表示的数
&lt;ul&gt;
&lt;li&gt;若为非中间值：LSB 后 1 位 0 舍 1 入&lt;/li&gt;
&lt;li&gt;若为中间值：强迫结果为偶数， LSB=
&lt;ul&gt;
&lt;li&gt;1.1101110 → 1.1110       (1.1101110 → 1.1110,  110&amp;gt;100, 1.1101+0.0001 = 1.1110)&lt;/li&gt;
&lt;li&gt;1.1101011 → 1.1101       (1.1101011 → 1.1101,  011&amp;lt;100, 1.1101+    0     = 1.1101)&lt;/li&gt;
&lt;li&gt;1.1101101 → 1.1110&lt;/li&gt;
&lt;li&gt;1.1111100 → 10.0000     (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1101 ；  1.1101101 →1.1110&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1110 ；  1.1101101 →1.1101&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断结果溢出（上溢和下溢）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第四章&#34;&gt;第四章
&lt;/h2&gt;&lt;h3 id=&#34;指令格式&#34;&gt;指令格式
&lt;/h3&gt;&lt;p&gt;指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。&lt;/p&gt;
&lt;h4 id=&#34;根据地址码数不同&#34;&gt;根据地址码数不同
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;零地址指令：
&lt;ul&gt;
&lt;li&gt;不需要操作数，如停机、关中断等&lt;/li&gt;
&lt;li&gt;堆栈计算机，操作数隐藏在栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一地址指令：
&lt;ul&gt;
&lt;li&gt;只需单操作数，如加一、取反&lt;/li&gt;
&lt;li&gt;需两个操作数，但其中一个存储在某个寄存器内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二地址指令：
&lt;ul&gt;
&lt;li&gt;用于需要两个操作数的算术运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三地址指令：
&lt;ul&gt;
&lt;li&gt;多一个地址存储结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;四地址指令：
&lt;ul&gt;
&lt;li&gt;再多一个地址存储下一个指令地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令位数不变时，地址码数越多，寻址能力越差&lt;/p&gt;
&lt;h4 id=&#34;按指令长度分类&#34;&gt;按指令长度分类
&lt;/h4&gt;&lt;p&gt;指令字长：一条指令的总长度(可能会变)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;影响取指令所需时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;机器字长：CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)&lt;/p&gt;
&lt;p&gt;存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)&lt;/p&gt;
&lt;h4 id=&#34;按操作码长度分类&#34;&gt;按操作码长度分类
&lt;/h4&gt;&lt;p&gt;定长：译码电路设计简单，但复杂性低&lt;/p&gt;
&lt;h4 id=&#34;按操作类型分类&#34;&gt;按操作类型分类
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据传送&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LOAD：把存储器中的数据放到寄存器中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STORE： 把寄存器中的数据放到存储器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数逻辑操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑（与或非、位操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑、循环移位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转移操作（改变程序执行流，PC指针改变）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无条件转移 JMP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件转移JZ：结果为0；JO：结果溢出；JC：结果有进位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用和返回 CALL和RETURN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;陷阱(Trap)与陷阱指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入输出操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;设计&#34;&gt;设计
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指令格式的选择应遵循的几条基本原则
&lt;ul&gt;
&lt;li&gt;应尽量短&lt;/li&gt;
&lt;li&gt;要有足够的操作码位数&lt;/li&gt;
&lt;li&gt;指令编码必须有唯一的解释，否则是不合法的指令&lt;/li&gt;
&lt;li&gt;指令字长应是&lt;strong&gt;字节的整数倍&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;合理地选择地址字段的个数&lt;/li&gt;
&lt;li&gt;指令尽量规整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一条指令必须&lt;strong&gt;明显或隐含&lt;/strong&gt;包含以下信息：
&lt;ul&gt;
&lt;li&gt;操作码：指定操作类型&lt;/li&gt;
&lt;li&gt;源操作数或其地址：一个或多个源操作数所在的地址&lt;/li&gt;
&lt;li&gt;结果的地址：产生的结果存放何处（目的操作数）&lt;/li&gt;
&lt;li&gt;下一条指令地址：下条指令存放何处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令的寻址方式&amp;mdash;-简单
&lt;ul&gt;
&lt;li&gt;顺序执行：PC增值&lt;/li&gt;
&lt;li&gt;跳转 （ jump / branch / call / return ）：同操作数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作数的寻址方式&amp;mdash;-复杂
&lt;ul&gt;
&lt;li&gt;操作数来源：寄存器 / 主（虚）存 /外设端口 /  栈顶&lt;/li&gt;
&lt;li&gt;操作数结构：位 / 字节 / 半字 / 字 / 双字 / 一维表 / 二维表 /…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常寻址方式特指“操作数的寻址”&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;扩展操作码&#34;&gt;扩展操作码
&lt;/h4&gt;&lt;p&gt;格式：定长指令字结构 + 可边长操作码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即不同地址数的指令使用不同的操作码，便于判断&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通常情况下，对使用频率较高的指令，分配较短的操作码；对使用
频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和
分析的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011090538497.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011090538497&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设地址长度为n，上一层留出m种状态，下一层可扩展出mx2^n种状态&lt;/p&gt;
&lt;p&gt;注意短的操作码不能是长操作码的前缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;寻址方式&#34;&gt;寻址方式
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;PC：程序计数器，取址后会自动加一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;指令寻址&#34;&gt;指令寻址
&lt;/h4&gt;&lt;p&gt;确定下一条指令的存放地址，由 PC 指明&lt;/p&gt;
&lt;p&gt;顺序寻址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC + ”1“
&lt;ul&gt;
&lt;li&gt;1 理解为一个指令字长，根据指令字长变化字节编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳跃寻址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行转移指令导致 PC 值改变（直接修改）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据寻址&#34;&gt;数据寻址
&lt;/h4&gt;&lt;p&gt;确定本条指令的地址码指明的&lt;strong&gt;真实地址&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序存储位置是相对的，需要用偏移量解读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在地址码中划分出&lt;strong&gt;寻址特征&lt;/strong&gt;，规定该地址需要用何种方式寻址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接寻址：存储 = 真实，即 EA = A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间接寻址：存储的是真实值的地址，即 EA = （A）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器寻址：指令字中直接给出操作数所在寄存器编号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器间接寻址：寄存器存储的是操作数所在储存单元的地址，即 EA = （R）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐含寻址：非显示给出的操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;立即寻址：地址就是操作数本身，又称立即数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基址寻址：以程序的起始存放地址作为起点，EA = （BR）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;BR 为基址寄存器，由操作系统决定，不可更改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;变址寻址：程序员自己决定从哪里作为起点，EA = （IX）+ A&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;IX 为变址寄存器，可由用户决定。类似一个指针，设置为数组首地址等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;p&gt;相对寻址：程序计数器PC所指地址作为起点，EA = （PC）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;堆栈可以用寄存器实现（硬堆栈）或主存实现，硬堆栈不妨存，速度快&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;优缺点&#34;&gt;优缺点
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011095613851.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011095613851&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;条件测试方式&#34;&gt;条件测试方式(?)
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011100211358.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011100211358&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于带符号数和无符号数运算，标志生成方式有没有不同？&lt;/p&gt;
&lt;p&gt;答：没有，因为加法电路不知道是无符号数还是带符号整数！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;指令系统设计风格&#34;&gt;指令系统设计风格
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;累加器型： （earliest machines）
&lt;ul&gt;
&lt;li&gt;特点：其中一个操作数（源操作数 1）和目的操作数总在累加器中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆栈型： （e.g. HP calculator, Java virtual machines)
&lt;ul&gt;
&lt;li&gt;特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通用寄存器型： （e.g. IA-32, Motorola 68xxx)
&lt;ul&gt;
&lt;li&gt;特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;装入/存储型： （e.g. SPARC, MIPS, PowerPC)
&lt;ul&gt;
&lt;li&gt;特点：运算指令的操作数只能是寄存器数据，只有 load/store 能访问存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令集cisc-和-risc&#34;&gt;指令集：CISC 和 RISC
&lt;/h3&gt;&lt;p&gt;CISC（Complex Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条指令完成一个复杂的基本功能。&lt;/li&gt;
&lt;li&gt;x86 架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC（Reduced Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路简单，功耗小，寄存器多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有 LOAD、STORE 指令可以访存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARM 架构，主要用于手机、平板&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%。而且在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013194838713.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013194838713&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;mips-的指令格式&#34;&gt;MIPS 的指令格式
&lt;/h3&gt;&lt;p&gt;所有指令都是32位宽（字长），按字地址对齐存储，字地址为4的倍数&lt;/p&gt;
&lt;p&gt;分为 R、I、J 型&lt;/p&gt;
&lt;h4 id=&#34;r-型&#34;&gt;R 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195437859.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195437859&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与运算的操作数和结果都在寄存器，R 型指令的寻址方式&lt;strong&gt;只有寄存器寻址&lt;/strong&gt;一种；&lt;/li&gt;
&lt;li&gt;R 型指令&lt;strong&gt;的 op 全为 0&lt;/strong&gt;，具体功能由 func 部分确定；&lt;/li&gt;
&lt;li&gt;rs：第一个源操作数（source register）&lt;/li&gt;
&lt;li&gt;rt：第 2 个源操作数（target register）&lt;/li&gt;
&lt;li&gt;rd：目的寄存器（destination register）&lt;/li&gt;
&lt;li&gt;shamt：对非移位指令为 00000。移位指令为移位次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;i-型&#34;&gt;I 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195709806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195709806&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令中包含了一个&lt;strong&gt;立即数&lt;/strong&gt;，所以称为 I 型指令。&lt;/li&gt;
&lt;li&gt;op：确定指令的功能；&lt;/li&gt;
&lt;li&gt;rs：可以是一个源操作数，&lt;strong&gt;寄存器寻址&lt;/strong&gt;；或者在存取指令中用作基址寄存器，&lt;strong&gt;偏移寻址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;rt：目的寄存器&lt;/li&gt;
&lt;li&gt;Immediate：长度为 16 位的立即数，指令执行时需扩展为 32 位。根据指令的不同，可以有以下三种用法：
&lt;ul&gt;
&lt;li&gt;运算类指令（ori）：以立即寻址方式提供的一个源操作数。&lt;/li&gt;
&lt;li&gt;存取指令（lw/sw）：作为偏移量，与寄存器 rs 组成偏移寻址方式，提供一个存储器操作数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件转移&lt;/strong&gt;指令（bne）：作为偏移量，与 PC 寄存器组成&lt;strong&gt;相对寻址&lt;/strong&gt;方式，提供一个转移目的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;j-型&#34;&gt;J 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195925675.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195925675&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;op：确定指令的功能&lt;/li&gt;
&lt;li&gt;address：转移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;整合&#34;&gt;整合
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三种指令     &lt;strong&gt;汇编格式   a=b op c   把=和op变成逗号&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;R型指令格式是op+rs+rt+rd+shamt+func   汇编格式是  xxx $rs, $rt, $rd&lt;/li&gt;
&lt;li&gt;I型指令格式是op+rs+rt+imm   汇编格式是  xxx $rt, $rs, imm&lt;/li&gt;
&lt;li&gt;J型指令格式是op+addr   汇编格式是  xxx addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200210127.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200210127&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200238754.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200238754&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200751544.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200751544&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mips-的通用寄存器&#34;&gt;MIPS 的通用寄存器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;0 号寄存器$zero 为固定值零，不能改变&lt;/li&gt;
&lt;li&gt;MIPS还提供了32个32位的单精度浮点寄存器$f0∽$f31,用于浮点数指令。它们可配对成16个64位的双精度浮点寄存器。&lt;/li&gt;
&lt;li&gt;在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上“$”,例如，$8或$t0。&lt;/li&gt;
&lt;li&gt;寄存器
&lt;ul&gt;
&lt;li&gt;长度：32 位&lt;/li&gt;
&lt;li&gt;个数：32 个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mips-的寻址方式&#34;&gt;MIPS 的寻址方式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;寄存器寻址
&lt;ul&gt;
&lt;li&gt;可以出现在 R 型和 I 型格式中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202438436.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202438436&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202455236.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202455236&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏移寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202517572.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202517572&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC 相对寻址&lt;/li&gt;
&lt;li&gt;PC&amp;lt;&amp;ndash; PC+4+imm*4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202535509.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202535509&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪直接寻址
&lt;ul&gt;
&lt;li&gt;为什么称伪直接？&lt;/li&gt;
&lt;li&gt;最终地址：PC 高四位+addr+两个 0，+表示拼接&lt;/li&gt;
&lt;li&gt;位数：4+26+2=32&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202548351.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202548351&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;机器语言的解码反汇编&#34;&gt;机器语言的解码（反汇编）？
&lt;/h3&gt;&lt;h3 id=&#34;高级语言汇编语言机器语言之间的转换-&#34;&gt;高级语言、汇编语言、机器语言之间的转换 ？
&lt;/h3&gt;&lt;h3 id=&#34;risc-v-指令系统&#34;&gt;RISC-V 指令系统
&lt;/h3&gt;&lt;p&gt;具有模块化结构，稳定性和可扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等各方面具有显著优势。&lt;/p&gt;
&lt;p&gt;模块化结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心：RV32I + 标准扩展集：RV32M、RV32F、RV32D、RV32A = RV32G&lt;/li&gt;
&lt;li&gt;32位架构RV32G = RV32IMAFD，其压缩指令集RV32C（指令长度16位）&lt;/li&gt;
&lt;li&gt;64位架构RV64G = RV64IMAFD，其压缩指令集RV64C（指令长度16位）&lt;/li&gt;
&lt;li&gt;向量计算RV32V和RV64V；嵌入式RV32E（RV32I的子集，16个通用寄存器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;指令格式-1&#34;&gt;指令格式
&lt;/h4&gt;&lt;h5 id=&#34;32位&#34;&gt;32位
&lt;/h5&gt;&lt;p&gt;R-型为寄存器操作数指令&lt;/p&gt;
&lt;p&gt;I-型为短立即数或装入（Load）指令&lt;/p&gt;
&lt;p&gt;S-型为存储（Store）指令&lt;/p&gt;
&lt;p&gt;B-型为条件跳转指令&lt;/p&gt;
&lt;p&gt;U-型为长立即数操作指令&lt;/p&gt;
&lt;p&gt;J-型为无条件跳转指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204153653.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204153653&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;16位压缩&#34;&gt;16位压缩
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204333864.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204333864&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第五章-中央处理器&#34;&gt;第五章 中央处理器
&lt;/h2&gt;&lt;h3 id=&#34;cpu-的功能和基本结构&#34;&gt;CPU 的功能和基本结构
&lt;/h3&gt;&lt;h4 id=&#34;cpu-基本功能&#34;&gt;CPU 基本功能：
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。&lt;/li&gt;
&lt;li&gt;操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件从而控制这些部件按指令的要求进行动作。&lt;/li&gt;
&lt;li&gt;时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。&lt;/li&gt;
&lt;li&gt;数据加工。对数据进行算术和逻辑运算。&lt;/li&gt;
&lt;li&gt;中断处理。对计算机运行过程中出现的&lt;strong&gt;异常情况&lt;/strong&gt;和特殊请求进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;基本结构&#34;&gt;基本结构
&lt;/h4&gt;&lt;p&gt;数据通路 + 控制器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106220709140.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106220709140&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制器
&lt;ul&gt;
&lt;li&gt;对指令进行译码，生成指令对应的控制信号，控制数据通路的动作。它向执行部件发出控制信号，是指令的控制部件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据通路&#34;&gt;数据通路
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;由操作元件和存储元件通过总线方式或分散方式连接而成的进行数据传送、处理和存储的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令执行过程中，数据所经过的路径，以及路径上的部件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包括：ALU、通用寄存器、状态寄存器、MMU、cache、中断处理逻辑等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通路中专门进行数据运算的部件称为执行部件或功能部件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能：进行数据传送、处理和存储&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成元件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合逻辑元件（操作元件）：输出只取决于当前输入&lt;/li&gt;
&lt;li&gt;时序逻辑元件（也称状态元件，或存储元件）：在时钟控制下输入被写到电路中，直到下个时钟到达。
&lt;ul&gt;
&lt;li&gt;定时方式：规定信号何时写入状态元件（上升沿、下降沿、电平触发）&lt;/li&gt;
&lt;li&gt;存储元件：寄存器 &amp;ndash;&amp;gt; 寄存器组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总线、分散&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;时序控制（过去式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106221950243.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106221950243&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;现代时钟周期
&lt;ul&gt;
&lt;li&gt;…… + 状态元件 + 操作元件( 组合电路) + 状态元件 + ……
&lt;ul&gt;
&lt;li&gt;只有状态元件能存储信息，所有操作元件都从状态元件接收输入，并将输出写入状态元件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟周期= &lt;code&gt;Latch Prop + Longest Delay Path + Setup + Clock Skew(时钟偏移)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;约束条件：操作元件输出有效信号最快出现必须在下一级状态元件的输入保持时间之后出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单周期-mips-处理器的设计&#34;&gt;单周期 MIPS 处理器的设计
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;复习：三种指令类型 R、I、J&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223015184.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223015184&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设计处理器步骤
&lt;ol&gt;
&lt;li&gt;分析每条指令功能，并用 RTL（Register Transfer Language）来表示&lt;/li&gt;
&lt;li&gt;根据指令的功能给出所需的元件，并考虑如何将他们互连&lt;/li&gt;
&lt;li&gt;确定每个元件所需控制信号的取值&lt;/li&gt;
&lt;li&gt;汇总所有指令所涉及到的控制信号，生成一张反映指令与控制信    号之间关系的表&lt;/li&gt;
&lt;li&gt;根据表得到每个控制信号的逻辑表达式，据此设计控制器电路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设计数据通路&#34;&gt;设计数据通路
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;R-type：取指 &amp;ndash;&amp;gt; 取寄存器 &amp;ndash;&amp;gt; 运算 &amp;ndash;&amp;gt; 输出、计算下地址
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 从PC所指的内存单元中取指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rd] ← R[rs] + R[rt]&lt;/code&gt; 从rs、r所指的寄存器中取数后相加。若结果不溢出，则将结果送rd所指的寄存器中；若结果溢出，则不送结果，并转到“溢出处理程序”执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; PC加4，使PC指向下一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223528090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223528090&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I-type
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← R[rs] or ZeroExt(imm16)&lt;/code&gt; 立即数零扩展，并与rs内容做“或”运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223721148.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223721148&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lw 装入指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt; 计算存储单元地址 (立即数符号扩展！)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← M [Addr]&lt;/code&gt;装入数据到寄存器rt中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224257606.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224257606&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sw 指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt;   计算存储单元地址（符号扩展！）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M[Addr] ← R[rt]&lt;/code&gt; 寄存器rt中的内容存到内存单元中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224756068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224756068&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cond ← R[rs] - R[rt]&lt;/code&gt; 做减法比较rs和rt中的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (Cond eq 0)&lt;/code&gt; 计算下地址（根据比较结果，修改PC）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4 + ( SignExt(imm16) x 4 )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225017615.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225017615&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt;	        取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC&amp;lt;31:2&amp;gt; ← PC&amp;lt;31:28&amp;gt;&lt;/code&gt; 串接  &lt;code&gt;target&amp;lt;25:0&amp;gt;&lt;/code&gt;     计算目标地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;指令范围有多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不是相对寻址，是绝对寻址。转移范围&lt;strong&gt;只能在 j 指令所在的228=256MB页面内&lt;/strong&gt;，页面号与j指令相同 &lt;code&gt;PC&amp;lt;31:28&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225306971.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225306971&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225341319.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225341319&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106230643068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106230643068&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;设计控制器&#34;&gt;设计控制器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;方法：
&lt;ol&gt;
&lt;li&gt;根据每条指令的功能，分析控制信号的取值，并列表表示。&lt;/li&gt;
&lt;li&gt;根据列出的指令和控制信号的关系，写出每个控制信号的逻辑表达式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PPT 上看指令译码后条件码的产生、执行过程，内容较多&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107083030372.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107083030372&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设计逻辑
&lt;ul&gt;
&lt;li&gt;MIPS指令格式中指示操作性质有op 和 func两个字段，分别用来产生两类不同的控制信号&lt;/li&gt;
&lt;li&gt;func只用于R型指令，形成对应的ALU的功能控制信号&lt;/li&gt;
&lt;li&gt;op用来产生各种控制信号，包括了非R型指令的ALU功能控制信号&lt;/li&gt;
&lt;li&gt;控制器 = 主控制单元 + ALU局部控制单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107083737456.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107083737456&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单周期处理器的性能
&lt;ul&gt;
&lt;li&gt;CPI = 1；其他条件一定的情况下，CPI越小，则性能越好！&lt;/li&gt;
&lt;li&gt;除CPI外，还取决于时钟周期的宽度，单周期处理器的时钟宽度为最复杂指令的执行时间&lt;/li&gt;
&lt;li&gt;但是，对每类指令采用可变长时钟周期实现非常困难，而且所带来的额外开销会很大，不合算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单周期处理器的问题
&lt;ul&gt;
&lt;li&gt;时钟周期以最复杂指令所需时间为准，太长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决思路
&lt;ul&gt;
&lt;li&gt;把指令的执行分成多个阶段，每个阶段用一个时钟周期完成&lt;/li&gt;
&lt;li&gt;多周期处理器
&lt;ul&gt;
&lt;li&gt;时钟周期短&lt;/li&gt;
&lt;li&gt;不同指令所用周期数可以不同&lt;/li&gt;
&lt;li&gt;允许功能部件在一条指令执行过程中被多次使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107084401880.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107084401880&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;微程序设计和异常处理&#34;&gt;微程序设计和异常处理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬连线控制器的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：速度快，适合于简单或规整的指令系统，例如 MIPS 指令集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：它是一个多输入/多输出的巨大逻辑网络。对于复杂指令系统来说，结构庞杂，不用大规模集成电路则实现困难；修改、维护不易；灵活性差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简化方法：微程序设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微程序控制器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仿照程序设计的方法，编制每条指令对应的微程序&lt;/li&gt;
&lt;li&gt;所有指令对应的微程序&lt;strong&gt;放在只读存储器&lt;/strong&gt;（控制存储器）中，执行某条指令就是取出对应微程序中的各条微指令，对微指令译码产生对应的微命令(即控制信号)&lt;/li&gt;
&lt;li&gt;特点：具有规整性、可维护性和灵活性，但速度慢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107084738021.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107084738021&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微指令格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;水平型：相容微命令尽量多地安排在一条微指令中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：微程序短，并行性高，适合于较高速度的场合&lt;/li&gt;
&lt;li&gt;缺点：微指令长，编码空间利用率较低，并且编制困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直型：一条微指令只控制一、二个微命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含：若干微命令、下条微指令地址（可选）、常数（可选）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251107085057666.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251107085057666&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;异常和中断的处理&#34;&gt;异常和中断的处理
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部异常：在CPU内部发生的意外事件或特殊事件
&lt;ul&gt;
&lt;li&gt;故障（fault）：执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时等&lt;/li&gt;
&lt;li&gt;自陷（Trap）：预先安排的事件，如单步跟踪、系统调用(执行访管指令)等&lt;/li&gt;
&lt;li&gt;终止（Abort）：硬故障事件，此时机器将“终止”，调出中断服务程序来重启操作系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部中断：在CPU外部发生的特殊事件，通过向CPU发“中断请求”信号，请求CPU处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关中断（“中断/异常允许”状态位清0）：使处理器处于“禁止中断”状态，以防止新异常(或中断)破坏断点、程序状态和现场（现场指通用寄存器的值）。&lt;/li&gt;
&lt;li&gt;保护断点和程序状态：将断点和程序状态保存到堆栈或特殊寄存器中。&lt;/li&gt;
&lt;li&gt;识别异常事件：有软件识别和硬件识别（向量中断方式）两种不同的方式。
&lt;ul&gt;
&lt;li&gt;软件识别（MIPS采用）：设置一个异常状态寄存器（MIPS中为Cause寄存器），用于记录异常原因。&lt;strong&gt;操作系统中&lt;/strong&gt;有一个统一的&lt;strong&gt;异常处理程序&lt;/strong&gt;，该程序按优先级顺序查询异常状态寄存器的各位，识别出异常事件&lt;/li&gt;
&lt;li&gt;硬件识别（向量中断）：用专门的硬件查询电路按优先级顺序识别异常，得到“中断类型号”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MIPS 异常处理数据通路设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加以下两个寄存器
&lt;ul&gt;
&lt;li&gt;EPC：32位，用于存放断点（异常处理后返回到的指令的地址）&lt;/li&gt;
&lt;li&gt;Cause：32位，记录异常原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增加两个寄存器的“写使能”控制信号
&lt;ul&gt;
&lt;li&gt;EPCWr：在保存断点时该信号有效，使断点PC写入EPC&lt;/li&gt;
&lt;li&gt;CauseWr：在处理器发现异常（如：非法指令、溢出）时，该信号有效，使异常类型被写到Cause寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要一个控制信号IntCause来选择正确的值写入到Cause中&lt;/li&gt;
&lt;li&gt;需要将异常查询程序的入口地址（MIPS为0x8000 0180）写入PC，可以在原来PCSource控制的多路复用器中再增加一路，其输入为0x8000 0180&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;必须考虑：&lt;strong&gt;保存&lt;/strong&gt;断点和异常原因，并将&lt;strong&gt;控制转到异常处理程序首地址&lt;/strong&gt;处
=======&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tags-笔记&#34;&gt;title: &amp;ldquo;计算机组成原理&amp;rdquo;
subtitle: &amp;ldquo;王道课程笔记&amp;rdquo;
summary: &amp;ldquo;计算机组成原理课程的笔记&amp;rdquo;
description: &amp;ldquo;计算机组成原理课程的笔记&amp;rdquo;
date: 2025-10-03
lastmod: 2025-11-06
image: &amp;quot;&amp;quot;
draft: false
toc:
enable: true
weight: false
categories: [&amp;ldquo;笔记&amp;rdquo;]
tags: [&amp;ldquo;笔记&amp;rdquo;]
&lt;/h2&gt;&lt;h2 id=&#34;第一章-计算机系统概述-1&#34;&gt;第一章 计算机系统概述
&lt;/h2&gt;&lt;h3 id=&#34;计算机系统的发展-1&#34;&gt;计算机系统的发展
&lt;/h3&gt;&lt;p&gt;计算机系统 = 硬件 + 软件&lt;/p&gt;
&lt;h4 id=&#34;软件-2&#34;&gt;软件
&lt;/h4&gt;&lt;p&gt;系统软件：用来管理整个计算机系统&lt;/p&gt;
&lt;p&gt;应用软件：按任务需要编制成的程序&lt;/p&gt;
&lt;h4 id=&#34;硬件-1&#34;&gt;硬件
&lt;/h4&gt;&lt;p&gt;第一台电子数字计算机：&lt;strong&gt;ENIAC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑元件（用于处理电信号的最小单元）：电子管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;十进制表示，手动编程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无冯 · 诺伊曼结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二代：晶体管&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带）&lt;/li&gt;
&lt;li&gt;特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。&lt;/li&gt;
&lt;li&gt;软件：使用高级语言，提供系统软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三代：中小规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件和主存储器均由&lt;strong&gt;集成电路&lt;/strong&gt;实现。&lt;/li&gt;
&lt;li&gt;特点：微程序控制，Cache，虚拟存储器，流水线。&lt;/li&gt;
&lt;li&gt;代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IBM 360（&lt;strong&gt;兼容机&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;相同/相似的指令集&amp;amp;操作系统。&lt;/p&gt;
&lt;p&gt;好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。&lt;/p&gt;
&lt;p&gt;保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;DEC PDP-8（&lt;strong&gt;采用总线结构&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第四代：大规模、超大规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半导体存储器，微处理器发展迅速。&lt;/li&gt;
&lt;li&gt;特点：共享存储器，分布式存储器以及大规模并行系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组成-1&#34;&gt;组成
&lt;/h3&gt;&lt;h4 id=&#34;冯诺依曼结构模型-1&#34;&gt;冯诺依曼结构模型
&lt;/h4&gt;&lt;p&gt;冯诺依曼提出&lt;strong&gt;存储程序&lt;/strong&gt;，取代手动接线。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冯诺依曼结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。&lt;/li&gt;
&lt;li&gt;各基本部件功能：
&lt;ol&gt;
&lt;li&gt;存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；&lt;/li&gt;
&lt;li&gt;控制器应能自动执行指令；&lt;/li&gt;
&lt;li&gt;运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；&lt;/li&gt;
&lt;li&gt;操作人员可以通过输入设备和输出设备与主机进行通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内部以&lt;strong&gt;二进制数&lt;/strong&gt;表述指令和数据
&lt;ol&gt;
&lt;li&gt;每条指令由&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;地址码&lt;/strong&gt;两部分组成。操作码指出操作的类型，地址码指出操作数的地址。&lt;/li&gt;
&lt;li&gt;由一串指令组成程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;工作方式
&lt;ol&gt;
&lt;li&gt;将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/20251003090538614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本部件及其功能-1&#34;&gt;基本部件及其功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;运算器（数据运算）：ALU、GPRs、标志寄存器等。&lt;/li&gt;
&lt;li&gt;存储器（数据存储）：存储阵列、地址译码器、读写控制电路&lt;/li&gt;
&lt;li&gt;总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线&lt;/li&gt;
&lt;li&gt;控制器（控制）：对指令译码生成控制信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU = 运算器 + 控制器&lt;/p&gt;
&lt;p&gt;主机 = CPU + 主存&lt;/p&gt;
&lt;h4 id=&#34;各硬件工作原理-1&#34;&gt;各硬件工作原理
&lt;/h4&gt;&lt;h5 id=&#34;主存储器-1&#34;&gt;主存储器
&lt;/h5&gt;&lt;p&gt;主存储器 = 存储体 + MAR + MDR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数&lt;/li&gt;
&lt;li&gt;Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令）&lt;/li&gt;
&lt;li&gt;存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1B = 1 byte ; 1 b = 1 bit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;MAR、MDR 逻辑上属于主存，但被集成到 CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;运算器-1&#34;&gt;运算器
&lt;/h5&gt;&lt;p&gt;实现算数运算、逻辑运算&lt;/p&gt;
&lt;p&gt;运算器 = ACC + ALU + MQ + X&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accumulator：累加器，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算&lt;/li&gt;
&lt;li&gt;X：通用的操作数寄存器，用于存放操作数&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;控制器-1&#34;&gt;控制器
&lt;/h5&gt;&lt;p&gt;控制器 = CU + IR +PC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Control Unit:控制单元，分析指令，给出控制信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instruction Register:指令寄存器，存放当前执行的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Program Counter:程序计数器，存放下一条指令地址，有自动加1功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配合-1&#34;&gt;配合
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003094316150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003094316150&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;指令和数据-1&#34;&gt;指令和数据
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序启动前，指令和数据都存储在存储器中，&lt;strong&gt;形式上没有区别&lt;/strong&gt;，都是 0/1 序列。&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。&lt;/li&gt;
&lt;li&gt;指令执行过程中，指令和数据从存储器取到 CPU，&lt;strong&gt;指令存在 IR 中，数据在 GPR 中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令需要给出的信息
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作码&lt;/strong&gt;：指令的操作，加减法等&lt;/li&gt;
&lt;li&gt;一个或多个&lt;strong&gt;源操作数&lt;/strong&gt;：立即数、寄存器编号、存储地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的操作数地址&lt;/strong&gt;：寄存器编号、存储地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;执行过程-1&#34;&gt;执行过程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序执行前
&lt;ul&gt;
&lt;li&gt;数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始执行程序
&lt;ul&gt;
&lt;li&gt;根据 PC &lt;strong&gt;取指&lt;/strong&gt;令送 IR：PC -&amp;gt; MAR -&amp;gt;存储器 -&amp;gt; MDR -&amp;gt; IR&lt;/li&gt;
&lt;li&gt;指令&lt;strong&gt;译码&lt;/strong&gt;：IR -&amp;gt; 控制器，控制器译码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取操作数&lt;/strong&gt;：GPRs 或存储器 -&amp;gt; ALU&lt;/li&gt;
&lt;li&gt;执行指令操作：ALU &lt;strong&gt;运算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回写&lt;/strong&gt;结果到 GPRs 或存储器&lt;/li&gt;
&lt;li&gt;修改 &lt;strong&gt;PC&lt;/strong&gt; 的值，使其指向&lt;strong&gt;下一条指令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;重复上述步骤直到程序完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;软件-3&#34;&gt;软件
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统软件——简化编程，&lt;strong&gt;使硬件资源被有效利用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：硬件资源管理，用户接口&lt;/li&gt;
&lt;li&gt;语言处理程序：翻译程序，Linker，Debug&amp;hellip;
&lt;ul&gt;
&lt;li&gt;翻译程序
&lt;ul&gt;
&lt;li&gt;汇编器（Assembler）：汇编语言源程序-&amp;gt;机器目标程序。或许叫汇编器更好理解？&lt;/li&gt;
&lt;li&gt;编译器（Complier）：高级语言程序-&amp;gt;汇编/机器目标程序。或许叫编译器更好理解？&lt;/li&gt;
&lt;li&gt;解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他实用程序：磁盘碎片整理、备份程序&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;机器语言：二进制代码&lt;/p&gt;
&lt;p&gt;汇编语言：助记符&lt;/p&gt;
&lt;p&gt;高级语言：C、C++、……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用软件——解决&lt;strong&gt;具体的应用&lt;/strong&gt;问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;层次结构-1&#34;&gt;层次结构
&lt;/h3&gt;&lt;h4 id=&#34;语言层次-1&#34;&gt;语言层次
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;微指令系统：直接控制硬件执行&lt;/li&gt;
&lt;li&gt;机器语言：传统机器M1，执行二进制机器指令&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作系统机器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编语言：虚拟机器M2，用汇编语言翻译成机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级语言：虚拟机器M3，需要编译成汇编、机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上两层视为硬件层&lt;/p&gt;
&lt;p&gt;计算机体系结构：讨论如何设计硬件与软件之间的接口&lt;/p&gt;
&lt;p&gt;计算机组成原理：讨论如何用硬件实现接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003100912264.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003100912264&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;isa-1&#34;&gt;ISA
&lt;/h4&gt;&lt;p&gt;指令集体系结构，其作为&lt;strong&gt;规约&lt;/strong&gt;，规定了&lt;strong&gt;如何使用硬件&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行的指令集合，包括&lt;strong&gt;指令格式&lt;/strong&gt;、&lt;strong&gt;操作种类&lt;/strong&gt;以及对应&lt;strong&gt;操作数&lt;/strong&gt;的规定。&lt;/li&gt;
&lt;li&gt;可以接受的&lt;strong&gt;操作数类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数存放的&lt;strong&gt;寄存器组结构&lt;/strong&gt;，例如寄存器名称、编号、长度和用途。&lt;/li&gt;
&lt;li&gt;操作数存放的存储空间的&lt;strong&gt;大小和编址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数在存储空间中按&lt;strong&gt;大/小端&lt;/strong&gt;方式存放。&lt;/li&gt;
&lt;li&gt;指令获得操作数的方式，即&lt;strong&gt;寻址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令执行过程的&lt;strong&gt;控制方式&lt;/strong&gt;，例如程序计数器，条件码定义等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ISA 是计算机系统中&lt;strong&gt;必不可少的抽象层&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;性能指标-1&#34;&gt;性能指标
&lt;/h3&gt;&lt;h4 id=&#34;存储器-1&#34;&gt;存储器
&lt;/h4&gt;&lt;p&gt;总容量 = 存储单元个数 * 存储字长(bit)&lt;/p&gt;
&lt;h4 id=&#34;cpu-1&#34;&gt;CPU
&lt;/h4&gt;&lt;h5 id=&#34;基本概念-1&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主频：CPU内数字脉冲信号振荡的频率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;= 1 / 时钟周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPS：每秒执行多少个命令 = 主频 / 平均CPI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FLOPS：每秒执行多少次浮点运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;K=Kilo=千=10^3&lt;/p&gt;
&lt;p&gt;M=Million=百万=10^6&lt;/p&gt;
&lt;p&gt;G=Giga=十亿=10^9&lt;/p&gt;
&lt;p&gt;T=Tera=万亿=10^12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：单位时间内处理请求的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相应时间：CPU时间 + 等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准程序：用于测量的程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于&lt;strong&gt;单条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;MIPS 为平均值，其并没有考虑以上三个属性，并且由于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同机器指令集不同&lt;/li&gt;
&lt;li&gt;程序由不同指令混合而成&lt;/li&gt;
&lt;li&gt;指令的频率会动态变换&lt;/li&gt;
&lt;li&gt;厂家给出峰值 MIPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，MIPS 表示性能存在局限性。&lt;/p&gt;
&lt;p&gt;MFLOPS：每秒执行浮点运算多少百万次，着重在于&lt;strong&gt;浮点操作&lt;/strong&gt;本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;计算-1&#34;&gt;计算
&lt;/h5&gt;&lt;p&gt;CPU 执行时间=CPI×程序总指令条数×时钟周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003103925476.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003103925476&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二章-数据的机器级表示-1&#34;&gt;第二章 数据的机器级表示
&lt;/h2&gt;&lt;h3 id=&#34;信息二进制编码-1&#34;&gt;信息二进制编码
&lt;/h3&gt;&lt;p&gt;计算机内部数据：二进制表示&lt;/p&gt;
&lt;p&gt;机器级数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数值数据，无符号/带符号整数，浮点数，十进制数&lt;/li&gt;
&lt;li&gt;非数值数据，逻辑数，汉字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二进制编码原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;制造两个稳态的物理器件容易&lt;/li&gt;
&lt;li&gt;二进制编码、计数、运算规则简单。&lt;/li&gt;
&lt;li&gt;与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;机器数：0/1 编码的 0/1 内部 0/1 序列。&lt;/p&gt;
&lt;p&gt;真值：机器数真正的值&lt;/p&gt;
&lt;h4 id=&#34;数值数据表示方法-1&#34;&gt;数值数据表示方法
&lt;/h4&gt;&lt;p&gt;三要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位计数制：十进制，二进制等转换。&lt;/li&gt;
&lt;li&gt;定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示）&lt;/li&gt;
&lt;li&gt;编码：原码补码反码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若不知道三要素，那么便无法得知机器数的具体真值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进制转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制 -&amp;gt; 其他：划分位数，对应&lt;/li&gt;
&lt;li&gt;十六、八 -&amp;gt; 二：位数对应，补全&lt;/li&gt;
&lt;li&gt;十进制 -&amp;gt; 任意位数：求商取余&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定点数的表示-1&#34;&gt;定点数的表示
&lt;/h4&gt;&lt;p&gt;常规计数，小数点位置固定。整数、小数分开存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数：没有符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 +0、-0 两种表示形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正数与原码相同&lt;/li&gt;
&lt;li&gt;若符号位为1，则数值位全部取反&lt;/li&gt;
&lt;li&gt;依然有 +0、-0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将减法抓换为等价的加法（加上补数）&lt;/li&gt;
&lt;li&gt;= 原码除符号位外，取反后加一（即反码 + 1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移码： &lt;strong&gt;将每一个数值加上一个偏置常数（ bias）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一般来说，当编码位数为 n **时，bias 取 2^n 标准移码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要用移码来表示阶码？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便于浮点数加减运算时的对阶操作（比较大小）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与补码的关系：&lt;strong&gt;最高位相反，其余位相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c语言的解析-1&#34;&gt;C语言的解析
&lt;/h4&gt;&lt;p&gt;无符号数变为有符号：不改变数据内容，改变解释方式&lt;/p&gt;
&lt;p&gt;长变短：高位截断，保留地位&lt;/p&gt;
&lt;p&gt;短变长：符号扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负数补1，正数补0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ieee编码-1&#34;&gt;IEEE编码
&lt;/h3&gt;&lt;p&gt;规定了二进制浮点数算数标准，类似科学计数法简化计数&lt;/p&gt;
&lt;h4 id=&#34;二进制浮点数-1&#34;&gt;二进制浮点数
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号：决定数值的正负性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数：影响数值的精度。尾数的位数越多，精度越高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码：反映小数点的实际位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数：K进制通常默认基数为K&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格化：石确保尾数的最高位非0数位刚好在小数点之前&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;float型：32位单精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 8 + 23&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;double型：64位双精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 11 + 52&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;float单精度-1&#34;&gt;float单精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认存储规格化尾数，小数点前的1省略（隐含）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数规定为 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码用移码表示，规定偏置值为 127&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何将十进制真值转换为偏置值为M的移码？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将十进制真值+偏置值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按“无符号整数”规则转换为指定位数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;double双精度-1&#34;&gt;double双精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;偏置值为1023&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;表示范围-1&#34;&gt;表示范围
&lt;/h4&gt;&lt;h4 id=&#34;特殊状态-1&#34;&gt;特殊状态
&lt;/h4&gt;&lt;p&gt;阶码全 0，或阶码全 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码真值的取值范围为 -126 ~ 127（单精度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003161255970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003161255970&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据数轴，存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正上溢、正下溢、负上溢，负下移&lt;/li&gt;
&lt;li&gt;上溢置为无穷，下溢置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003160611584.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003160611584&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据表示-1&#34;&gt;数据表示
&lt;/h3&gt;&lt;h4 id=&#34;十进制数表示-1&#34;&gt;十进制数表示
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ASCII 码：就是把数字当作字符存储，&lt;strong&gt;0-9用30H-39H表示&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前分隔：&lt;strong&gt;正号用 2B  负号用 2D&lt;/strong&gt;  放在最前面&lt;/li&gt;
&lt;li&gt;后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。
&lt;ul&gt;
&lt;li&gt;正数不变；负数高 4 位变为 0111。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD 码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;西文字符表示-1&#34;&gt;西文字符表示：
&lt;/h4&gt;&lt;p&gt;复习要点中未提到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制数字：0/1/2…/9             10 个&lt;/li&gt;
&lt;li&gt;英文字母：A/B/…/Z/a/b/…/z    52 个&lt;/li&gt;
&lt;li&gt;专用符号：+/-/%/*/&amp;amp;/……        33 个&lt;/li&gt;
&lt;li&gt;控制字符（不可打印或显示）  33 个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;汉字表示-1&#34;&gt;汉字表示
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;输入码：用于输入汉字。&lt;/li&gt;
&lt;li&gt;内码：用于在系统中进行存储、查找、传送等处理&lt;/li&gt;
&lt;li&gt;字模点阵或轮廓描述：用于显示/打印&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据的宽度-1&#34;&gt;数据的宽度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bit&lt;/li&gt;
&lt;li&gt;字节：
&lt;ul&gt;
&lt;li&gt;现代计算机中，存储器按字节编址&lt;/li&gt;
&lt;li&gt;字节是最小可寻址单位 （addressable unit ）&lt;/li&gt;
&lt;li&gt;LSB 表示最低有效字节，MSB 表示最高有效字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字
&lt;ul&gt;
&lt;li&gt;表示被处理信息的单位，用来度量数据类型的宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字长
&lt;ul&gt;
&lt;li&gt;指某特定机器定点运算时数据通路的宽度。&lt;/li&gt;
&lt;li&gt;数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。&lt;/li&gt;
&lt;li&gt;等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据的存储和排列顺序-1&#34;&gt;数据的存储和排列顺序
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大小端
&lt;ul&gt;
&lt;li&gt;小端（ &lt;strong&gt;Little Endian&lt;/strong&gt;）:低字节放低地址&lt;/li&gt;
&lt;li&gt;大端（ &lt;strong&gt;Big Endian&lt;/strong&gt;）:高字节放低地址&lt;/li&gt;
&lt;li&gt;指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对齐：要求数据存放的地址必须是相应的边界地址
&lt;ul&gt;
&lt;li&gt;每次访存只能读写一个字&lt;/li&gt;
&lt;li&gt;浪费一定空间，换取存取时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003164347928.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003164347928&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据的检错与纠错-1&#34;&gt;数据的检错与纠错
&lt;/h3&gt;&lt;p&gt;大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码&lt;/li&gt;
&lt;li&gt;海明校验码&lt;/li&gt;
&lt;li&gt;循环冗余校验码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三章-运算方法和运算部件-1&#34;&gt;第三章 运算方法和运算部件
&lt;/h2&gt;&lt;h3 id=&#34;加法器-1&#34;&gt;加法器
&lt;/h3&gt;&lt;h4 id=&#34;串行进位-1&#34;&gt;串行进位
&lt;/h4&gt;&lt;p&gt;传递速度慢&lt;/p&gt;
&lt;h4 id=&#34;并行进位-1&#34;&gt;并行进位
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用先行进位优化，各进位之间无等待，相互独立并同时产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但全先行电路复杂，成本高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部先行进位加法器： &lt;strong&gt;组内并行、组间串行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用多个位数较少的 n 位全先行进位加法器进行串联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级先行进位加法器： &lt;strong&gt;组内并行、组间并行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alu的构成-1&#34;&gt;ALU的构成
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ALU 如何控制实现加、减、与、或等等各种功能；
&lt;ol&gt;
&lt;li&gt;无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。&lt;/li&gt;
&lt;li&gt;在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;零标志 ZF、&lt;strong&gt;&lt;strong&gt;溢出标志 OF&lt;/strong&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;进/借位标志 CF&lt;/strong&gt;&lt;/strong&gt;、符号标志 SF&lt;/strong&gt; 称为&lt;strong&gt;条件标志。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中&lt;/li&gt;
&lt;li&gt;存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003180007637.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003180007637&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;溢出条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无符号加、减溢出条件：CF=1&lt;/li&gt;
&lt;li&gt;带符号加、减溢出条件：OF=1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数运算-1&#34;&gt;定点数运算
&lt;/h3&gt;&lt;h4 id=&#34;移位-1&#34;&gt;移位
&lt;/h4&gt;&lt;p&gt;逻辑移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;针对无符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左移 n 位，即乘上位权的 n 次方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高位溢出丢弃，低位补 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算数移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左移与逻辑移位类似，但移到符号位结果更改&lt;/li&gt;
&lt;li&gt;右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;加减-1&#34;&gt;加减
&lt;/h4&gt;&lt;p&gt;原码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减法用减法器实现，1 变 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位可以一起参与运算&lt;/li&gt;
&lt;li&gt;[A+B]补=[A]补+ [B]补&lt;/li&gt;
&lt;li&gt;[A-B]补=[A]补+[-B]补&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;乘法-1&#34;&gt;乘法
&lt;/h4&gt;&lt;h5 id=&#34;无符号整数-1&#34;&gt;无符号整数：
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;模拟手算乘法即可，计算机还需拆分部分积&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003165328818.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003165328818&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;带符号整数-1&#34;&gt;带符号整数
&lt;/h5&gt;&lt;p&gt;给无符号整数乘法电路添加一辅助位，让符号位参与运算。&lt;/p&gt;
&lt;p&gt;计算机底层判断溢出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 2n 位的高 n + 1 位不均相同，则溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;实现方式-1&#34;&gt;实现方式
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ALU + 移位器 + 寄存器 + 控制逻辑&lt;/li&gt;
&lt;li&gt;阵列乘法器&lt;/li&gt;
&lt;li&gt;逻辑运算模拟&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浮点数运算-1&#34;&gt;浮点数运算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浮点数加减运算的对阶原则和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原则：小阶向大阶看齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算一个移码数减 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数规格化中的右规和左规方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码减 1 后要判断阶码是否下溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码加 1 后要判断阶码是否上溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阶码溢出异常处理：
&lt;ul&gt;
&lt;li&gt;阶码上溢，则结果溢出；&lt;/li&gt;
&lt;li&gt;阶码下溢，则结果为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乘法运算结果不需左规！最多右规 1 次！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;除法最多左规 1 次！不需右规！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数的舍入处理常用方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就近舍入：舍入为最近可表示的数
&lt;ul&gt;
&lt;li&gt;若为非中间值：LSB 后 1 位 0 舍 1 入&lt;/li&gt;
&lt;li&gt;若为中间值：强迫结果为偶数， LSB=
&lt;ul&gt;
&lt;li&gt;1.1101110 → 1.1110       (1.1101110 → 1.1110,  110&amp;gt;100, 1.1101+0.0001 = 1.1110)&lt;/li&gt;
&lt;li&gt;1.1101011 → 1.1101       (1.1101011 → 1.1101,  011&amp;lt;100, 1.1101+    0     = 1.1101)&lt;/li&gt;
&lt;li&gt;1.1101101 → 1.1110&lt;/li&gt;
&lt;li&gt;1.1111100 → 10.0000     (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1101 ；  1.1101101 →1.1110&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1110 ；  1.1101101 →1.1101&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断结果溢出（上溢和下溢）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第四章-1&#34;&gt;第四章
&lt;/h2&gt;&lt;h3 id=&#34;指令格式-2&#34;&gt;指令格式
&lt;/h3&gt;&lt;p&gt;指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。&lt;/p&gt;
&lt;h4 id=&#34;根据地址码数不同-1&#34;&gt;根据地址码数不同
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;零地址指令：
&lt;ul&gt;
&lt;li&gt;不需要操作数，如停机、关中断等&lt;/li&gt;
&lt;li&gt;堆栈计算机，操作数隐藏在栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一地址指令：
&lt;ul&gt;
&lt;li&gt;只需单操作数，如加一、取反&lt;/li&gt;
&lt;li&gt;需两个操作数，但其中一个存储在某个寄存器内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二地址指令：
&lt;ul&gt;
&lt;li&gt;用于需要两个操作数的算术运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三地址指令：
&lt;ul&gt;
&lt;li&gt;多一个地址存储结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;四地址指令：
&lt;ul&gt;
&lt;li&gt;再多一个地址存储下一个指令地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令位数不变时，地址码数越多，寻址能力越差&lt;/p&gt;
&lt;h4 id=&#34;按指令长度分类-1&#34;&gt;按指令长度分类
&lt;/h4&gt;&lt;p&gt;指令字长：一条指令的总长度(可能会变)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;影响取指令所需时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;机器字长：CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)&lt;/p&gt;
&lt;p&gt;存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)&lt;/p&gt;
&lt;h4 id=&#34;按操作码长度分类-1&#34;&gt;按操作码长度分类
&lt;/h4&gt;&lt;p&gt;定长：译码电路设计简单，但复杂性低&lt;/p&gt;
&lt;h4 id=&#34;按操作类型分类-1&#34;&gt;按操作类型分类
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据传送&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LOAD：把存储器中的数据放到寄存器中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STORE： 把寄存器中的数据放到存储器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数逻辑操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑（与或非、位操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑、循环移位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转移操作（改变程序执行流，PC指针改变）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无条件转移 JMP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件转移JZ：结果为0；JO：结果溢出；JC：结果有进位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用和返回 CALL和RETURN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;陷阱(Trap)与陷阱指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入输出操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;设计-1&#34;&gt;设计
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指令格式的选择应遵循的几条基本原则
&lt;ul&gt;
&lt;li&gt;应尽量短&lt;/li&gt;
&lt;li&gt;要有足够的操作码位数&lt;/li&gt;
&lt;li&gt;指令编码必须有唯一的解释，否则是不合法的指令&lt;/li&gt;
&lt;li&gt;指令字长应是&lt;strong&gt;字节的整数倍&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;合理地选择地址字段的个数&lt;/li&gt;
&lt;li&gt;指令尽量规整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一条指令必须&lt;strong&gt;明显或隐含&lt;/strong&gt;包含以下信息：
&lt;ul&gt;
&lt;li&gt;操作码：指定操作类型&lt;/li&gt;
&lt;li&gt;源操作数或其地址：一个或多个源操作数所在的地址&lt;/li&gt;
&lt;li&gt;结果的地址：产生的结果存放何处（目的操作数）&lt;/li&gt;
&lt;li&gt;下一条指令地址：下条指令存放何处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令的寻址方式&amp;mdash;-简单
&lt;ul&gt;
&lt;li&gt;顺序执行：PC增值&lt;/li&gt;
&lt;li&gt;跳转 （ jump / branch / call / return ）：同操作数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作数的寻址方式&amp;mdash;-复杂
&lt;ul&gt;
&lt;li&gt;操作数来源：寄存器 / 主（虚）存 /外设端口 /  栈顶&lt;/li&gt;
&lt;li&gt;操作数结构：位 / 字节 / 半字 / 字 / 双字 / 一维表 / 二维表 /…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常寻址方式特指“操作数的寻址”&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;扩展操作码-1&#34;&gt;扩展操作码
&lt;/h4&gt;&lt;p&gt;格式：定长指令字结构 + 可边长操作码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即不同地址数的指令使用不同的操作码，便于判断&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通常情况下，对使用频率较高的指令，分配较短的操作码；对使用
频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和
分析的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011090538497.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011090538497&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设地址长度为n，上一层留出m种状态，下一层可扩展出mx2^n种状态&lt;/p&gt;
&lt;p&gt;注意短的操作码不能是长操作码的前缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;寻址方式-1&#34;&gt;寻址方式
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;PC：程序计数器，取址后会自动加一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;指令寻址-1&#34;&gt;指令寻址
&lt;/h4&gt;&lt;p&gt;确定下一条指令的存放地址，由 PC 指明&lt;/p&gt;
&lt;p&gt;顺序寻址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC + ”1“
&lt;ul&gt;
&lt;li&gt;1 理解为一个指令字长，根据指令字长变化字节编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳跃寻址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行转移指令导致 PC 值改变（直接修改）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据寻址-1&#34;&gt;数据寻址
&lt;/h4&gt;&lt;p&gt;确定本条指令的地址码指明的&lt;strong&gt;真实地址&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序存储位置是相对的，需要用偏移量解读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在地址码中划分出&lt;strong&gt;寻址特征&lt;/strong&gt;，规定该地址需要用何种方式寻址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接寻址：存储 = 真实，即 EA = A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间接寻址：存储的是真实值的地址，即 EA = （A）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器寻址：指令字中直接给出操作数所在寄存器编号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器间接寻址：寄存器存储的是操作数所在储存单元的地址，即 EA = （R）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐含寻址：非显示给出的操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;立即寻址：地址就是操作数本身，又称立即数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基址寻址：以程序的起始存放地址作为起点，EA = （BR）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;BR 为基址寄存器，由操作系统决定，不可更改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;变址寻址：程序员自己决定从哪里作为起点，EA = （IX）+ A&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;IX 为变址寄存器，可由用户决定。类似一个指针，设置为数组首地址等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;p&gt;相对寻址：程序计数器PC所指地址作为起点，EA = （PC）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;堆栈可以用寄存器实现（硬堆栈）或主存实现，硬堆栈不妨存，速度快&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;优缺点-1&#34;&gt;优缺点
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011095613851.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011095613851&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;条件测试方式-1&#34;&gt;条件测试方式(?)
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011100211358.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011100211358&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于带符号数和无符号数运算，标志生成方式有没有不同？&lt;/p&gt;
&lt;p&gt;答：没有，因为加法电路不知道是无符号数还是带符号整数！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;指令系统设计风格-1&#34;&gt;指令系统设计风格
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;累加器型： （earliest machines）
&lt;ul&gt;
&lt;li&gt;特点：其中一个操作数（源操作数 1）和目的操作数总在累加器中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆栈型： （e.g. HP calculator, Java virtual machines)
&lt;ul&gt;
&lt;li&gt;特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通用寄存器型： （e.g. IA-32, Motorola 68xxx)
&lt;ul&gt;
&lt;li&gt;特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;装入/存储型： （e.g. SPARC, MIPS, PowerPC)
&lt;ul&gt;
&lt;li&gt;特点：运算指令的操作数只能是寄存器数据，只有 load/store 能访问存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令集cisc-和-risc-1&#34;&gt;指令集：CISC 和 RISC
&lt;/h3&gt;&lt;p&gt;CISC（Complex Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条指令完成一个复杂的基本功能。&lt;/li&gt;
&lt;li&gt;x86 架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC（Reduced Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路简单，功耗小，寄存器多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有 LOAD、STORE 指令可以访存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARM 架构，主要用于手机、平板&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%。而且在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013194838713.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013194838713&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;mips-的指令格式-1&#34;&gt;MIPS 的指令格式
&lt;/h3&gt;&lt;p&gt;所有指令都是32位宽（字长），按字地址对齐存储，字地址为4的倍数&lt;/p&gt;
&lt;p&gt;分为 R、I、J 型&lt;/p&gt;
&lt;h4 id=&#34;r-型-1&#34;&gt;R 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195437859.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195437859&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与运算的操作数和结果都在寄存器，R 型指令的寻址方式&lt;strong&gt;只有寄存器寻址&lt;/strong&gt;一种；&lt;/li&gt;
&lt;li&gt;R 型指令&lt;strong&gt;的 op 全为 0&lt;/strong&gt;，具体功能由 func 部分确定；&lt;/li&gt;
&lt;li&gt;rs：第一个源操作数（source register）&lt;/li&gt;
&lt;li&gt;rt：第 2 个源操作数（target register）&lt;/li&gt;
&lt;li&gt;rd：目的寄存器（destination register）&lt;/li&gt;
&lt;li&gt;shamt：对非移位指令为 00000。移位指令为移位次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;i-型-1&#34;&gt;I 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195709806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195709806&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令中包含了一个&lt;strong&gt;立即数&lt;/strong&gt;，所以称为 I 型指令。&lt;/li&gt;
&lt;li&gt;op：确定指令的功能；&lt;/li&gt;
&lt;li&gt;rs：可以是一个源操作数，&lt;strong&gt;寄存器寻址&lt;/strong&gt;；或者在存取指令中用作基址寄存器，&lt;strong&gt;偏移寻址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;rt：目的寄存器&lt;/li&gt;
&lt;li&gt;Immediate：长度为 16 位的立即数，指令执行时需扩展为 32 位。根据指令的不同，可以有以下三种用法：
&lt;ul&gt;
&lt;li&gt;运算类指令（ori）：以立即寻址方式提供的一个源操作数。&lt;/li&gt;
&lt;li&gt;存取指令（lw/sw）：作为偏移量，与寄存器 rs 组成偏移寻址方式，提供一个存储器操作数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件转移&lt;/strong&gt;指令（bne）：作为偏移量，与 PC 寄存器组成&lt;strong&gt;相对寻址&lt;/strong&gt;方式，提供一个转移目的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;j-型-1&#34;&gt;J 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195925675.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195925675&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;op：确定指令的功能&lt;/li&gt;
&lt;li&gt;address：转移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;整合-1&#34;&gt;整合
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三种指令     &lt;strong&gt;汇编格式   a=b op c   把=和op变成逗号&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;R型指令格式是op+rs+rt+rd+shamt+func   汇编格式是  xxx $rs, $rt, $rd&lt;/li&gt;
&lt;li&gt;I型指令格式是op+rs+rt+imm   汇编格式是  xxx $rt, $rs, imm&lt;/li&gt;
&lt;li&gt;J型指令格式是op+addr   汇编格式是  xxx addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200210127.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200210127&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200238754.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200238754&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200751544.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200751544&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mips-的通用寄存器-1&#34;&gt;MIPS 的通用寄存器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;0 号寄存器$zero 为固定值零，不能改变&lt;/li&gt;
&lt;li&gt;MIPS还提供了32个32位的单精度浮点寄存器$f0∽$f31,用于浮点数指令。它们可配对成16个64位的双精度浮点寄存器。&lt;/li&gt;
&lt;li&gt;在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上“$”,例如，$8或$t0。&lt;/li&gt;
&lt;li&gt;寄存器
&lt;ul&gt;
&lt;li&gt;长度：32 位&lt;/li&gt;
&lt;li&gt;个数：32 个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mips-的寻址方式-1&#34;&gt;MIPS 的寻址方式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;寄存器寻址
&lt;ul&gt;
&lt;li&gt;可以出现在 R 型和 I 型格式中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202438436.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202438436&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202455236.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202455236&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏移寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202517572.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202517572&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC 相对寻址&lt;/li&gt;
&lt;li&gt;PC&amp;lt;&amp;ndash; PC+4+imm*4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202535509.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202535509&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪直接寻址
&lt;ul&gt;
&lt;li&gt;为什么称伪直接？&lt;/li&gt;
&lt;li&gt;最终地址：PC 高四位+addr+两个 0，+表示拼接&lt;/li&gt;
&lt;li&gt;位数：4+26+2=32&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202548351.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202548351&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;机器语言的解码反汇编-1&#34;&gt;机器语言的解码（反汇编）？
&lt;/h3&gt;&lt;h3 id=&#34;高级语言汇编语言机器语言之间的转换--1&#34;&gt;高级语言、汇编语言、机器语言之间的转换 ？
&lt;/h3&gt;&lt;h3 id=&#34;risc-v-指令系统-1&#34;&gt;RISC-V 指令系统
&lt;/h3&gt;&lt;p&gt;具有模块化结构，稳定性和可扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等各方面具有显著优势。&lt;/p&gt;
&lt;p&gt;模块化结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心：RV32I + 标准扩展集：RV32M、RV32F、RV32D、RV32A = RV32G&lt;/li&gt;
&lt;li&gt;32位架构RV32G = RV32IMAFD，其压缩指令集RV32C（指令长度16位）&lt;/li&gt;
&lt;li&gt;64位架构RV64G = RV64IMAFD，其压缩指令集RV64C（指令长度16位）&lt;/li&gt;
&lt;li&gt;向量计算RV32V和RV64V；嵌入式RV32E（RV32I的子集，16个通用寄存器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;指令格式-3&#34;&gt;指令格式
&lt;/h4&gt;&lt;h5 id=&#34;32位-1&#34;&gt;32位
&lt;/h5&gt;&lt;p&gt;R-型为寄存器操作数指令&lt;/p&gt;
&lt;p&gt;I-型为短立即数或装入（Load）指令&lt;/p&gt;
&lt;p&gt;S-型为存储（Store）指令&lt;/p&gt;
&lt;p&gt;B-型为条件跳转指令&lt;/p&gt;
&lt;p&gt;U-型为长立即数操作指令&lt;/p&gt;
&lt;p&gt;J-型为无条件跳转指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204153653.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204153653&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;16位压缩-1&#34;&gt;16位压缩
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204333864.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204333864&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第五章-中央处理器-1&#34;&gt;第五章 中央处理器
&lt;/h2&gt;&lt;h3 id=&#34;cpu-的功能和基本结构-1&#34;&gt;CPU 的功能和基本结构
&lt;/h3&gt;&lt;h4 id=&#34;cpu-基本功能-1&#34;&gt;CPU 基本功能：
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。&lt;/li&gt;
&lt;li&gt;操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件从而控制这些部件按指令的要求进行动作。&lt;/li&gt;
&lt;li&gt;时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。&lt;/li&gt;
&lt;li&gt;数据加工。对数据进行算术和逻辑运算。&lt;/li&gt;
&lt;li&gt;中断处理。对计算机运行过程中出现的&lt;strong&gt;异常情况&lt;/strong&gt;和特殊请求进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;基本结构-1&#34;&gt;基本结构
&lt;/h4&gt;&lt;p&gt;数据通路 + 控制器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106220709140.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106220709140&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制器
&lt;ul&gt;
&lt;li&gt;对指令进行译码，生成指令对应的控制信号，控制数据通路的动作。它向执行部件发出控制信号，是指令的控制部件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据通路-1&#34;&gt;数据通路
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;由操作元件和存储元件通过总线方式或分散方式连接而成的进行数据传送、处理和存储的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令执行过程中，数据所经过的路径，以及路径上的部件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包括：ALU、通用寄存器、状态寄存器、MMU、cache、中断处理逻辑等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通路中专门进行数据运算的部件称为执行部件或功能部件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能：进行数据传送、处理和存储&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成元件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合逻辑元件（操作元件）：输出只取决于当前输入&lt;/li&gt;
&lt;li&gt;时序逻辑元件（也称状态元件，或存储元件）：在时钟控制下输入被写到电路中，直到下个时钟到达。
&lt;ul&gt;
&lt;li&gt;定时方式：规定信号何时写入状态元件（上升沿、下降沿、电平触发）&lt;/li&gt;
&lt;li&gt;存储元件：寄存器 &amp;ndash;&amp;gt; 寄存器组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总线、分散&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;时序控制（过去式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106221950243.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106221950243&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;现代时钟周期
&lt;ul&gt;
&lt;li&gt;…… + 状态元件 + 操作元件( 组合电路) + 状态元件 + ……
&lt;ul&gt;
&lt;li&gt;只有状态元件能存储信息，所有操作元件都从状态元件接收输入，并将输出写入状态元件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟周期= &lt;code&gt;Latch Prop + Longest Delay Path + Setup + Clock Skew(时钟偏移)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;约束条件：操作元件输出有效信号最快出现必须在下一级状态元件的输入保持时间之后出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单周期-mips-处理器的设计-1&#34;&gt;单周期 MIPS 处理器的设计
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;复习：三种指令类型 R、I、J&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223015184.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223015184&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设计处理器步骤
&lt;ol&gt;
&lt;li&gt;分析每条指令功能，并用 RTL（Register Transfer Language）来表示&lt;/li&gt;
&lt;li&gt;根据指令的功能给出所需的元件，并考虑如何将他们互连&lt;/li&gt;
&lt;li&gt;确定每个元件所需控制信号的取值&lt;/li&gt;
&lt;li&gt;汇总所有指令所涉及到的控制信号，生成一张反映指令与控制信    号之间关系的表&lt;/li&gt;
&lt;li&gt;根据表得到每个控制信号的逻辑表达式，据此设计控制器电路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设计数据通路-1&#34;&gt;设计数据通路
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;R-type：取指 &amp;ndash;&amp;gt; 取寄存器 &amp;ndash;&amp;gt; 运算 &amp;ndash;&amp;gt; 输出、计算下地址
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 从PC所指的内存单元中取指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rd] ← R[rs] + R[rt]&lt;/code&gt; 从rs、r所指的寄存器中取数后相加。若结果不溢出，则将结果送rd所指的寄存器中；若结果溢出，则不送结果，并转到“溢出处理程序”执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; PC加4，使PC指向下一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223528090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223528090&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I-type
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← R[rs] or ZeroExt(imm16)&lt;/code&gt; 立即数零扩展，并与rs内容做“或”运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223721148.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223721148&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lw 装入指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt; 计算存储单元地址 (立即数符号扩展！)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← M [Addr]&lt;/code&gt;装入数据到寄存器rt中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224257606.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224257606&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sw 指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt;   计算存储单元地址（符号扩展！）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M[Addr] ← R[rt]&lt;/code&gt; 寄存器rt中的内容存到内存单元中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224756068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224756068&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cond ← R[rs] - R[rt]&lt;/code&gt; 做减法比较rs和rt中的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (Cond eq 0)&lt;/code&gt; 计算下地址（根据比较结果，修改PC）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4 + ( SignExt(imm16) x 4 )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225017615.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225017615&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt;	        取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC&amp;lt;31:2&amp;gt; ← PC&amp;lt;31:28&amp;gt;&lt;/code&gt; 串接  &lt;code&gt;target&amp;lt;25:0&amp;gt;&lt;/code&gt;     计算目标地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;指令范围有多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不是相对寻址，是绝对寻址。转移范围&lt;strong&gt;只能在 j 指令所在的228=256MB页面内&lt;/strong&gt;，页面号与j指令相同 &lt;code&gt;PC&amp;lt;31:28&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225306971.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225306971&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225341319.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225341319&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106230643068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106230643068&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;设计控制器-1&#34;&gt;设计控制器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;方法：
&lt;ol&gt;
&lt;li&gt;根据每条指令的功能，分析控制信号的取值，并列表表示。&lt;/li&gt;
&lt;li&gt;根据列出的指令和控制信号的关系，写出每个控制信号的逻辑表达式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
