<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>笔记 on Calendar&#39;s Blog</title>
        <link>https://calendar0917.github.io/tags/%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 笔记 on Calendar&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Calendar</copyright>
        <lastBuildDate>Thu, 06 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://calendar0917.github.io/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>密码学</title>
        <link>https://calendar0917.github.io/posts/%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
        <pubDate>Sat, 25 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E5%AF%86%E7%A0%81%E5%AD%A6/</guid>
        <description>&lt;h2 id=&#34;引言与古典密码体制&#34;&gt;引言与古典密码体制
&lt;/h2&gt;&lt;h3 id=&#34;基础知识&#34;&gt;基础知识
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密和公钥加密&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据消息发送方和接收方使用的&lt;strong&gt;加密和解密密钥是否相同&lt;/strong&gt;， 加密方案可分为对称加密和公钥加密。
&lt;ul&gt;
&lt;li&gt;==公加私解==&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息认证码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息发送方和接收方首先&lt;strong&gt;共享一个密钥&lt;/strong&gt;，发送方为待发送的消息产生一个标识，并将&lt;strong&gt;消息和标识一同发送&lt;/strong&gt;给接收方。&lt;/li&gt;
&lt;li&gt;用于标志消息息在传递过程中没有被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将任意长的消息&lt;strong&gt;映射&lt;/strong&gt;为一个“较短的” “定长的” 抗碰撞的”消息&lt;strong&gt;摘要&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于保护数据完整性，防篡改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字签名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在数字世界中实现了“手写签名”的功能，保证了被签名消息的完整性和不可否认性。&lt;/li&gt;
&lt;li&gt;案基于公钥密码体制：发送者使用自己的私钥对消息进行签名，接收者使用签名者的公钥验证数字签名的合法性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;现代密码学发展史&#34;&gt;现代密码学发展史
&lt;/h3&gt;&lt;p&gt;1940 ==香农==证明了一次一密的安全性&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;K 密钥空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M 明文空间：现代密码学中，M是二进制字符串的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 密文空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密方案(Gen; Enc; Dec)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gen →K (概率性的) 密钥生成算法。&lt;/li&gt;
&lt;li&gt;Enc : K x M→C 加密算法。&lt;/li&gt;
&lt;li&gt;Dec : K x C →M 解密算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;科尔霍夫原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密码算法的安全性应该依赖于密钥k的保密性,而不应依赖于算法 Gen;Enc; Dec 的保密性。&lt;/li&gt;
&lt;li&gt;理由：
&lt;ul&gt;
&lt;li&gt;算法设计保密是不切实际的（逆向工程）。&lt;/li&gt;
&lt;li&gt;短密钥更容易保护、生成和替换。&lt;/li&gt;
&lt;li&gt;密码设计应该被公开讨论和分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;古典密码&#34;&gt;古典密码
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单表代换
&lt;ul&gt;
&lt;li&gt;移位密码：如凯撒密码、仿射密码&lt;/li&gt;
&lt;li&gt;密文空间小时，直接爆破&lt;/li&gt;
&lt;li&gt;密文空间大时，用字母频率猜测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025110458839.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025110458839&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多表代换
&lt;ul&gt;
&lt;li&gt;选择一串字符作为密钥，明文字符“加上”密钥字符得到密文字符&lt;/li&gt;
&lt;li&gt;多表代换密码是安全的：密钥长度等于明文长度&lt;/li&gt;
&lt;li&gt;当密钥长度小于明文长度时，多表代换密码易受到统计攻 击。
&lt;ul&gt;
&lt;li&gt;先确定密钥周期&lt;/li&gt;
&lt;li&gt;拆分部分，分别频率检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>大学物理（下）</title>
        <link>https://calendar0917.github.io/posts/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</guid>
        <description>&lt;p&gt;参考视频：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1XJCzYyEcp/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=f329e64c57c95b7adedc05b814353e29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《大学物理-电磁学》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;电学&#34;&gt;电学
&lt;/h2&gt;&lt;h3 id=&#34;电场强度&#34;&gt;电场强度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;库伦定律：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170518198.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170518198&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场强度：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170530237.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170530237&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022170718333.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022170718333&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于圆弧来说：&lt;code&gt;dl = Rdθ&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一些结论：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171213318.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171213318&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电通量高斯定理&#34;&gt;电通量、高斯定理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电通量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171321846.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171321846&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静电场中高斯定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171356058.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171356058&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171439634.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171439634&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电势&#34;&gt;电势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电势&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171535545.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171535545&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电势能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171635919.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171635919&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场和电势的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171726047.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171726047&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171927866.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171927866&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;导体&#34;&gt;导体
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022171823961.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022171823961&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么内部场强为零？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;导体上的电荷可以自由移动，移动后形成电场，与外部场强相抵消&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内部包围有电荷 q 时，导体上电荷分布？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;导体内层会感应出 -q，外层变为 Q+q。由高斯定理配合导体内场强为零，可知导体内部的 E * S = 0，故 q + -q = 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;传导电流&#34;&gt;传导电流
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;若将导体的两端接到电源上, 导体中便有持续的电流，这种存在导体中的电流称为传导电流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;电流密度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095303355.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095303355&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欧姆定律的微分形式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095359037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095359037&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳恒电流
&lt;ul&gt;
&lt;li&gt;可推导出基尔霍夫定律&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095500684.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095500684&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电动势&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251028095617717.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251028095617717&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;电容器&#34;&gt;电容器
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182756902.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182756902&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串并联
&lt;ul&gt;
&lt;li&gt;串联时电荷相等&lt;/li&gt;
&lt;li&gt;并联时电压相等 C = C1 + …… + Cn&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182817615.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182817615&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022182927084.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022182927084&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;电解质电场能&#34;&gt;电解质、电场能
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;电介质高斯定理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183119795.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183119795&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电场能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183208273.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183208273&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;磁学&#34;&gt;磁学
&lt;/h2&gt;&lt;h3 id=&#34;磁感应强度&#34;&gt;磁感应强度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;判断方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183346633.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183346633&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;毕奥萨法尔定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183609069.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183609069&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183630106.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183630106&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;安培环路定理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183711892.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183711892&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022183817018.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022183817018&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;磁通量高斯定理&#34;&gt;磁通量、高斯定理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184030312.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184030312&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184138965.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184138965&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安培力磁矩洛伦兹力&#34;&gt;安培力、磁矩、洛伦兹力
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安培力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184231717.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184231717&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁矩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184416546.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184416546&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;洛伦兹力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184541583.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184541583&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;磁介质磁场能&#34;&gt;磁介质、磁场能
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;磁介质&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184643080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184643080&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁场能量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022184725420.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022184725420&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>概率论</title>
        <link>https://calendar0917.github.io/posts/%E6%A6%82%E7%8E%87%E8%AE%BA/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E6%A6%82%E7%8E%87%E8%AE%BA/</guid>
        <description>&lt;p&gt;参考视频：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1N8BbY8E15/?p=2&amp;amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;amp;vd_source=f329e64c57c95b7adedc05b814353e29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;概率论四小时速成&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;随机事件与概率&#34;&gt;随机事件与概率
&lt;/h2&gt;&lt;h3 id=&#34;事件关系与运算率&#34;&gt;事件关系与运算率
&lt;/h3&gt;&lt;p&gt;事件关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075205102.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075205102&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;运算律：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075254990.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075254990&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;概率计算性质&#34;&gt;概率计算性质
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022075336338.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022075336338&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注意：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080231202.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080231202&#34;
	
	
&gt;对于多项依然成立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合并 == 概率 +&lt;/p&gt;
&lt;p&gt;集合且 == 概率 ·&lt;/p&gt;
&lt;p&gt;补充：容斥原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;条件概率&#34;&gt;条件概率
&lt;/h3&gt;&lt;p&gt;条件概率与乘法公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080612196.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080612196&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;事件的独立性&#34;&gt;事件的独立性
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080750938.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080750938&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;独立不互斥，互斥不独立&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080945953.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080945953&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多事件独立性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022080829872.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022080829872&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;全概率 - 贝叶斯公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081025058.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081025058&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;随机变量分布&#34;&gt;随机变量分布
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分布函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081325900.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081325900&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081339289.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081339289&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;概率 - 分布函数关系：配凑出范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081425038.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081425038&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分布函数的充要条件：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081621331.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081621331&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等号跟大于走，永远右连续&lt;/p&gt;
&lt;p&gt;根据规范性、右连续性，可以用极限解方程求参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常识结论：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081839150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081839150&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;离散型随机变量&#34;&gt;离散型随机变量
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022081922286.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022081922286&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布律可以写成表格的形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;古典概型：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082007258.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082007258&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据分布律写分布函数：
&lt;ul&gt;
&lt;li&gt;根据定义域划分范围，依次求和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;二项分布&#34;&gt;二项分布
&lt;/h4&gt;&lt;p&gt;独立重复、事件 A 发生的次数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082320081.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082320081&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082421022.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082421022&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;几何概型：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082537602.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082537602&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;几何分布&#34;&gt;几何分布
&lt;/h4&gt;&lt;p&gt;事件首次发生的概率&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082634533.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082634533&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;二项-01-分布&#34;&gt;二项 01 分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022082836415.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022082836415&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;泊松分布&#34;&gt;泊松分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084237766.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084237766&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一个代换：&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084307855.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084307855&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;连续型随机变量&#34;&gt;连续型随机变量
&lt;/h3&gt;&lt;h4 id=&#34;概率密度&#34;&gt;概率密度：
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084626738.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084626738&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概率为 0 的事件可能发生&lt;/p&gt;
&lt;p&gt;概率密度的积分就成为概率 &amp;ndash;&amp;gt; 在哪求概率，就在哪求积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;充要条件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022084813110.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022084813110&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与分布函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085101165.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085101165&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分定义域求积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;均匀分布&#34;&gt;均匀分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085829523.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085829523&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;指数分布&#34;&gt;指数分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022085945280.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022085945280&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用指数分布的无记忆性，转换区间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;正态分布&#34;&gt;正态分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022090654026.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022090654026&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准化：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022090834007.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022090834007&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先变换为标准正态，再求概率（用标准正态的分布函数表示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022091436382.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022091436382&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据形式配凑&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022091554558.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022091554558&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;已知-x求-fx-的分布函数&#34;&gt;已知 X，求 f(X) 的分布函数
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022092554592.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022092554592&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关键在于根据 Y &amp;lt;= y 转换出 X ~ y 关系，用 X 的分布函数代换出 Y 的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二维随机变量&#34;&gt;二维随机变量
&lt;/h2&gt;&lt;h3 id=&#34;离散型&#34;&gt;离散型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;联合分布律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094458316.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094458316&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094526051.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094526051&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094540253.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094540253&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 p_ij = 0，一定不独立&lt;/p&gt;
&lt;p&gt;独立 == 各行（列）成比例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;连续型&#34;&gt;连续型
&lt;/h3&gt;&lt;h4 id=&#34;分布密度概率&#34;&gt;分布密度、概率
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022094731080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022094731080&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找区域，二重积分即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;独立性&#34;&gt;独立性
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022095256614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022095256614&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;边缘密度&#34;&gt;边缘密度
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022095512292.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022095512292&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对另一个变量积分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;条件概率密度&#34;&gt;条件概率密度
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022100004051.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022100004051&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;固定某个参数后，概率密度只域另一个参数有关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;二位均匀&#34;&gt;二位均匀
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022100325862.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022100325862&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求面积之比即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;最大最小值分布&#34;&gt;最大、最小值分布
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022102611138.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022102611138&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;二维连续型函数分布&#34;&gt;二维连续型函数分布
&lt;/h4&gt;&lt;p&gt;分布函数法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022130118656.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022130118656&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;换元&lt;/li&gt;
&lt;li&gt;做正概区域范围 D_z 和 g(x,y) 观察交集&lt;/li&gt;
&lt;li&gt;根据 z 从负无穷到正无穷，对 x，y 积分（z 作为常数）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251022130946531.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251022130946531&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要可以反解出 y 才可使用，替换 x 或 y 以后，再乘上偏导&lt;/p&gt;
&lt;p&gt;注意定义域的选定&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>数据结构与算法</title>
        <link>https://calendar0917.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
        <pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;img src="https://raw.githubusercontent.com/calendar0917/images/master/20251022104404297.png" alt="Featured image of post 数据结构与算法" /&gt;&lt;h2 id=&#34;绪论&#34;&gt;绪论
&lt;/h2&gt;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形式定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构是一个四元组 &lt;code&gt;Data_Structure=（D,L,S,O）&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;D是数据元素的有限集&lt;/li&gt;
&lt;li&gt;L是D上客观存在的关系（&lt;strong&gt;逻辑结构&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;S是关系L在计算机中的存储表示（&lt;strong&gt;存储结构&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;O是D上规定的一组操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集合（set）—若干具有共同特征的事物的“聚合”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据（data) —所有能输入到计算机中的描述客观事物的符号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据元素（data element）—数据的基本单位，也称节点（node）或记录（record）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据项（data item）—有独立含义的数据最小单位，也称域(field)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键码（key）—数据元素中能起标识作用的数据项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 —集合中元素之间的某种相关性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性结构：一对一，线性表、栈、队列等&lt;/li&gt;
&lt;li&gt;树形结构&lt;/li&gt;
&lt;li&gt;图状结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序：借助相对位置表示元素间关系&lt;/li&gt;
&lt;li&gt;链式：借助指针&lt;/li&gt;
&lt;li&gt;散列：通过对关键字直接计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为了解决某类问题而规定的一个有限长的操作序列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特性：有穷、确定、可行、功能性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标：正确、可读、健壮、高效率与低存储量需求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;衡量方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法的时间特性用执行基本操作次数来度量&lt;/li&gt;
&lt;li&gt;算法的空间特性用算法运行所需存储量的增长率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线性表栈与队列&#34;&gt;线性表、栈与队列
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线性结构特点：在数据元素的非空有限集中
&lt;ul&gt;
&lt;li&gt;存在唯一一个称作“&lt;strong&gt;第一个&lt;/strong&gt;”的数据元素&lt;/li&gt;
&lt;li&gt;存在唯一一个称作“&lt;strong&gt;最后一个&lt;/strong&gt;”的数据元素&lt;/li&gt;
&lt;li&gt;除第一个外，集合中的每个数据元素均&lt;strong&gt;只有一个前驱&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;除最后一个外，集合中的每个数据元素均&lt;strong&gt;只有一个后继&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线性表&#34;&gt;线性表
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：一个线性表是n个数据元素的有限序列
&lt;ul&gt;
&lt;li&gt;元素个数n = 表长度&lt;/li&gt;
&lt;li&gt;a_1 无直接前驱，a_n 无直接后继&lt;/li&gt;
&lt;li&gt;i 为 a_i 再线性表中的位序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;顺序存储&#34;&gt;顺序存储
&lt;/h4&gt;&lt;p&gt;逻辑上相邻 - 物理地址相邻&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入：复杂度 &lt;code&gt;n/2&lt;/code&gt;，算在 i 出的平均移动次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除：复杂度 &lt;code&gt;(n-1)/2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑相邻，物理相邻&lt;/li&gt;
&lt;li&gt;可随机存取任一元素&lt;/li&gt;
&lt;li&gt;存储空间使用紧凑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入、删除操作需要移动大量的元素&lt;/li&gt;
&lt;li&gt;预先分配空间需按最大空间分配，利用不充分&lt;/li&gt;
&lt;li&gt;表容量难以扩充&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;链式存储&#34;&gt;链式存储
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;用一组任意的存储单元存储线性表的数据元素，利用指针实现：&lt;strong&gt;用不相邻的存储单元存放逻辑上相邻的元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;单链表&#34;&gt;单链表
&lt;/h5&gt;&lt;p&gt;结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;ElemType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNodePtr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 生成新节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNodePtr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 回收节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入、删除：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态结构，整个存储空间为多个链表共用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需预先分配空间，指针额外存储空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能随机读取，查找慢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;循环链表&#34;&gt;循环链表
&lt;/h5&gt;&lt;p&gt;表中最后一个结点的指针指向头结点，使链表构成环状&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从表中任一结点出发均可找到表中其他结点， 提高查找效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;操作与单链表基本一致,循环条件不同：
&lt;ul&gt;
&lt;li&gt;单链表 p 或 &lt;code&gt;p-&amp;gt;next=NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;循环链表 &lt;code&gt;p-&amp;gt;next=h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;双向链表&#34;&gt;双向链表
&lt;/h5&gt;&lt;p&gt;解决单链表单向性的问题，存储前、后指针&lt;/p&gt;
&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;h4 id=&#34;顺序存储-1&#34;&gt;顺序存储
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义：
&lt;ul&gt;
&lt;li&gt;限定仅在表尾进行插入或删除操作的线性表，进行操作的一端称栈顶，固定的一端称栈底，不含元素的空表称空栈。&lt;/li&gt;
&lt;li&gt;先进后出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作：
&lt;ul&gt;
&lt;li&gt;用指针 &lt;code&gt;top&lt;/code&gt; 始终指向栈顶，初值为 -1 （栈空），终值为 M-1 （栈满）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define MAXSTACK 100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;StackEntry&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MAXSTACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;链式存储-1&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;top 始终指向下一个插入的位置，类似&lt;/p&gt;
&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;p&gt;限定只能在表的一端进行插入，在表的另一端进行删除的线性表，&lt;code&gt;先进先出&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;链式存储-2&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;设队首、队尾指针 front 和rear, front 指向头结点，rear 指向队尾&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列不满时假溢出、队列满时真溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;队首固定：需要频繁移动 X&lt;/li&gt;
&lt;li&gt;循环队列：将队列设计成环形，让 &lt;code&gt;让sq[0]&lt;/code&gt; 接在 &lt;code&gt;sq[M-1]&lt;/code&gt; 之后，若 rear == M，则令 rear = 0
&lt;ul&gt;
&lt;li&gt;问题：队空和队满标志一样&lt;/li&gt;
&lt;li&gt;解决：另设标志位、少用一个元素空间、用一个计数变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;优先队列&#34;&gt;优先队列
&lt;/h4&gt;&lt;p&gt;不完全遵守先进先出，设有优先级&lt;/p&gt;
&lt;h3 id=&#34;数组&#34;&gt;数组
&lt;/h3&gt;&lt;h4 id=&#34;顺序存储-2&#34;&gt;顺序存储：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要区分列主序、行主序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Loc (j1, j2, ... , jn )=Loc (0, 0, ... , 0)+(b2*b3*...*bn*j1 + b3*b4*...*bn*j2+ ...+bn*jn-1+ jn)*l&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三角矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025143824138.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025143824138&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三对角矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025143918477.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025143918477&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;稀疏矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025144028082.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025144028082&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;链式存储-3&#34;&gt;链式存储
&lt;/h4&gt;&lt;p&gt;表示矩阵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组 + 链表&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025145127520.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025145127520&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;查找排序递归&#34;&gt;查找、排序、递归
&lt;/h2&gt;&lt;h3 id=&#34;递归&#34;&gt;递归
&lt;/h3&gt;&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个过程或函数出现调用本过程或本函数的成分,称之为递归。&lt;/li&gt;
&lt;li&gt;若调用自身,称之为&lt;strong&gt;直接递归&lt;/strong&gt;。若过程或函数p调用过程或函数q,而q又调用 p,称之为&lt;strong&gt;间接递归&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果一个递归过程或递归函数中递归调用语句是最后一条执行语句,则称这种递归调用为&lt;strong&gt;尾递归&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找
&lt;/h3&gt;&lt;h4 id=&#34;顺序表&#34;&gt;顺序表
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;顺序查找，改变 &lt;code&gt;R[0]&lt;/code&gt; 以控制结束：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seqsearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;折半查找，对于有序表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BinarySearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;c1&#34;&gt;//在长度为n的有序表SL中折半查找其关键字等于key的数据元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;//查找成功返回其在有序表中的位置，查找失败否返回0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;}&lt;/span&gt;              
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;high&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;索引表查找
&lt;ul&gt;
&lt;li&gt;基本思想：将&lt;strong&gt;原表分成若干块&lt;/strong&gt;，各块内部不一定有序，但表中的块是“&lt;strong&gt;分块有序&lt;/strong&gt;”的，&lt;strong&gt;抽取各块中的最大关键字&lt;/strong&gt;及其起始位置建立索引表。&lt;/li&gt;
&lt;li&gt;块间顺序：复杂度 &lt;code&gt;1/2 * (n/s + s) + 1&lt;/code&gt; (n 长度，分成 n/s 块)&lt;/li&gt;
&lt;li&gt;块间二分：&lt;code&gt;log_2(n/s + 1) + s/2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IndexSequelSearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IndexType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;c1&#34;&gt;//索引表中顺序查找关键字为key的记录。索引表为ls[0]-ls[m-1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//顺序表为s，块长为l
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//在索引表中顺序查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//块间查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;//在块内顺序查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                  &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Link&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Link&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                   &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//查找失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;哈希表查找
&lt;ul&gt;
&lt;li&gt;以 &lt;code&gt;h(key) 哈希函数&lt;/code&gt; 作为 key 的记录在表中的位置，常见构造方法有：
&lt;ul&gt;
&lt;li&gt;直接哈希：适用于地址集合大小 == 关键字集合大小&lt;/li&gt;
&lt;li&gt;数字分析：取随机&lt;/li&gt;
&lt;li&gt;平方取中：取关键字平方后的中间几位&lt;/li&gt;
&lt;li&gt;折叠：关键字分割后求和&lt;/li&gt;
&lt;li&gt;除留取余：除某个不大于哈希表长度的数后取余&lt;/li&gt;
&lt;li&gt;随机数：取随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突处理方法：
&lt;ul&gt;
&lt;li&gt;开放地址：线性探测、平方探测、随机探测 再散列&lt;/li&gt;
&lt;li&gt;再哈希：将 n 个不同哈希函数排成序列，往下计算&lt;/li&gt;
&lt;li&gt;链地址：将关键字发生冲突的记录存储在一个线性链表中&lt;/li&gt;
&lt;li&gt;公共溢出：将发生冲突的放在冲突表中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ALS 影响因素：
&lt;ul&gt;
&lt;li&gt;选用的哈希函数&lt;/li&gt;
&lt;li&gt;冲突处理方法&lt;/li&gt;
&lt;li&gt;哈希表饱和度、装载因子 &lt;code&gt;n/m&lt;/code&gt; 的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序
&lt;/h3&gt;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;稳定性：对于任意的数据元素序列，以在排序前后&lt;strong&gt;相同关键字数据的相对位置&lt;/strong&gt;是否改变为依据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内外部：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需借助外存，称内部排序&lt;/li&gt;
&lt;li&gt;数据量巨大，需要借助外村，称外部排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;插入&#34;&gt;插入
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;直接插入：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;在&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;中查找&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的插入位置&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;err&#34;&gt;插入&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025154450647.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025154450647&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;折半插入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 &lt;code&gt;R[1..i-1]&lt;/code&gt; 是一个按关键字有序的有序序列，则可以利用折半查找实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希尔排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;strong&gt;n较大而且无序时&lt;/strong&gt;，直接插入排序效率就较低，这时，如果能&lt;strong&gt;将序列分成几个较小的序列&lt;/strong&gt;，对这些较小的序列先排序，然后再对较长的序列进行排序，可一定程度地提高排序效率。&lt;/li&gt;
&lt;li&gt;步骤：
&lt;ul&gt;
&lt;li&gt;先选取一个小于n的整数di（步长），然后把待排序的序列分成di个组&lt;/li&gt;
&lt;li&gt;第一趟完成之后，减小步长，再进行分组，再排序，如此知道 d=1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;交换&#34;&gt;交换
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;冒泡排序
&lt;ul&gt;
&lt;li&gt;基于两两比较及交换，直到某一趟没有发生数据的交换为止。&lt;/li&gt;
&lt;li&gt;改进：记下上次交换的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Bubble_Sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DataType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//对长度为n的序列R按升序进行冒泡排序，降序排序类似
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//交换标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 可以改进成 j&amp;lt;i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;不满足升序规则，交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//此趟冒泡没有发生交换，排序结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251025160526177.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251025160526177&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>计算机组成原理</title>
        <link>https://calendar0917.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
        <pubDate>Fri, 03 Oct 2025 00:00:00 +0000</pubDate>
        
        <guid>https://calendar0917.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;第一章-计算机系统概述&#34;&gt;第一章 计算机系统概述
&lt;/h2&gt;&lt;h3 id=&#34;计算机系统的发展&#34;&gt;计算机系统的发展
&lt;/h3&gt;&lt;p&gt;计算机系统 = 硬件 + 软件&lt;/p&gt;
&lt;h4 id=&#34;软件&#34;&gt;软件
&lt;/h4&gt;&lt;p&gt;系统软件：用来管理整个计算机系统&lt;/p&gt;
&lt;p&gt;应用软件：按任务需要编制成的程序&lt;/p&gt;
&lt;h4 id=&#34;硬件&#34;&gt;硬件
&lt;/h4&gt;&lt;p&gt;第一台电子数字计算机：&lt;strong&gt;ENIAC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑元件（用于处理电信号的最小单元）：电子管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;十进制表示，手动编程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无冯 · 诺伊曼结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二代：晶体管&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带）&lt;/li&gt;
&lt;li&gt;特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。&lt;/li&gt;
&lt;li&gt;软件：使用高级语言，提供系统软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三代：中小规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元器件：逻辑元件和主存储器均由&lt;strong&gt;集成电路&lt;/strong&gt;实现。&lt;/li&gt;
&lt;li&gt;特点：微程序控制，Cache，虚拟存储器，流水线。&lt;/li&gt;
&lt;li&gt;代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IBM 360（&lt;strong&gt;兼容机&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;相同/相似的指令集&amp;amp;操作系统。&lt;/p&gt;
&lt;p&gt;好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。&lt;/p&gt;
&lt;p&gt;保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;DEC PDP-8（&lt;strong&gt;采用总线结构&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第四代：大规模、超大规模集成电路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半导体存储器，微处理器发展迅速。&lt;/li&gt;
&lt;li&gt;特点：共享存储器，分布式存储器以及大规模并行系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组成&#34;&gt;组成
&lt;/h3&gt;&lt;h4 id=&#34;冯诺依曼结构模型&#34;&gt;冯诺依曼结构模型
&lt;/h4&gt;&lt;p&gt;冯诺依曼提出&lt;strong&gt;存储程序&lt;/strong&gt;，取代手动接线。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冯诺依曼结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。&lt;/li&gt;
&lt;li&gt;各基本部件功能：
&lt;ol&gt;
&lt;li&gt;存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；&lt;/li&gt;
&lt;li&gt;控制器应能自动执行指令；&lt;/li&gt;
&lt;li&gt;运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；&lt;/li&gt;
&lt;li&gt;操作人员可以通过输入设备和输出设备与主机进行通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内部以&lt;strong&gt;二进制数&lt;/strong&gt;表述指令和数据
&lt;ol&gt;
&lt;li&gt;每条指令由&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;地址码&lt;/strong&gt;两部分组成。操作码指出操作的类型，地址码指出操作数的地址。&lt;/li&gt;
&lt;li&gt;由一串指令组成程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;工作方式
&lt;ol&gt;
&lt;li&gt;将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/20251003090538614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本部件及其功能&#34;&gt;基本部件及其功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;运算器（数据运算）：ALU、GPRs、标志寄存器等。&lt;/li&gt;
&lt;li&gt;存储器（数据存储）：存储阵列、地址译码器、读写控制电路&lt;/li&gt;
&lt;li&gt;总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线&lt;/li&gt;
&lt;li&gt;控制器（控制）：对指令译码生成控制信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU = 运算器 + 控制器&lt;/p&gt;
&lt;p&gt;主机 = CPU + 主存&lt;/p&gt;
&lt;h4 id=&#34;各硬件工作原理&#34;&gt;各硬件工作原理
&lt;/h4&gt;&lt;h5 id=&#34;主存储器&#34;&gt;主存储器
&lt;/h5&gt;&lt;p&gt;主存储器 = 存储体 + MAR + MDR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数&lt;/li&gt;
&lt;li&gt;Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令）&lt;/li&gt;
&lt;li&gt;存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1B = 1 byte ; 1 b = 1 bit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;MAR、MDR 逻辑上属于主存，但被集成到 CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;运算器&#34;&gt;运算器
&lt;/h5&gt;&lt;p&gt;实现算数运算、逻辑运算&lt;/p&gt;
&lt;p&gt;运算器 = ACC + ALU + MQ + X&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accumulator：累加器，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果&lt;/li&gt;
&lt;li&gt;Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算&lt;/li&gt;
&lt;li&gt;X：通用的操作数寄存器，用于存放操作数&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;控制器&#34;&gt;控制器
&lt;/h5&gt;&lt;p&gt;控制器 = CU + IR +PC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Control Unit:控制单元，分析指令，给出控制信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instruction Register:指令寄存器，存放当前执行的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Program Counter:程序计数器，存放下一条指令地址，有自动加1功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配合&#34;&gt;配合
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003094316150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003094316150&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;指令和数据&#34;&gt;指令和数据
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序启动前，指令和数据都存储在存储器中，&lt;strong&gt;形式上没有区别&lt;/strong&gt;，都是 0/1 序列。&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。&lt;/li&gt;
&lt;li&gt;指令执行过程中，指令和数据从存储器取到 CPU，&lt;strong&gt;指令存在 IR 中，数据在 GPR 中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令需要给出的信息
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作码&lt;/strong&gt;：指令的操作，加减法等&lt;/li&gt;
&lt;li&gt;一个或多个&lt;strong&gt;源操作数&lt;/strong&gt;：立即数、寄存器编号、存储地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的操作数地址&lt;/strong&gt;：寄存器编号、存储地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;执行过程&#34;&gt;执行过程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;程序执行前
&lt;ul&gt;
&lt;li&gt;数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始执行程序
&lt;ul&gt;
&lt;li&gt;根据 PC &lt;strong&gt;取指&lt;/strong&gt;令送 IR：PC -&amp;gt; MAR -&amp;gt;存储器 -&amp;gt; MDR -&amp;gt; IR&lt;/li&gt;
&lt;li&gt;指令&lt;strong&gt;译码&lt;/strong&gt;：IR -&amp;gt; 控制器，控制器译码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取操作数&lt;/strong&gt;：GPRs 或存储器 -&amp;gt; ALU&lt;/li&gt;
&lt;li&gt;执行指令操作：ALU &lt;strong&gt;运算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回写&lt;/strong&gt;结果到 GPRs 或存储器&lt;/li&gt;
&lt;li&gt;修改 &lt;strong&gt;PC&lt;/strong&gt; 的值，使其指向&lt;strong&gt;下一条指令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;重复上述步骤直到程序完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;软件-1&#34;&gt;软件
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统软件——简化编程，&lt;strong&gt;使硬件资源被有效利用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：硬件资源管理，用户接口&lt;/li&gt;
&lt;li&gt;语言处理程序：翻译程序，Linker，Debug&amp;hellip;
&lt;ul&gt;
&lt;li&gt;翻译程序
&lt;ul&gt;
&lt;li&gt;汇编器（Assembler）：汇编语言源程序-&amp;gt;机器目标程序。或许叫汇编器更好理解？&lt;/li&gt;
&lt;li&gt;编译器（Complier）：高级语言程序-&amp;gt;汇编/机器目标程序。或许叫编译器更好理解？&lt;/li&gt;
&lt;li&gt;解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他实用程序：磁盘碎片整理、备份程序&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;机器语言：二进制代码&lt;/p&gt;
&lt;p&gt;汇编语言：助记符&lt;/p&gt;
&lt;p&gt;高级语言：C、C++、……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用软件——解决&lt;strong&gt;具体的应用&lt;/strong&gt;问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;层次结构&#34;&gt;层次结构
&lt;/h3&gt;&lt;h4 id=&#34;语言层次&#34;&gt;语言层次
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;微指令系统：直接控制硬件执行&lt;/li&gt;
&lt;li&gt;机器语言：传统机器M1，执行二进制机器指令&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作系统机器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编语言：虚拟机器M2，用汇编语言翻译成机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级语言：虚拟机器M3，需要编译成汇编、机器语言&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上两层视为硬件层&lt;/p&gt;
&lt;p&gt;计算机体系结构：讨论如何设计硬件与软件之间的接口&lt;/p&gt;
&lt;p&gt;计算机组成原理：讨论如何用硬件实现接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003100912264.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003100912264&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;isa&#34;&gt;ISA
&lt;/h4&gt;&lt;p&gt;指令集体系结构，其作为&lt;strong&gt;规约&lt;/strong&gt;，规定了&lt;strong&gt;如何使用硬件&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行的指令集合，包括&lt;strong&gt;指令格式&lt;/strong&gt;、&lt;strong&gt;操作种类&lt;/strong&gt;以及对应&lt;strong&gt;操作数&lt;/strong&gt;的规定。&lt;/li&gt;
&lt;li&gt;可以接受的&lt;strong&gt;操作数类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数存放的&lt;strong&gt;寄存器组结构&lt;/strong&gt;，例如寄存器名称、编号、长度和用途。&lt;/li&gt;
&lt;li&gt;操作数存放的存储空间的&lt;strong&gt;大小和编址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;操作数在存储空间中按&lt;strong&gt;大/小端&lt;/strong&gt;方式存放。&lt;/li&gt;
&lt;li&gt;指令获得操作数的方式，即&lt;strong&gt;寻址方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;指令执行过程的&lt;strong&gt;控制方式&lt;/strong&gt;，例如程序计数器，条件码定义等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ISA 是计算机系统中&lt;strong&gt;必不可少的抽象层&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;性能指标&#34;&gt;性能指标
&lt;/h3&gt;&lt;h4 id=&#34;存储器&#34;&gt;存储器
&lt;/h4&gt;&lt;p&gt;总容量 = 存储单元个数 * 存储字长(bit)&lt;/p&gt;
&lt;h4 id=&#34;cpu&#34;&gt;CPU
&lt;/h4&gt;&lt;h5 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主频：CPU内数字脉冲信号振荡的频率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;= 1 / 时钟周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPS：每秒执行多少个命令 = 主频 / 平均CPI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FLOPS：每秒执行多少次浮点运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;K=Kilo=千=10^3&lt;/p&gt;
&lt;p&gt;M=Million=百万=10^6&lt;/p&gt;
&lt;p&gt;G=Giga=十亿=10^9&lt;/p&gt;
&lt;p&gt;T=Tera=万亿=10^12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：单位时间内处理请求的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相应时间：CPU时间 + 等待时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准程序：用于测量的程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于&lt;strong&gt;单条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;MIPS 为平均值，其并没有考虑以上三个属性，并且由于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同机器指令集不同&lt;/li&gt;
&lt;li&gt;程序由不同指令混合而成&lt;/li&gt;
&lt;li&gt;指令的频率会动态变换&lt;/li&gt;
&lt;li&gt;厂家给出峰值 MIPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，MIPS 表示性能存在局限性。&lt;/p&gt;
&lt;p&gt;MFLOPS：每秒执行浮点运算多少百万次，着重在于&lt;strong&gt;浮点操作&lt;/strong&gt;本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;计算&#34;&gt;计算
&lt;/h5&gt;&lt;p&gt;CPU 执行时间=CPI×程序总指令条数×时钟周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003103925476.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003103925476&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二章-数据的机器级表示&#34;&gt;第二章 数据的机器级表示
&lt;/h2&gt;&lt;h3 id=&#34;信息二进制编码&#34;&gt;信息二进制编码
&lt;/h3&gt;&lt;p&gt;计算机内部数据：二进制表示&lt;/p&gt;
&lt;p&gt;机器级数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数值数据，无符号/带符号整数，浮点数，十进制数&lt;/li&gt;
&lt;li&gt;非数值数据，逻辑数，汉字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二进制编码原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;制造两个稳态的物理器件容易&lt;/li&gt;
&lt;li&gt;二进制编码、计数、运算规则简单。&lt;/li&gt;
&lt;li&gt;与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;机器数：0/1 编码的 0/1 内部 0/1 序列。&lt;/p&gt;
&lt;p&gt;真值：机器数真正的值&lt;/p&gt;
&lt;h4 id=&#34;数值数据表示方法&#34;&gt;数值数据表示方法
&lt;/h4&gt;&lt;p&gt;三要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位计数制：十进制，二进制等转换。&lt;/li&gt;
&lt;li&gt;定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示）&lt;/li&gt;
&lt;li&gt;编码：原码补码反码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若不知道三要素，那么便无法得知机器数的具体真值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进制转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制 -&amp;gt; 其他：划分位数，对应&lt;/li&gt;
&lt;li&gt;十六、八 -&amp;gt; 二：位数对应，补全&lt;/li&gt;
&lt;li&gt;十进制 -&amp;gt; 任意位数：求商取余&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定点数的表示&#34;&gt;定点数的表示
&lt;/h4&gt;&lt;p&gt;常规计数，小数点位置固定。整数、小数分开存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数：没有符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 +0、-0 两种表示形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正数与原码相同&lt;/li&gt;
&lt;li&gt;若符号位为1，则数值位全部取反&lt;/li&gt;
&lt;li&gt;依然有 +0、-0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将减法抓换为等价的加法（加上补数）&lt;/li&gt;
&lt;li&gt;= 原码除符号位外，取反后加一（即反码 + 1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移码： &lt;strong&gt;将每一个数值加上一个偏置常数（ bias）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一般来说，当编码位数为 n **时，bias 取 2^n 标准移码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要用移码来表示阶码？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便于浮点数加减运算时的对阶操作（比较大小）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与补码的关系：&lt;strong&gt;最高位相反，其余位相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c语言的解析&#34;&gt;C语言的解析
&lt;/h4&gt;&lt;p&gt;无符号数变为有符号：不改变数据内容，改变解释方式&lt;/p&gt;
&lt;p&gt;长变短：高位截断，保留地位&lt;/p&gt;
&lt;p&gt;短变长：符号扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负数补1，正数补0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ieee编码&#34;&gt;IEEE编码
&lt;/h3&gt;&lt;p&gt;规定了二进制浮点数算数标准，类似科学计数法简化计数&lt;/p&gt;
&lt;h4 id=&#34;二进制浮点数&#34;&gt;二进制浮点数
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号：决定数值的正负性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数：影响数值的精度。尾数的位数越多，精度越高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码：反映小数点的实际位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数：K进制通常默认基数为K&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格化：石确保尾数的最高位非0数位刚好在小数点之前&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;float型：32位单精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 8 + 23&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;double型：64位双精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号 + 阶码 + 尾数：1 + 11 + 52&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;float单精度&#34;&gt;float单精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认存储规格化尾数，小数点前的1省略（隐含）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数规定为 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码用移码表示，规定偏置值为 127&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何将十进制真值转换为偏置值为M的移码？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将十进制真值+偏置值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按“无符号整数”规则转换为指定位数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;double双精度&#34;&gt;double双精度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;偏置值为1023&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;表示范围&#34;&gt;表示范围
&lt;/h4&gt;&lt;h4 id=&#34;特殊状态&#34;&gt;特殊状态
&lt;/h4&gt;&lt;p&gt;阶码全 0，或阶码全 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码真值的取值范围为 -126 ~ 127（单精度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003161255970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003161255970&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据数轴，存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正上溢、正下溢、负上溢，负下移&lt;/li&gt;
&lt;li&gt;上溢置为无穷，下溢置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003160611584.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003160611584&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据表示&#34;&gt;数据表示
&lt;/h3&gt;&lt;h4 id=&#34;十进制数表示&#34;&gt;十进制数表示
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ASCII 码：就是把数字当作字符存储，&lt;strong&gt;0-9用30H-39H表示&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前分隔：&lt;strong&gt;正号用 2B  负号用 2D&lt;/strong&gt;  放在最前面&lt;/li&gt;
&lt;li&gt;后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。
&lt;ul&gt;
&lt;li&gt;正数不变；负数高 4 位变为 0111。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD 码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;西文字符表示&#34;&gt;西文字符表示：
&lt;/h4&gt;&lt;p&gt;复习要点中未提到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制数字：0/1/2…/9             10 个&lt;/li&gt;
&lt;li&gt;英文字母：A/B/…/Z/a/b/…/z    52 个&lt;/li&gt;
&lt;li&gt;专用符号：+/-/%/*/&amp;amp;/……        33 个&lt;/li&gt;
&lt;li&gt;控制字符（不可打印或显示）  33 个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;汉字表示&#34;&gt;汉字表示
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;输入码：用于输入汉字。&lt;/li&gt;
&lt;li&gt;内码：用于在系统中进行存储、查找、传送等处理&lt;/li&gt;
&lt;li&gt;字模点阵或轮廓描述：用于显示/打印&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据的宽度&#34;&gt;数据的宽度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bit&lt;/li&gt;
&lt;li&gt;字节：
&lt;ul&gt;
&lt;li&gt;现代计算机中，存储器按字节编址&lt;/li&gt;
&lt;li&gt;字节是最小可寻址单位 （addressable unit ）&lt;/li&gt;
&lt;li&gt;LSB 表示最低有效字节，MSB 表示最高有效字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字
&lt;ul&gt;
&lt;li&gt;表示被处理信息的单位，用来度量数据类型的宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字长
&lt;ul&gt;
&lt;li&gt;指某特定机器定点运算时数据通路的宽度。&lt;/li&gt;
&lt;li&gt;数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。&lt;/li&gt;
&lt;li&gt;等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据的存储和排列顺序&#34;&gt;数据的存储和排列顺序
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大小端
&lt;ul&gt;
&lt;li&gt;小端（ &lt;strong&gt;Little Endian&lt;/strong&gt;）:低字节放低地址&lt;/li&gt;
&lt;li&gt;大端（ &lt;strong&gt;Big Endian&lt;/strong&gt;）:高字节放低地址&lt;/li&gt;
&lt;li&gt;指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对齐：要求数据存放的地址必须是相应的边界地址
&lt;ul&gt;
&lt;li&gt;每次访存只能读写一个字&lt;/li&gt;
&lt;li&gt;浪费一定空间，换取存取时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003164347928.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003164347928&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据的检错与纠错&#34;&gt;数据的检错与纠错
&lt;/h3&gt;&lt;p&gt;大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码&lt;/li&gt;
&lt;li&gt;海明校验码&lt;/li&gt;
&lt;li&gt;循环冗余校验码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三章-运算方法和运算部件&#34;&gt;第三章 运算方法和运算部件
&lt;/h2&gt;&lt;h3 id=&#34;加法器&#34;&gt;加法器
&lt;/h3&gt;&lt;h4 id=&#34;串行进位&#34;&gt;串行进位
&lt;/h4&gt;&lt;p&gt;传递速度慢&lt;/p&gt;
&lt;h4 id=&#34;并行进位&#34;&gt;并行进位
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用先行进位优化，各进位之间无等待，相互独立并同时产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但全先行电路复杂，成本高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部先行进位加法器： &lt;strong&gt;组内并行、组间串行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用多个位数较少的 n 位全先行进位加法器进行串联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级先行进位加法器： &lt;strong&gt;组内并行、组间并行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alu的构成&#34;&gt;ALU的构成
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ALU 如何控制实现加、减、与、或等等各种功能；
&lt;ol&gt;
&lt;li&gt;无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。&lt;/li&gt;
&lt;li&gt;在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;零标志 ZF、&lt;strong&gt;&lt;strong&gt;溢出标志 OF&lt;/strong&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;进/借位标志 CF&lt;/strong&gt;&lt;/strong&gt;、符号标志 SF&lt;/strong&gt; 称为&lt;strong&gt;条件标志。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中&lt;/li&gt;
&lt;li&gt;存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003180007637.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003180007637&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;溢出条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无符号加、减溢出条件：CF=1&lt;/li&gt;
&lt;li&gt;带符号加、减溢出条件：OF=1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数运算&#34;&gt;定点数运算
&lt;/h3&gt;&lt;h4 id=&#34;移位&#34;&gt;移位
&lt;/h4&gt;&lt;p&gt;逻辑移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;针对无符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左移 n 位，即乘上位权的 n 次方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高位溢出丢弃，低位补 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算数移位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左移与逻辑移位类似，但移到符号位结果更改&lt;/li&gt;
&lt;li&gt;右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;加减&#34;&gt;加减
&lt;/h4&gt;&lt;p&gt;原码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减法用减法器实现，1 变 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位可以一起参与运算&lt;/li&gt;
&lt;li&gt;[A+B]补=[A]补+ [B]补&lt;/li&gt;
&lt;li&gt;[A-B]补=[A]补+[-B]补&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;乘法&#34;&gt;乘法
&lt;/h4&gt;&lt;h5 id=&#34;无符号整数&#34;&gt;无符号整数：
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;模拟手算乘法即可，计算机还需拆分部分积&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251003165328818.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251003165328818&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;带符号整数&#34;&gt;带符号整数
&lt;/h5&gt;&lt;p&gt;给无符号整数乘法电路添加一辅助位，让符号位参与运算。&lt;/p&gt;
&lt;p&gt;计算机底层判断溢出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 2n 位的高 n + 1 位不均相同，则溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;实现方式&#34;&gt;实现方式
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ALU + 移位器 + 寄存器 + 控制逻辑&lt;/li&gt;
&lt;li&gt;阵列乘法器&lt;/li&gt;
&lt;li&gt;逻辑运算模拟&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浮点数运算&#34;&gt;浮点数运算
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浮点数加减运算的对阶原则和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原则：小阶向大阶看齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何计算一个移码数减 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数规格化中的右规和左规方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码减 1 后要判断阶码是否下溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1
&lt;ul&gt;
&lt;li&gt;每次阶码加 1 后要判断阶码是否上溢&lt;/li&gt;
&lt;li&gt;先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阶码溢出异常处理：
&lt;ul&gt;
&lt;li&gt;阶码上溢，则结果溢出；&lt;/li&gt;
&lt;li&gt;阶码下溢，则结果为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乘法运算结果不需左规！最多右规 1 次！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;除法最多左规 1 次！不需右规！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数的舍入处理常用方法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就近舍入：舍入为最近可表示的数
&lt;ul&gt;
&lt;li&gt;若为非中间值：LSB 后 1 位 0 舍 1 入&lt;/li&gt;
&lt;li&gt;若为中间值：强迫结果为偶数， LSB=
&lt;ul&gt;
&lt;li&gt;1.1101110 → 1.1110       (1.1101110 → 1.1110,  110&amp;gt;100, 1.1101+0.0001 = 1.1110)&lt;/li&gt;
&lt;li&gt;1.1101011 → 1.1101       (1.1101011 → 1.1101,  011&amp;lt;100, 1.1101+    0     = 1.1101)&lt;/li&gt;
&lt;li&gt;1.1101101 → 1.1110&lt;/li&gt;
&lt;li&gt;1.1111100 → 10.0000     (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1101 ；  1.1101101 →1.1110&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入）
&lt;ul&gt;
&lt;li&gt;例：-1.1101101 →-1.1110 ；  1.1101101 →1.1101&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断结果溢出（上溢和下溢）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第四章&#34;&gt;第四章
&lt;/h2&gt;&lt;h3 id=&#34;指令格式&#34;&gt;指令格式
&lt;/h3&gt;&lt;p&gt;指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。&lt;/p&gt;
&lt;h4 id=&#34;根据地址码数不同&#34;&gt;根据地址码数不同
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;零地址指令：
&lt;ul&gt;
&lt;li&gt;不需要操作数，如停机、关中断等&lt;/li&gt;
&lt;li&gt;堆栈计算机，操作数隐藏在栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一地址指令：
&lt;ul&gt;
&lt;li&gt;只需单操作数，如加一、取反&lt;/li&gt;
&lt;li&gt;需两个操作数，但其中一个存储在某个寄存器内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二地址指令：
&lt;ul&gt;
&lt;li&gt;用于需要两个操作数的算术运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三地址指令：
&lt;ul&gt;
&lt;li&gt;多一个地址存储结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;四地址指令：
&lt;ul&gt;
&lt;li&gt;再多一个地址存储下一个指令地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令位数不变时，地址码数越多，寻址能力越差&lt;/p&gt;
&lt;h4 id=&#34;按指令长度分类&#34;&gt;按指令长度分类
&lt;/h4&gt;&lt;p&gt;指令字长：一条指令的总长度(可能会变)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;影响取指令所需时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;机器字长：CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)&lt;/p&gt;
&lt;p&gt;存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)&lt;/p&gt;
&lt;h4 id=&#34;按操作码长度分类&#34;&gt;按操作码长度分类
&lt;/h4&gt;&lt;p&gt;定长：译码电路设计简单，但复杂性低&lt;/p&gt;
&lt;h4 id=&#34;按操作类型分类&#34;&gt;按操作类型分类
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据传送&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LOAD：把存储器中的数据放到寄存器中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STORE： 把寄存器中的数据放到存储器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数逻辑操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑（与或非、位操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数、逻辑、循环移位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转移操作（改变程序执行流，PC指针改变）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无条件转移 JMP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件转移JZ：结果为0；JO：结果溢出；JC：结果有进位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用和返回 CALL和RETURN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;陷阱(Trap)与陷阱指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入输出操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;设计&#34;&gt;设计
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指令格式的选择应遵循的几条基本原则
&lt;ul&gt;
&lt;li&gt;应尽量短&lt;/li&gt;
&lt;li&gt;要有足够的操作码位数&lt;/li&gt;
&lt;li&gt;指令编码必须有唯一的解释，否则是不合法的指令&lt;/li&gt;
&lt;li&gt;指令字长应是&lt;strong&gt;字节的整数倍&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;合理地选择地址字段的个数&lt;/li&gt;
&lt;li&gt;指令尽量规整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一条指令必须&lt;strong&gt;明显或隐含&lt;/strong&gt;包含以下信息：
&lt;ul&gt;
&lt;li&gt;操作码：指定操作类型&lt;/li&gt;
&lt;li&gt;源操作数或其地址：一个或多个源操作数所在的地址&lt;/li&gt;
&lt;li&gt;结果的地址：产生的结果存放何处（目的操作数）&lt;/li&gt;
&lt;li&gt;下一条指令地址：下条指令存放何处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令的寻址方式&amp;mdash;-简单
&lt;ul&gt;
&lt;li&gt;顺序执行：PC增值&lt;/li&gt;
&lt;li&gt;跳转 （ jump / branch / call / return ）：同操作数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作数的寻址方式&amp;mdash;-复杂
&lt;ul&gt;
&lt;li&gt;操作数来源：寄存器 / 主（虚）存 /外设端口 /  栈顶&lt;/li&gt;
&lt;li&gt;操作数结构：位 / 字节 / 半字 / 字 / 双字 / 一维表 / 二维表 /…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常寻址方式特指“操作数的寻址”&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;扩展操作码&#34;&gt;扩展操作码
&lt;/h4&gt;&lt;p&gt;格式：定长指令字结构 + 可边长操作码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即不同地址数的指令使用不同的操作码，便于判断&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通常情况下，对使用频率较高的指令，分配较短的操作码；对使用
频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和
分析的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011090538497.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011090538497&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设地址长度为n，上一层留出m种状态，下一层可扩展出mx2^n种状态&lt;/p&gt;
&lt;p&gt;注意短的操作码不能是长操作码的前缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;寻址方式&#34;&gt;寻址方式
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;PC：程序计数器，取址后会自动加一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;指令寻址&#34;&gt;指令寻址
&lt;/h4&gt;&lt;p&gt;确定下一条指令的存放地址，由 PC 指明&lt;/p&gt;
&lt;p&gt;顺序寻址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC + ”1“
&lt;ul&gt;
&lt;li&gt;1 理解为一个指令字长，根据指令字长变化字节编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳跃寻址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行转移指令导致 PC 值改变（直接修改）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据寻址&#34;&gt;数据寻址
&lt;/h4&gt;&lt;p&gt;确定本条指令的地址码指明的&lt;strong&gt;真实地址&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序存储位置是相对的，需要用偏移量解读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在地址码中划分出&lt;strong&gt;寻址特征&lt;/strong&gt;，规定该地址需要用何种方式寻址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接寻址：存储 = 真实，即 EA = A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间接寻址：存储的是真实值的地址，即 EA = （A）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器寻址：指令字中直接给出操作数所在寄存器编号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器间接寻址：寄存器存储的是操作数所在储存单元的地址，即 EA = （R）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐含寻址：非显示给出的操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;立即寻址：地址就是操作数本身，又称立即数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基址寻址：以程序的起始存放地址作为起点，EA = （BR）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;BR 为基址寄存器，由操作系统决定，不可更改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;变址寻址：程序员自己决定从哪里作为起点，EA = （IX）+ A&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;IX 为变址寄存器，可由用户决定。类似一个指针，设置为数组首地址等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;p&gt;相对寻址：程序计数器PC所指地址作为起点，EA = （PC）+ A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;堆栈可以用寄存器实现（硬堆栈）或主存实现，硬堆栈不妨存，速度快&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;优缺点&#34;&gt;优缺点
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011095613851.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011095613851&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;条件测试方式&#34;&gt;条件测试方式(?)
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251011100211358.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251011100211358&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于带符号数和无符号数运算，标志生成方式有没有不同？&lt;/p&gt;
&lt;p&gt;答：没有，因为加法电路不知道是无符号数还是带符号整数！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;指令系统设计风格&#34;&gt;指令系统设计风格
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;累加器型： （earliest machines）
&lt;ul&gt;
&lt;li&gt;特点：其中一个操作数（源操作数 1）和目的操作数总在累加器中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆栈型： （e.g. HP calculator, Java virtual machines)
&lt;ul&gt;
&lt;li&gt;特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通用寄存器型： （e.g. IA-32, Motorola 68xxx)
&lt;ul&gt;
&lt;li&gt;特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;装入/存储型： （e.g. SPARC, MIPS, PowerPC)
&lt;ul&gt;
&lt;li&gt;特点：运算指令的操作数只能是寄存器数据，只有 load/store 能访问存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令集cisc-和-risc&#34;&gt;指令集：CISC 和 RISC
&lt;/h3&gt;&lt;p&gt;CISC（Complex Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条指令完成一个复杂的基本功能。&lt;/li&gt;
&lt;li&gt;x86 架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC（Reduced Instruction Set Computer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路简单，功耗小，寄存器多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有 LOAD、STORE 指令可以访存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARM 架构，主要用于手机、平板&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%。而且在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013194838713.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013194838713&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;mips-的指令格式&#34;&gt;MIPS 的指令格式
&lt;/h3&gt;&lt;p&gt;所有指令都是32位宽（字长），按字地址对齐存储，字地址为4的倍数&lt;/p&gt;
&lt;p&gt;分为 R、I、J 型&lt;/p&gt;
&lt;h4 id=&#34;r-型&#34;&gt;R 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195437859.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195437859&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与运算的操作数和结果都在寄存器，R 型指令的寻址方式&lt;strong&gt;只有寄存器寻址&lt;/strong&gt;一种；&lt;/li&gt;
&lt;li&gt;R 型指令&lt;strong&gt;的 op 全为 0&lt;/strong&gt;，具体功能由 func 部分确定；&lt;/li&gt;
&lt;li&gt;rs：第一个源操作数（source register）&lt;/li&gt;
&lt;li&gt;rt：第 2 个源操作数（target register）&lt;/li&gt;
&lt;li&gt;rd：目的寄存器（destination register）&lt;/li&gt;
&lt;li&gt;shamt：对非移位指令为 00000。移位指令为移位次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;i-型&#34;&gt;I 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195709806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195709806&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令中包含了一个&lt;strong&gt;立即数&lt;/strong&gt;，所以称为 I 型指令。&lt;/li&gt;
&lt;li&gt;op：确定指令的功能；&lt;/li&gt;
&lt;li&gt;rs：可以是一个源操作数，&lt;strong&gt;寄存器寻址&lt;/strong&gt;；或者在存取指令中用作基址寄存器，&lt;strong&gt;偏移寻址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;rt：目的寄存器&lt;/li&gt;
&lt;li&gt;Immediate：长度为 16 位的立即数，指令执行时需扩展为 32 位。根据指令的不同，可以有以下三种用法：
&lt;ul&gt;
&lt;li&gt;运算类指令（ori）：以立即寻址方式提供的一个源操作数。&lt;/li&gt;
&lt;li&gt;存取指令（lw/sw）：作为偏移量，与寄存器 rs 组成偏移寻址方式，提供一个存储器操作数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件转移&lt;/strong&gt;指令（bne）：作为偏移量，与 PC 寄存器组成&lt;strong&gt;相对寻址&lt;/strong&gt;方式，提供一个转移目的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;j-型&#34;&gt;J 型
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195925675.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013195925675&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;op：确定指令的功能&lt;/li&gt;
&lt;li&gt;address：转移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;整合&#34;&gt;整合
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三种指令     &lt;strong&gt;汇编格式   a=b op c   把=和op变成逗号&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;R型指令格式是op+rs+rt+rd+shamt+func   汇编格式是  xxx $rs, $rt, $rd&lt;/li&gt;
&lt;li&gt;I型指令格式是op+rs+rt+imm   汇编格式是  xxx $rt, $rs, imm&lt;/li&gt;
&lt;li&gt;J型指令格式是op+addr   汇编格式是  xxx addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200210127.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200210127&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200238754.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200238754&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200751544.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013200751544&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mips-的通用寄存器&#34;&gt;MIPS 的通用寄存器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;0 号寄存器$zero 为固定值零，不能改变&lt;/li&gt;
&lt;li&gt;MIPS还提供了32个32位的单精度浮点寄存器$f0∽$f31,用于浮点数指令。它们可配对成16个64位的双精度浮点寄存器。&lt;/li&gt;
&lt;li&gt;在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上“$”,例如，$8或$t0。&lt;/li&gt;
&lt;li&gt;寄存器
&lt;ul&gt;
&lt;li&gt;长度：32 位&lt;/li&gt;
&lt;li&gt;个数：32 个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mips-的寻址方式&#34;&gt;MIPS 的寻址方式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;寄存器寻址
&lt;ul&gt;
&lt;li&gt;可以出现在 R 型和 I 型格式中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202438436.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202438436&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即数寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202455236.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202455236&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏移寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202517572.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202517572&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC 相对寻址&lt;/li&gt;
&lt;li&gt;PC&amp;lt;&amp;ndash; PC+4+imm*4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202535509.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202535509&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪直接寻址
&lt;ul&gt;
&lt;li&gt;为什么称伪直接？&lt;/li&gt;
&lt;li&gt;最终地址：PC 高四位+addr+两个 0，+表示拼接&lt;/li&gt;
&lt;li&gt;位数：4+26+2=32&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202548351.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013202548351&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;机器语言的解码反汇编&#34;&gt;机器语言的解码（反汇编）？
&lt;/h3&gt;&lt;h3 id=&#34;高级语言汇编语言机器语言之间的转换-&#34;&gt;高级语言、汇编语言、机器语言之间的转换 ？
&lt;/h3&gt;&lt;h3 id=&#34;risc-v-指令系统&#34;&gt;RISC-V 指令系统
&lt;/h3&gt;&lt;p&gt;具有模块化结构，稳定性和可扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等各方面具有显著优势。&lt;/p&gt;
&lt;p&gt;模块化结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心：RV32I + 标准扩展集：RV32M、RV32F、RV32D、RV32A = RV32G&lt;/li&gt;
&lt;li&gt;32位架构RV32G = RV32IMAFD，其压缩指令集RV32C（指令长度16位）&lt;/li&gt;
&lt;li&gt;64位架构RV64G = RV64IMAFD，其压缩指令集RV64C（指令长度16位）&lt;/li&gt;
&lt;li&gt;向量计算RV32V和RV64V；嵌入式RV32E（RV32I的子集，16个通用寄存器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;指令格式-1&#34;&gt;指令格式
&lt;/h4&gt;&lt;h5 id=&#34;32位&#34;&gt;32位
&lt;/h5&gt;&lt;p&gt;R-型为寄存器操作数指令&lt;/p&gt;
&lt;p&gt;I-型为短立即数或装入（Load）指令&lt;/p&gt;
&lt;p&gt;S-型为存储（Store）指令&lt;/p&gt;
&lt;p&gt;B-型为条件跳转指令&lt;/p&gt;
&lt;p&gt;U-型为长立即数操作指令&lt;/p&gt;
&lt;p&gt;J-型为无条件跳转指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204153653.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204153653&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;16位压缩&#34;&gt;16位压缩
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204333864.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251013204333864&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第五章-中央处理器&#34;&gt;第五章 中央处理器
&lt;/h2&gt;&lt;h3 id=&#34;cpu-的功能和基本结构&#34;&gt;CPU 的功能和基本结构
&lt;/h3&gt;&lt;h4 id=&#34;cpu-基本功能&#34;&gt;CPU 基本功能：
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。&lt;/li&gt;
&lt;li&gt;操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件从而控制这些部件按指令的要求进行动作。&lt;/li&gt;
&lt;li&gt;时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。&lt;/li&gt;
&lt;li&gt;数据加工。对数据进行算术和逻辑运算。&lt;/li&gt;
&lt;li&gt;中断处理。对计算机运行过程中出现的&lt;strong&gt;异常情况&lt;/strong&gt;和特殊请求进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;基本结构&#34;&gt;基本结构
&lt;/h4&gt;&lt;p&gt;数据通路 + 控制器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106220709140.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106220709140&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制器
&lt;ul&gt;
&lt;li&gt;对指令进行译码，生成指令对应的控制信号，控制数据通路的动作。它向执行部件发出控制信号，是指令的控制部件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据通路&#34;&gt;数据通路
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;由操作元件和存储元件通过总线方式或分散方式连接而成的进行数据传送、处理和存储的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令执行过程中，数据所经过的路径，以及路径上的部件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包括：ALU、通用寄存器、状态寄存器、MMU、cache、中断处理逻辑等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通路中专门进行数据运算的部件称为执行部件或功能部件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能：进行数据传送、处理和存储&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成元件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合逻辑元件（操作元件）：输出只取决于当前输入&lt;/li&gt;
&lt;li&gt;时序逻辑元件（也称状态元件，或存储元件）：在时钟控制下输入被写到电路中，直到下个时钟到达。
&lt;ul&gt;
&lt;li&gt;定时方式：规定信号何时写入状态元件（上升沿、下降沿、电平触发）&lt;/li&gt;
&lt;li&gt;存储元件：寄存器 &amp;ndash;&amp;gt; 寄存器组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总线、分散&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;时序控制（过去式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106221950243.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106221950243&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;现代时钟周期
&lt;ul&gt;
&lt;li&gt;…… + 状态元件 + 操作元件( 组合电路) + 状态元件 + ……
&lt;ul&gt;
&lt;li&gt;只有状态元件能存储信息，所有操作元件都从状态元件接收输入，并将输出写入状态元件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟周期= &lt;code&gt;Latch Prop + Longest Delay Path + Setup + Clock Skew(时钟偏移)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;约束条件：操作元件输出有效信号最快出现必须在下一级状态元件的输入保持时间之后出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单周期-mips-处理器的设计&#34;&gt;单周期 MIPS 处理器的设计
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;复习：三种指令类型 R、I、J&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223015184.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223015184&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设计处理器步骤
&lt;ol&gt;
&lt;li&gt;分析每条指令功能，并用 RTL（Register Transfer Language）来表示&lt;/li&gt;
&lt;li&gt;根据指令的功能给出所需的元件，并考虑如何将他们互连&lt;/li&gt;
&lt;li&gt;确定每个元件所需控制信号的取值&lt;/li&gt;
&lt;li&gt;汇总所有指令所涉及到的控制信号，生成一张反映指令与控制信    号之间关系的表&lt;/li&gt;
&lt;li&gt;根据表得到每个控制信号的逻辑表达式，据此设计控制器电路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设计数据通路&#34;&gt;设计数据通路
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;R-type：取指 &amp;ndash;&amp;gt; 取寄存器 &amp;ndash;&amp;gt; 运算 &amp;ndash;&amp;gt; 输出、计算下地址
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 从PC所指的内存单元中取指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rd] ← R[rs] + R[rt]&lt;/code&gt; 从rs、r所指的寄存器中取数后相加。若结果不溢出，则将结果送rd所指的寄存器中；若结果溢出，则不送结果，并转到“溢出处理程序”执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; PC加4，使PC指向下一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223528090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223528090&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I-type
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← R[rs] or ZeroExt(imm16)&lt;/code&gt; 立即数零扩展，并与rs内容做“或”运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106223721148.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106223721148&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lw 装入指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt; 计算存储单元地址 (立即数符号扩展！)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R[rt] ← M [Addr]&lt;/code&gt;装入数据到寄存器rt中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224257606.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224257606&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sw 指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Addr ← R[rs] + SignExt(imm16)&lt;/code&gt;   计算存储单元地址（符号扩展！）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M[Addr] ← R[rt]&lt;/code&gt; 寄存器rt中的内容存到内存单元中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt; 计算下地址（公共操作，取指部件完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106224756068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106224756068&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt; 取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cond ← R[rs] - R[rt]&lt;/code&gt; 做减法比较rs和rt中的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (Cond eq 0)&lt;/code&gt; 计算下地址（根据比较结果，修改PC）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4 + ( SignExt(imm16) x 4 )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC ← PC + 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225017615.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225017615&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[PC]&lt;/code&gt;	        取指令（公共操作，取指部件完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC&amp;lt;31:2&amp;gt; ← PC&amp;lt;31:28&amp;gt;&lt;/code&gt; 串接  &lt;code&gt;target&amp;lt;25:0&amp;gt;&lt;/code&gt;     计算目标地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;指令范围有多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不是相对寻址，是绝对寻址。转移范围&lt;strong&gt;只能在 j 指令所在的228=256MB页面内&lt;/strong&gt;，页面号与j指令相同 &lt;code&gt;PC&amp;lt;31:28&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225306971.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225306971&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106225341319.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106225341319&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/calendar0917/images/master/image-20251106230643068.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251106230643068&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;设计控制器&#34;&gt;设计控制器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;方法：
&lt;ol&gt;
&lt;li&gt;根据每条指令的功能，分析控制信号的取值，并列表表示。&lt;/li&gt;
&lt;li&gt;根据列出的指令和控制信号的关系，写出每个控制信号的逻辑表达式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
