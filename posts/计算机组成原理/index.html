<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="计算机组成原理课程的笔记">
<title>计算机组成原理</title>

<link rel='canonical' href='https://example.com/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="计算机组成原理">
<meta property='og:description' content="计算机组成原理课程的笔记">
<meta property='og:url' content='https://example.com/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/'>
<meta property='og:site_name' content='Calendar&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='笔记' /><meta property='article:published_time' content='2025-10-03T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-10-13T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="计算机组成原理">
<meta name="twitter:description" content="计算机组成原理课程的笔记">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/images/1_hu_b5fde55a1ef6fadd.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Calendar&#39;s Blog</a></h1>
            <h2 class="site-description">欢迎</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/calendar0917'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#707070"
     stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
     class="icon icon-tabler icons-tabler-outline icon-tabler-square-rounded-arrow-up">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M16 12l-4 -4l-4 4"/>
    <path d="M12 16v-8"/>
    <path d="M12 3c7.2 0 9 1.8 9 9s-1.8 9 -9 9s-9 -1.8 -9 -9s1.8 -9 9 -9z"/>
</svg>

                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#第一章-计算机系统概述">第一章 计算机系统概述</a>
      <ol>
        <li><a href="#计算机系统的发展">计算机系统的发展</a>
          <ol>
            <li><a href="#软件">软件</a></li>
            <li><a href="#硬件">硬件</a></li>
          </ol>
        </li>
        <li><a href="#组成">组成</a>
          <ol>
            <li><a href="#冯诺依曼结构模型">冯诺依曼结构模型</a></li>
            <li><a href="#基本部件及其功能">基本部件及其功能</a></li>
            <li><a href="#各硬件工作原理">各硬件工作原理</a></li>
            <li><a href="#配合">配合</a></li>
            <li><a href="#软件-1">软件</a></li>
          </ol>
        </li>
        <li><a href="#层次结构">层次结构</a>
          <ol>
            <li><a href="#语言层次">语言层次</a></li>
            <li><a href="#isa">ISA</a></li>
          </ol>
        </li>
        <li><a href="#性能指标">性能指标</a>
          <ol>
            <li><a href="#存储器">存储器</a></li>
            <li><a href="#cpu">CPU</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第二章-数据的机器级表示">第二章 数据的机器级表示</a>
      <ol>
        <li><a href="#信息二进制编码">信息二进制编码</a>
          <ol>
            <li><a href="#数值数据表示方法">数值数据表示方法</a></li>
            <li><a href="#定点数的表示">定点数的表示</a></li>
            <li><a href="#c语言的解析">C语言的解析</a></li>
          </ol>
        </li>
        <li><a href="#ieee编码">IEEE编码</a>
          <ol>
            <li><a href="#二进制浮点数">二进制浮点数</a></li>
            <li><a href="#float单精度">float单精度</a></li>
            <li><a href="#double双精度">double双精度</a></li>
            <li><a href="#表示范围">表示范围</a></li>
            <li><a href="#特殊状态">特殊状态</a></li>
          </ol>
        </li>
        <li><a href="#数据表示">数据表示</a>
          <ol>
            <li><a href="#十进制数表示">十进制数表示</a></li>
            <li><a href="#西文字符表示">西文字符表示：</a></li>
            <li><a href="#汉字表示">汉字表示</a></li>
          </ol>
        </li>
        <li><a href="#数据的宽度">数据的宽度</a></li>
        <li><a href="#数据的存储和排列顺序">数据的存储和排列顺序</a></li>
        <li><a href="#数据的检错与纠错">数据的检错与纠错</a></li>
      </ol>
    </li>
    <li><a href="#第三章-运算方法和运算部件">第三章 运算方法和运算部件</a>
      <ol>
        <li><a href="#加法器">加法器</a>
          <ol>
            <li><a href="#串行进位">串行进位</a></li>
            <li><a href="#并行进位">并行进位</a></li>
          </ol>
        </li>
        <li><a href="#alu的构成">ALU的构成</a></li>
        <li><a href="#定点数运算">定点数运算</a>
          <ol>
            <li><a href="#移位">移位</a></li>
            <li><a href="#加减">加减</a></li>
            <li><a href="#乘法">乘法</a></li>
          </ol>
        </li>
        <li><a href="#浮点数运算">浮点数运算</a></li>
      </ol>
    </li>
    <li><a href="#第四章">第四章</a>
      <ol>
        <li><a href="#指令格式">指令格式</a>
          <ol>
            <li><a href="#根据地址码数不同">根据地址码数不同</a></li>
            <li><a href="#按指令长度分类">按指令长度分类</a></li>
            <li><a href="#按操作码长度分类">按操作码长度分类</a></li>
            <li><a href="#按操作类型分类">按操作类型分类</a></li>
            <li><a href="#设计">设计</a></li>
            <li><a href="#扩展操作码">扩展操作码</a></li>
          </ol>
        </li>
        <li><a href="#寻址方式">寻址方式</a>
          <ol>
            <li><a href="#指令寻址">指令寻址</a></li>
            <li><a href="#数据寻址">数据寻址</a></li>
          </ol>
        </li>
        <li><a href="#条件测试方式">条件测试方式(?)</a></li>
        <li><a href="#指令系统设计风格">指令系统设计风格</a></li>
        <li><a href="#指令集cisc-和-risc">指令集：CISC 和 RISC</a></li>
        <li><a href="#mips-的指令格式">MIPS 的指令格式</a>
          <ol>
            <li><a href="#r-型">R 型</a></li>
            <li><a href="#i-型">I 型</a></li>
            <li><a href="#j-型">J 型</a></li>
            <li><a href="#整合">整合</a></li>
          </ol>
        </li>
        <li><a href="#mips-的通用寄存器">MIPS 的通用寄存器</a>
          <ol>
            <li><a href="#mips-的寻址方式">MIPS 的寻址方式</a></li>
          </ol>
        </li>
        <li><a href="#机器语言的解码反汇编">机器语言的解码（反汇编）？</a></li>
        <li><a href="#高级语言汇编语言机器语言之间的转换-">高级语言、汇编语言、机器语言之间的转换 ？</a></li>
        <li><a href="#risc-v-指令系统">RISC-V 指令系统</a>
          <ol>
            <li><a href="#指令格式-1">指令格式</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AC%94%E8%AE%B0/" style="background-color: #80aba9; color: #fff;">
                课内笔记
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            计算机组成原理课程的笔记
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 03, 2025</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="第一章-计算机系统概述">第一章 计算机系统概述
</h2><h3 id="计算机系统的发展">计算机系统的发展
</h3><p>计算机系统 = 硬件 + 软件</p>
<h4 id="软件">软件
</h4><p>系统软件：用来管理整个计算机系统</p>
<p>应用软件：按任务需要编制成的程序</p>
<h4 id="硬件">硬件
</h4><p>第一台电子数字计算机：<strong>ENIAC</strong></p>
<ul>
<li>
<p>逻辑元件（用于处理电信号的最小单元）：电子管</p>
</li>
<li>
<p>十进制表示，手动编程</p>
</li>
<li>
<p>无冯 · 诺伊曼结构</p>
</li>
</ul>
<p>第二代：晶体管</p>
<ul>
<li>元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带）</li>
<li>特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。</li>
<li>软件：使用高级语言，提供系统软件。</li>
</ul>
<p>第三代：中小规模集成电路</p>
<ul>
<li>元器件：逻辑元件和主存储器均由<strong>集成电路</strong>实现。</li>
<li>特点：微程序控制，Cache，虚拟存储器，流水线。</li>
<li>代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。</li>
</ul>
<blockquote>
<p>IBM 360（<strong>兼容机</strong>）</p>
<p>相同/相似的指令集&amp;操作系统。</p>
<p>好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。</p>
<p>保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。</p></blockquote>
<blockquote>
<p>DEC PDP-8（<strong>采用总线结构</strong>）</p>
<p>总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜</p></blockquote>
<p>第四代：大规模、超大规模集成电路</p>
<ul>
<li>半导体存储器，微处理器发展迅速。</li>
<li>特点：共享存储器，分布式存储器以及大规模并行系统。</li>
</ul>
<h3 id="组成">组成
</h3><h4 id="冯诺依曼结构模型">冯诺依曼结构模型
</h4><p>冯诺依曼提出<strong>存储程序</strong>，取代手动接线。</p>
<blockquote>
<p>冯诺依曼结构：</p>
<ol>
<li>计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。</li>
<li>各基本部件功能：
<ol>
<li>存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；</li>
<li>控制器应能自动执行指令；</li>
<li>运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；</li>
<li>操作人员可以通过输入设备和输出设备与主机进行通信。</li>
</ol>
</li>
<li>内部以<strong>二进制数</strong>表述指令和数据
<ol>
<li>每条指令由<strong>操作码</strong>和<strong>地址码</strong>两部分组成。操作码指出操作的类型，地址码指出操作数的地址。</li>
<li>由一串指令组成程序。</li>
</ol>
</li>
<li>采用<strong>存储程序</strong>工作方式
<ol>
<li>将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。</li>
</ol>
</li>
</ol></blockquote>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/20251003090538614.png"
	
	
	
	loading="lazy"
	
	
></p>
<h4 id="基本部件及其功能">基本部件及其功能
</h4><ul>
<li>运算器（数据运算）：ALU、GPRs、标志寄存器等。</li>
<li>存储器（数据存储）：存储阵列、地址译码器、读写控制电路</li>
<li>总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线</li>
<li>控制器（控制）：对指令译码生成控制信号</li>
</ul>
<p>CPU = 运算器 + 控制器</p>
<p>主机 = CPU + 主存</p>
<h4 id="各硬件工作原理">各硬件工作原理
</h4><h5 id="主存储器">主存储器
</h5><p>主存储器 = 存储体 + MAR + MDR</p>
<ul>
<li>Memory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数</li>
<li>Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令）</li>
<li>存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址</li>
</ul>
<blockquote>
<p>1B = 1 byte ; 1 b = 1 bit</p></blockquote>
<blockquote>
<p>MAR、MDR 逻辑上属于主存，但被集成到 CPU</p></blockquote>
<h5 id="运算器">运算器
</h5><p>实现算数运算、逻辑运算</p>
<p>运算器 = ACC + ALU + MQ + X</p>
<ul>
<li>Accumulator：累加器，存放操作数或运算结果</li>
<li>Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果</li>
<li>Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算</li>
<li>X：通用的操作数寄存器，用于存放操作数</li>
</ul>
<h5 id="控制器">控制器
</h5><p>控制器 = CU + IR +PC</p>
<ul>
<li>
<p>Control Unit:控制单元，分析指令，给出控制信号</p>
</li>
<li>
<p>Instruction Register:指令寄存器，存放当前执行的指令</p>
</li>
<li>
<p>Program Counter:程序计数器，存放下一条指令地址，有自动加1功能</p>
</li>
</ul>
<h4 id="配合">配合
</h4><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003094316150.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003094316150"
	
	
></p>
<h5 id="指令和数据">指令和数据
</h5><ul>
<li>程序启动前，指令和数据都存储在存储器中，<strong>形式上没有区别</strong>，都是 0/1 序列。</li>
<li>采用<strong>存储程序</strong>的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。</li>
<li>指令执行过程中，指令和数据从存储器取到 CPU，<strong>指令存在 IR 中，数据在 GPR 中</strong>。</li>
<li>指令需要给出的信息
<ul>
<li><strong>操作码</strong>：指令的操作，加减法等</li>
<li>一个或多个<strong>源操作数</strong>：立即数、寄存器编号、存储地址</li>
<li><strong>目的操作数地址</strong>：寄存器编号、存储地址</li>
</ul>
</li>
</ul>
<h5 id="执行过程">执行过程
</h5><ul>
<li>程序执行前
<ul>
<li>数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。</li>
</ul>
</li>
<li>开始执行程序
<ul>
<li>根据 PC <strong>取指</strong>令送 IR：PC -&gt; MAR -&gt;存储器 -&gt; MDR -&gt; IR</li>
<li>指令<strong>译码</strong>：IR -&gt; 控制器，控制器译码</li>
<li><strong>取操作数</strong>：GPRs 或存储器 -&gt; ALU</li>
<li>执行指令操作：ALU <strong>运算</strong></li>
<li><strong>回写</strong>结果到 GPRs 或存储器</li>
<li>修改 <strong>PC</strong> 的值，使其指向<strong>下一条指令</strong></li>
<li>重复上述步骤直到程序完成</li>
</ul>
</li>
</ul>
<h4 id="软件-1">软件
</h4><ul>
<li>系统软件——简化编程，<strong>使硬件资源被有效利用</strong>
<ul>
<li>操作系统：硬件资源管理，用户接口</li>
<li>语言处理程序：翻译程序，Linker，Debug&hellip;
<ul>
<li>翻译程序
<ul>
<li>汇编器（Assembler）：汇编语言源程序-&gt;机器目标程序。或许叫汇编器更好理解？</li>
<li>编译器（Complier）：高级语言程序-&gt;汇编/机器目标程序。或许叫编译器更好理解？</li>
<li>解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段）</li>
</ul>
</li>
</ul>
</li>
<li>其他实用程序：磁盘碎片整理、备份程序&hellip;</li>
</ul>
</li>
</ul>
<blockquote>
<p>机器语言：二进制代码</p>
<p>汇编语言：助记符</p>
<p>高级语言：C、C++、……</p></blockquote>
<ul>
<li>应用软件——解决<strong>具体的应用</strong>问题</li>
</ul>
<h3 id="层次结构">层次结构
</h3><h4 id="语言层次">语言层次
</h4><ul>
<li>微指令系统：直接控制硬件执行</li>
<li>机器语言：传统机器M1，执行二进制机器指令</li>
</ul>
<hr>
<ul>
<li>
<p>操作系统机器</p>
</li>
<li>
<p>汇编语言：虚拟机器M2，用汇编语言翻译成机器语言</p>
</li>
<li>
<p>高级语言：虚拟机器M3，需要编译成汇编、机器语言</p>
</li>
</ul>
<p>上两层视为硬件层</p>
<p>计算机体系结构：讨论如何设计硬件与软件之间的接口</p>
<p>计算机组成原理：讨论如何用硬件实现接口</p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003100912264.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003100912264"
	
	
></p>
<h4 id="isa">ISA
</h4><p>指令集体系结构，其作为<strong>规约</strong>，规定了<strong>如何使用硬件</strong>。</p>
<ul>
<li>可执行的指令集合，包括<strong>指令格式</strong>、<strong>操作种类</strong>以及对应<strong>操作数</strong>的规定。</li>
<li>可以接受的<strong>操作数类型</strong>。</li>
<li>操作数存放的<strong>寄存器组结构</strong>，例如寄存器名称、编号、长度和用途。</li>
<li>操作数存放的存储空间的<strong>大小和编址方式</strong>。</li>
<li>操作数在存储空间中按<strong>大/小端</strong>方式存放。</li>
<li>指令获得操作数的方式，即<strong>寻址方式</strong>。</li>
<li>指令执行过程的<strong>控制方式</strong>，例如程序计数器，条件码定义等。</li>
</ul>
<p>ISA 是计算机系统中<strong>必不可少的抽象层</strong>。</p>
<h3 id="性能指标">性能指标
</h3><h4 id="存储器">存储器
</h4><p>总容量 = 存储单元个数 * 存储字长(bit)</p>
<h4 id="cpu">CPU
</h4><h5 id="基本概念">基本概念
</h5><ul>
<li>
<p>主频：CPU内数字脉冲信号振荡的频率</p>
</li>
<li>
<ul>
<li>= 1 / 时钟周期</li>
</ul>
</li>
<li>
<p>CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同）</p>
</li>
<li>
<p>CPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频</p>
</li>
<li>
<p>IPS：每秒执行多少个命令 = 主频 / 平均CPI</p>
</li>
<li>
<p>FLOPS：每秒执行多少次浮点运算</p>
</li>
</ul>
<blockquote>
<p>K=Kilo=千=10^3</p>
<p>M=Million=百万=10^6</p>
<p>G=Giga=十亿=10^9</p>
<p>T=Tera=万亿=10^12</p></blockquote>
<ul>
<li>
<p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p>
</li>
<li>
<p>吞吐量：单位时间内处理请求的数量</p>
</li>
<li>
<p>相应时间：CPU时间 + 等待时间</p>
</li>
<li>
<p>基准程序：用于测量的程序</p>
</li>
</ul>
<blockquote>
<p>MIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于<strong>单条指令</strong>。</p>
<p>MIPS 为平均值，其并没有考虑以上三个属性，并且由于：</p>
<ul>
<li>不同机器指令集不同</li>
<li>程序由不同指令混合而成</li>
<li>指令的频率会动态变换</li>
<li>厂家给出峰值 MIPS</li>
</ul>
<p>因此，MIPS 表示性能存在局限性。</p>
<p>MFLOPS：每秒执行浮点运算多少百万次，着重在于<strong>浮点操作</strong>本身。</p></blockquote>
<h5 id="计算">计算
</h5><p>CPU 执行时间=CPI×程序总指令条数×时钟周期</p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003103925476.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003103925476"
	
	
></p>
<h2 id="第二章-数据的机器级表示">第二章 数据的机器级表示
</h2><h3 id="信息二进制编码">信息二进制编码
</h3><p>计算机内部数据：二进制表示</p>
<p>机器级数据：</p>
<ol>
<li>数值数据，无符号/带符号整数，浮点数，十进制数</li>
<li>非数值数据，逻辑数，汉字</li>
</ol>
<p>二进制编码原因：</p>
<ol>
<li>制造两个稳态的物理器件容易</li>
<li>二进制编码、计数、运算规则简单。</li>
<li>与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。</li>
</ol>
<p>机器数：0/1 编码的 0/1 内部 0/1 序列。</p>
<p>真值：机器数真正的值</p>
<h4 id="数值数据表示方法">数值数据表示方法
</h4><p>三要素：</p>
<ul>
<li>进位计数制：十进制，二进制等转换。</li>
<li>定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示）</li>
<li>编码：原码补码反码等。</li>
</ul>
<p>若不知道三要素，那么便无法得知机器数的具体真值。</p>
<blockquote>
<p>进制转换：</p>
<ul>
<li>二进制 -&gt; 其他：划分位数，对应</li>
<li>十六、八 -&gt; 二：位数对应，补全</li>
<li>十进制 -&gt; 任意位数：求商取余</li>
</ul></blockquote>
<h4 id="定点数的表示">定点数的表示
</h4><p>常规计数，小数点位置固定。整数、小数分开存储。</p>
<ul>
<li>
<p>无符号数：没有符号位</p>
</li>
<li>
<p>原码：</p>
<ul>
<li>有 +0、-0 两种表示形式</li>
</ul>
</li>
<li>
<p>反码：</p>
<ul>
<li>正数与原码相同</li>
<li>若符号位为1，则数值位全部取反</li>
<li>依然有 +0、-0</li>
</ul>
</li>
<li>
<p>补码：</p>
<ul>
<li>将减法抓换为等价的加法（加上补数）</li>
<li>= 原码除符号位外，取反后加一（即反码 + 1）</li>
</ul>
</li>
<li>
<p>移码： <strong>将每一个数值加上一个偏置常数（ bias）</strong></p>
<ul>
<li>
<p>一般来说，当编码位数为 n **时，bias 取 2^n 标准移码</p>
</li>
<li>
<p>为什么要用移码来表示阶码？</p>
</li>
<li>
<p>便于浮点数加减运算时的对阶操作（比较大小）</p>
</li>
<li>
<p>与补码的关系：<strong>最高位相反，其余位相同</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="c语言的解析">C语言的解析
</h4><p>无符号数变为有符号：不改变数据内容，改变解释方式</p>
<p>长变短：高位截断，保留地位</p>
<p>短变长：符号扩展</p>
<ul>
<li>负数补1，正数补0</li>
</ul>
<h3 id="ieee编码">IEEE编码
</h3><p>规定了二进制浮点数算数标准，类似科学计数法简化计数</p>
<h4 id="二进制浮点数">二进制浮点数
</h4><ul>
<li>
<p>符号：决定数值的正负性</p>
</li>
<li>
<p>尾数：影响数值的精度。尾数的位数越多，精度越高</p>
</li>
<li>
<p>阶码：反映小数点的实际位置</p>
</li>
<li>
<p>基数：K进制通常默认基数为K</p>
</li>
<li>
<p>规格化：石确保尾数的最高位非0数位刚好在小数点之前</p>
</li>
</ul>
<p>float型：32位单精度</p>
<ul>
<li>符号 + 阶码 + 尾数：1 + 8 + 23</li>
</ul>
<p>double型：64位双精度</p>
<ul>
<li>符号 + 阶码 + 尾数：1 + 11 + 52</li>
</ul>
<h4 id="float单精度">float单精度
</h4><ul>
<li>
<p>默认存储规格化尾数，小数点前的1省略（隐含）</p>
</li>
<li>
<p>基数规定为 2</p>
</li>
<li>
<p>阶码用移码表示，规定偏置值为 127</p>
</li>
</ul>
<blockquote>
<p>如何将十进制真值转换为偏置值为M的移码？</p>
<ol>
<li>
<p>将十进制真值+偏置值</p>
</li>
<li>
<p>按“无符号整数”规则转换为指定位数</p>
</li>
</ol></blockquote>
<h4 id="double双精度">double双精度
</h4><ul>
<li>偏置值为1023</li>
</ul>
<h4 id="表示范围">表示范围
</h4><h4 id="特殊状态">特殊状态
</h4><p>阶码全 0，或阶码全 1</p>
<ul>
<li>阶码真值的取值范围为 -126 ~ 127（单精度）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003161255970.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003161255970"
	
	
></p>
<p>根据数轴，存在：</p>
<ul>
<li>正上溢、正下溢、负上溢，负下移</li>
<li>上溢置为无穷，下溢置为0</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003160611584.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003160611584"
	
	
></p>
<h3 id="数据表示">数据表示
</h3><h4 id="十进制数表示">十进制数表示
</h4><ul>
<li>
<p>ASCII 码：就是把数字当作字符存储，<strong>0-9用30H-39H表示</strong></p>
<ul>
<li>前分隔：<strong>正号用 2B  负号用 2D</strong>  放在最前面</li>
<li>后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。
<ul>
<li>正数不变；负数高 4 位变为 0111。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BCD 码</p>
<ul>
<li>每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。</li>
</ul>
</li>
</ul>
<h4 id="西文字符表示">西文字符表示：
</h4><p>复习要点中未提到</p>
<ul>
<li>十进制数字：0/1/2…/9             10 个</li>
<li>英文字母：A/B/…/Z/a/b/…/z    52 个</li>
<li>专用符号：+/-/%/*/&amp;/……        33 个</li>
<li>控制字符（不可打印或显示）  33 个</li>
</ul>
<h4 id="汉字表示">汉字表示
</h4><ol>
<li>输入码：用于输入汉字。</li>
<li>内码：用于在系统中进行存储、查找、传送等处理</li>
<li>字模点阵或轮廓描述：用于显示/打印</li>
</ol>
<h3 id="数据的宽度">数据的宽度
</h3><ul>
<li>bit</li>
<li>字节：
<ul>
<li>现代计算机中，存储器按字节编址</li>
<li>字节是最小可寻址单位 （addressable unit ）</li>
<li>LSB 表示最低有效字节，MSB 表示最高有效字节</li>
</ul>
</li>
<li>字
<ul>
<li>表示被处理信息的单位，用来度量数据类型的宽度</li>
</ul>
</li>
<li>字长
<ul>
<li>指某特定机器定点运算时数据通路的宽度。</li>
<li>数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。</li>
<li>等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。</li>
</ul>
</li>
</ul>
<h3 id="数据的存储和排列顺序">数据的存储和排列顺序
</h3><ul>
<li>大小端
<ul>
<li>小端（ <strong>Little Endian</strong>）:低字节放低地址</li>
<li>大端（ <strong>Big Endian</strong>）:高字节放低地址</li>
<li>指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序</li>
</ul>
</li>
<li>对齐：要求数据存放的地址必须是相应的边界地址
<ul>
<li>每次访存只能读写一个字</li>
<li>浪费一定空间，换取存取时间</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003164347928.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003164347928"
	
	
></p>
<h3 id="数据的检错与纠错">数据的检错与纠错
</h3><p>大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。</p>
<ul>
<li>奇偶校验码</li>
<li>海明校验码</li>
<li>循环冗余校验码</li>
</ul>
<h2 id="第三章-运算方法和运算部件">第三章 运算方法和运算部件
</h2><h3 id="加法器">加法器
</h3><h4 id="串行进位">串行进位
</h4><p>传递速度慢</p>
<h4 id="并行进位">并行进位
</h4><ul>
<li>
<p>用先行进位优化，各进位之间无等待，相互独立并同时产生</p>
</li>
<li>
<p>但全先行电路复杂，成本高</p>
</li>
<li>
<p>局部先行进位加法器： <strong>组内并行、组间串行</strong></p>
<ul>
<li>用多个位数较少的 n 位全先行进位加法器进行串联</li>
</ul>
</li>
<li>
<p>多级先行进位加法器： <strong>组内并行、组间并行</strong></p>
</li>
</ul>
<h3 id="alu的构成">ALU的构成
</h3><ol>
<li>ALU 如何控制实现加、减、与、或等等各种功能；
<ol>
<li>无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。</li>
<li>在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。</li>
</ol>
</li>
<li>ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。
<ol>
<li><strong>零标志 ZF、<strong><strong>溢出标志 OF</strong></strong>、<strong><strong>进/借位标志 CF</strong></strong>、符号标志 SF</strong> 称为<strong>条件标志。</strong></li>
<li>条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中</li>
<li>存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003180007637.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003180007637"
	
	
></p>
<p>溢出条件：</p>
<ul>
<li>无符号加、减溢出条件：CF=1</li>
<li>带符号加、减溢出条件：OF=1</li>
</ul>
<h3 id="定点数运算">定点数运算
</h3><h4 id="移位">移位
</h4><p>逻辑移位</p>
<ul>
<li>
<p>针对无符号数</p>
</li>
<li>
<p>左移 n 位，即乘上位权的 n 次方。</p>
</li>
<li>
<p>高位溢出丢弃，低位补 0</p>
</li>
</ul>
<p>算数移位</p>
<ul>
<li>左移与逻辑移位类似，但移到符号位结果更改</li>
<li>右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失</li>
</ul>
<h4 id="加减">加减
</h4><p>原码</p>
<ul>
<li>减法用减法器实现，1 变 0</li>
</ul>
<p>补码</p>
<ul>
<li>符号位可以一起参与运算</li>
<li>[A+B]补=[A]补+ [B]补</li>
<li>[A-B]补=[A]补+[-B]补</li>
</ul>
<blockquote>
<p>[-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反</p></blockquote>
<ul>
<li>溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可</li>
</ul>
<h4 id="乘法">乘法
</h4><h5 id="无符号整数">无符号整数：
</h5><ul>
<li>模拟手算乘法即可，计算机还需拆分部分积</li>
</ul>
<p>具体实现：</p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251003165328818.png"
	
	
	
	loading="lazy"
	
		alt="image-20251003165328818"
	
	
></p>
<h5 id="带符号整数">带符号整数
</h5><p>给无符号整数乘法电路添加一辅助位，让符号位参与运算。</p>
<p>计算机底层判断溢出：</p>
<ul>
<li>若 2n 位的高 n + 1 位不均相同，则溢出</li>
</ul>
<h5 id="实现方式">实现方式
</h5><ul>
<li>ALU + 移位器 + 寄存器 + 控制逻辑</li>
<li>阵列乘法器</li>
<li>逻辑运算模拟</li>
</ul>
<h3 id="浮点数运算">浮点数运算
</h3><ol>
<li>
<p>浮点数加减运算的对阶原则和方法；</p>
<ul>
<li>
<p>原则：小阶向大阶看齐</p>
</li>
<li>
<p>方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值</p>
</li>
<li>
<p>IEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上</p>
</li>
</ul>
</li>
<li>
<p>如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）；</p>
<ul>
<li>
<p>阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8）</p>
</li>
<li>
<p>阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8）</p>
</li>
</ul>
</li>
<li>
<p>如何计算一个移码数减 1</p>
</li>
<li>
<p>尾数规格化中的右规和左规方法；</p>
<ol>
<li>当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1
<ul>
<li>每次阶码减 1 后要判断阶码是否下溢</li>
<li>先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。</li>
</ul>
</li>
<li>当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1
<ul>
<li>每次阶码加 1 后要判断阶码是否上溢</li>
<li>先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。</li>
</ul>
</li>
<li>阶码溢出异常处理：
<ul>
<li>阶码上溢，则结果溢出；</li>
<li>阶码下溢，则结果为 0</li>
</ul>
</li>
<li><strong>乘法运算结果不需左规！最多右规 1 次！</strong></li>
<li><strong>除法最多左规 1 次！不需右规！</strong></li>
</ol>
</li>
<li>
<p>尾数的舍入处理常用方法；</p>
<ol>
<li>就近舍入：舍入为最近可表示的数
<ul>
<li>若为非中间值：LSB 后 1 位 0 舍 1 入</li>
<li>若为中间值：强迫结果为偶数， LSB=
<ul>
<li>1.1101110 → 1.1110       (1.1101110 → 1.1110,  110&gt;100, 1.1101+0.0001 = 1.1110)</li>
<li>1.1101011 → 1.1101       (1.1101011 → 1.1101,  011&lt;100, 1.1101+    0     = 1.1101)</li>
<li>1.1101101 → 1.1110</li>
<li>1.1111100 → 10.0000     (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000)</li>
</ul>
</li>
</ul>
</li>
<li>朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入）
<ul>
<li>例：-1.1101101 →-1.1101 ；  1.1101101 →1.1110</li>
</ul>
</li>
<li>朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入）
<ul>
<li>例：-1.1101101 →-1.1110 ；  1.1101101 →1.1101</li>
</ul>
</li>
<li>朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单</li>
</ol>
</li>
<li>
<p>如何判断结果溢出（上溢和下溢）。</p>
</li>
</ol>
<h2 id="第四章">第四章
</h2><h3 id="指令格式">指令格式
</h3><p>指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</p>
<h4 id="根据地址码数不同">根据地址码数不同
</h4><ul>
<li>零地址指令：
<ul>
<li>不需要操作数，如停机、关中断等</li>
<li>堆栈计算机，操作数隐藏在栈顶</li>
</ul>
</li>
<li>一地址指令：
<ul>
<li>只需单操作数，如加一、取反</li>
<li>需两个操作数，但其中一个存储在某个寄存器内</li>
</ul>
</li>
<li>二地址指令：
<ul>
<li>用于需要两个操作数的算术运算</li>
</ul>
</li>
<li>三地址指令：
<ul>
<li>多一个地址存储结果</li>
</ul>
</li>
<li>四地址指令：
<ul>
<li>再多一个地址存储下一个指令地址</li>
</ul>
</li>
</ul>
<p>指令位数不变时，地址码数越多，寻址能力越差</p>
<h4 id="按指令长度分类">按指令长度分类
</h4><p>指令字长：一条指令的总长度(可能会变)</p>
<blockquote>
<p>影响取指令所需时间</p></blockquote>
<p>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)</p>
<p>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)</p>
<h4 id="按操作码长度分类">按操作码长度分类
</h4><p>定长：译码电路设计简单，但复杂性低</p>
<h4 id="按操作类型分类">按操作类型分类
</h4><ol>
<li>
<p>数据传送</p>
<ul>
<li>
<p>LOAD：把存储器中的数据放到寄存器中</p>
</li>
<li>
<p>STORE： 把寄存器中的数据放到存储器中</p>
</li>
</ul>
</li>
<li>
<p>算数逻辑操作</p>
<ul>
<li>算数、逻辑（与或非、位操作）</li>
</ul>
</li>
<li>
<p>移位操作</p>
<ul>
<li>算数、逻辑、循环移位</li>
</ul>
</li>
<li>
<p>转移操作（改变程序执行流，PC指针改变）</p>
<ul>
<li>
<p>无条件转移 JMP</p>
</li>
<li>
<p>条件转移JZ：结果为0；JO：结果溢出；JC：结果有进位</p>
</li>
<li>
<p>调用和返回 CALL和RETURN</p>
</li>
<li>
<p>陷阱(Trap)与陷阱指令</p>
</li>
</ul>
</li>
<li>
<p>输入输出操作</p>
<ul>
<li>CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)</li>
</ul>
</li>
</ol>
<h4 id="设计">设计
</h4><ul>
<li>指令格式的选择应遵循的几条基本原则
<ul>
<li>应尽量短</li>
<li>要有足够的操作码位数</li>
<li>指令编码必须有唯一的解释，否则是不合法的指令</li>
<li>指令字长应是<strong>字节的整数倍</strong></li>
<li>合理地选择地址字段的个数</li>
<li>指令尽量规整</li>
</ul>
</li>
<li>一条指令必须<strong>明显或隐含</strong>包含以下信息：
<ul>
<li>操作码：指定操作类型</li>
<li>源操作数或其地址：一个或多个源操作数所在的地址</li>
<li>结果的地址：产生的结果存放何处（目的操作数）</li>
<li>下一条指令地址：下条指令存放何处</li>
</ul>
</li>
<li>指令的寻址方式&mdash;-简单
<ul>
<li>顺序执行：PC增值</li>
<li>跳转 （ jump / branch / call / return ）：同操作数寻址</li>
</ul>
</li>
<li>操作数的寻址方式&mdash;-复杂
<ul>
<li>操作数来源：寄存器 / 主（虚）存 /外设端口 /  栈顶</li>
<li>操作数结构：位 / 字节 / 半字 / 字 / 双字 / 一维表 / 二维表 /…</li>
</ul>
</li>
<li>通常寻址方式特指“操作数的寻址”</li>
</ul>
<h4 id="扩展操作码">扩展操作码
</h4><p>格式：定长指令字结构 + 可边长操作码</p>
<ul>
<li>即不同地址数的指令使用不同的操作码，便于判断</li>
</ul>
<blockquote>
<p>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用
频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和
分析的时间。</p></blockquote>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251011090538497.png"
	
	
	
	loading="lazy"
	
		alt="image-20251011090538497"
	
	
></p>
<blockquote>
<p>设地址长度为n，上一层留出m种状态，下一层可扩展出mx2^n种状态</p>
<p>注意短的操作码不能是长操作码的前缀</p></blockquote>
<h3 id="寻址方式">寻址方式
</h3><blockquote>
<p>PC：程序计数器，取址后会自动加一</p></blockquote>
<h4 id="指令寻址">指令寻址
</h4><p>确定下一条指令的存放地址，由 PC 指明</p>
<p>顺序寻址：</p>
<ul>
<li>PC + ”1“
<ul>
<li>1 理解为一个指令字长，根据指令字长变化字节编码</li>
</ul>
</li>
</ul>
<p>跳跃寻址</p>
<ul>
<li>执行转移指令导致 PC 值改变（直接修改）</li>
</ul>
<h4 id="数据寻址">数据寻址
</h4><p>确定本条指令的地址码指明的<strong>真实地址</strong></p>
<blockquote>
<p>程序存储位置是相对的，需要用偏移量解读</p></blockquote>
<p>在地址码中划分出<strong>寻址特征</strong>，规定该地址需要用何种方式寻址</p>
<ol>
<li>
<p>直接寻址：存储 = 真实，即 EA = A</p>
</li>
<li>
<p>间接寻址：存储的是真实值的地址，即 EA = （A）</p>
</li>
<li>
<p>寄存器寻址：指令字中直接给出操作数所在寄存器编号</p>
</li>
<li>
<p>寄存器间接寻址：寄存器存储的是操作数所在储存单元的地址，即 EA = （R）</p>
</li>
<li>
<p>隐含寻址：非显示给出的操作数</p>
</li>
<li>
<p>立即寻址：地址就是操作数本身，又称立即数</p>
</li>
<li>
<p>基址寻址：以程序的起始存放地址作为起点，EA = （BR）+ A</p>
</li>
</ol>
<blockquote>
<p>BR 为基址寄存器，由操作系统决定，不可更改</p></blockquote>
<ol start="8">
<li>变址寻址：程序员自己决定从哪里作为起点，EA = （IX）+ A</li>
</ol>
<blockquote>
<p>IX 为变址寄存器，可由用户决定。类似一个指针，设置为数组首地址等</p></blockquote>
<ol start="9">
<li>
<p>相对寻址：程序计数器PC所指地址作为起点，EA = （PC）+ A</p>
</li>
<li>
<p>堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。</p>
</li>
</ol>
<blockquote>
<p>堆栈可以用寄存器实现（硬堆栈）或主存实现，硬堆栈不妨存，速度快</p></blockquote>
<h5 id="优缺点">优缺点
</h5><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251011095613851.png"
	
	
	
	loading="lazy"
	
		alt="image-20251011095613851"
	
	
></p>
<h3 id="条件测试方式">条件测试方式(?)
</h3><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251011100211358.png"
	
	
	
	loading="lazy"
	
		alt="image-20251011100211358"
	
	
></p>
<blockquote>
<p>对于带符号数和无符号数运算，标志生成方式有没有不同？</p>
<p>答：没有，因为加法电路不知道是无符号数还是带符号整数！</p></blockquote>
<h3 id="指令系统设计风格">指令系统设计风格
</h3><ul>
<li>累加器型： （earliest machines）
<ul>
<li>特点：其中一个操作数（源操作数 1）和目的操作数总在累加器中</li>
</ul>
</li>
<li>堆栈型： （e.g. HP calculator, Java virtual machines)
<ul>
<li>特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址</li>
</ul>
</li>
<li>通用寄存器型： （e.g. IA-32, Motorola 68xxx)
<ul>
<li>特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元）</li>
</ul>
</li>
<li>装入/存储型： （e.g. SPARC, MIPS, PowerPC)
<ul>
<li>特点：运算指令的操作数只能是寄存器数据，只有 load/store 能访问存储器</li>
</ul>
</li>
</ul>
<h3 id="指令集cisc-和-risc">指令集：CISC 和 RISC
</h3><p>CISC（Complex Instruction Set Computer）：</p>
<ul>
<li>一条指令完成一个复杂的基本功能。</li>
<li>x86 架构</li>
</ul>
<p>RISC（Reduced Instruction Set Computer）：</p>
<ul>
<li>
<p>一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。</p>
</li>
<li>
<p>电路简单，功耗小，寄存器多</p>
</li>
<li>
<p>只有 LOAD、STORE 指令可以访存</p>
</li>
<li>
<p>ARM 架构，主要用于手机、平板</p>
</li>
</ul>
<blockquote>
<p>在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%。而且在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%。</p></blockquote>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013194838713.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013194838713"
	
	
></p>
<h3 id="mips-的指令格式">MIPS 的指令格式
</h3><p>所有指令都是32位宽（字长），按字地址对齐存储，字地址为4的倍数</p>
<p>分为 R、I、J 型</p>
<h4 id="r-型">R 型
</h4><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195437859.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013195437859"
	
	
></p>
<ul>
<li>参与运算的操作数和结果都在寄存器，R 型指令的寻址方式<strong>只有寄存器寻址</strong>一种；</li>
<li>R 型指令<strong>的 op 全为 0</strong>，具体功能由 func 部分确定；</li>
<li>rs：第一个源操作数（source register）</li>
<li>rt：第 2 个源操作数（target register）</li>
<li>rd：目的寄存器（destination register）</li>
<li>shamt：对非移位指令为 00000。移位指令为移位次数。</li>
</ul>
<h4 id="i-型">I 型
</h4><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195709806.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013195709806"
	
	
></p>
<ul>
<li>指令中包含了一个<strong>立即数</strong>，所以称为 I 型指令。</li>
<li>op：确定指令的功能；</li>
<li>rs：可以是一个源操作数，<strong>寄存器寻址</strong>；或者在存取指令中用作基址寄存器，<strong>偏移寻址</strong>。</li>
<li>rt：目的寄存器</li>
<li>Immediate：长度为 16 位的立即数，指令执行时需扩展为 32 位。根据指令的不同，可以有以下三种用法：
<ul>
<li>运算类指令（ori）：以立即寻址方式提供的一个源操作数。</li>
<li>存取指令（lw/sw）：作为偏移量，与寄存器 rs 组成偏移寻址方式，提供一个存储器操作数。</li>
<li><strong>条件转移</strong>指令（bne）：作为偏移量，与 PC 寄存器组成<strong>相对寻址</strong>方式，提供一个转移目的地址。</li>
</ul>
</li>
</ul>
<h4 id="j-型">J 型
</h4><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013195925675.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013195925675"
	
	
></p>
<ul>
<li>op：确定指令的功能</li>
<li>address：转移地址</li>
</ul>
<h4 id="整合">整合
</h4><ul>
<li>三种指令     <strong>汇编格式   a=b op c   把=和op变成逗号</strong>
<ul>
<li>R型指令格式是op+rs+rt+rd+shamt+func   汇编格式是  xxx $rs, $rt, $rd</li>
<li>I型指令格式是op+rs+rt+imm   汇编格式是  xxx $rt, $rs, imm</li>
<li>J型指令格式是op+addr   汇编格式是  xxx addr</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200210127.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013200210127"
	
	
></p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200238754.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013200238754"
	
	
></p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013200751544.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013200751544"
	
	
></p></blockquote>
<h3 id="mips-的通用寄存器">MIPS 的通用寄存器
</h3><ul>
<li>0 号寄存器$zero 为固定值零，不能改变</li>
<li>MIPS还提供了32个32位的单精度浮点寄存器$f0∽$f31,用于浮点数指令。它们可配对成16个64位的双精度浮点寄存器。</li>
<li>在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上“$”,例如，$8或$t0。</li>
<li>寄存器
<ul>
<li>长度：32 位</li>
<li>个数：32 个</li>
</ul>
</li>
</ul>
<h4 id="mips-的寻址方式">MIPS 的寻址方式
</h4><ul>
<li>寄存器寻址
<ul>
<li>可以出现在 R 型和 I 型格式中</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202438436.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013202438436"
	
	
></p>
<ul>
<li>立即数寻址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202455236.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013202455236"
	
	
></p>
<ul>
<li>偏移寻址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202517572.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013202517572"
	
	
></p>
<ul>
<li>PC 相对寻址
<ul>
<li>PC&lt;&ndash; PC+4+imm*4</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202535509.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013202535509"
	
	
></p>
<ul>
<li>伪直接寻址
<ul>
<li>为什么称伪直接？</li>
<li>最终地址：PC 高四位+addr+两个 0，+表示拼接</li>
<li>位数：4+26+2=32</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013202548351.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013202548351"
	
	
></p>
<h3 id="机器语言的解码反汇编">机器语言的解码（反汇编）？
</h3><h3 id="高级语言汇编语言机器语言之间的转换-">高级语言、汇编语言、机器语言之间的转换 ？
</h3><h3 id="risc-v-指令系统">RISC-V 指令系统
</h3><p>具有模块化结构，稳定性和可扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等各方面具有显著优势。</p>
<p>模块化结构：</p>
<ul>
<li>核心：RV32I + 标准扩展集：RV32M、RV32F、RV32D、RV32A = RV32G</li>
<li>32位架构RV32G = RV32IMAFD，其压缩指令集RV32C（指令长度16位）</li>
<li>64位架构RV64G = RV64IMAFD，其压缩指令集RV64C（指令长度16位）</li>
<li>向量计算RV32V和RV64V；嵌入式RV32E（RV32I的子集，16个通用寄存器）</li>
</ul>
<h4 id="指令格式-1">指令格式
</h4><h5 id="32位">32位
</h5><p>R-型为寄存器操作数指令</p>
<p>I-型为短立即数或装入（Load）指令</p>
<p>S-型为存储（Store）指令</p>
<p>B-型为条件跳转指令</p>
<p>U-型为长立即数操作指令</p>
<p>J-型为无条件跳转指令</p>
<p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204153653.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013204153653"
	
	
></p>
<h5 id="16位压缩">16位压缩
</h5><p><img src="https://raw.githubusercontent.com/calendar0917/images/master/image-20251013204333864.png"
	
	
	
	loading="lazy"
	
		alt="image-20251013204333864"
	
	
></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under Calendar</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Oct 13, 2025 00:00 UTC
        </span>
    </section></footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 Calendar
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.31.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<style>
    #backTopBtn {
        display: none;
        position: fixed;
        bottom: 30px;
        z-index: 99;
        cursor: pointer;
        width: 30px;
        height: 30px;
        background-image: url(https://example.com/icons/backTop.svg);
    }
</style>

<script>
    

    function initScrollTop() {
        let rightSideBar = document.querySelector(".right-sidebar");
        if (!rightSideBar) {
            return;
        }
        
        let btn = document.createElement("div");
        btn.id = "backTopBtn";
        btn.onclick = backToTop
        rightSideBar.appendChild(btn)
        
        window.onscroll = function() {
            
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                btn.style.display = "block";
            } else {
                btn.style.display = "none";
            }
        };
    }

    

    function backToTop(){
        window.scrollTo({ top: 0, behavior: "smooth" })
    }

    initScrollTop();
</script>

    </body>
</html>
