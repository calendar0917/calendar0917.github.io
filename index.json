[{"categories":["开发"],"content":"项目介绍 从以下几个方面进行项目介绍： 项目的背景，包括：是自研还是外包，什么业务，服务的客户群是谁，谁去运营等问题。 项目的业务流程（核心的业务流程） 项目的功能模块（核心模块一定要说） 项目的技术架构 个人工作职责（说得详细一些） 个人负责模块的详细说明，包括模块设计，用到的技术，技术的实现方案等（找最熟悉的模块进行说明）。 项目基本介绍：是公司自研的专门针对成人职业技能教育的网络课堂系统，网站提供了成人职业技能培训的相关课程，如：软件开发培训。基于B2B2C的业务模式。培训机构可以在平台入驻、发布课程，我们公司作为运营方由专门的人员对发布的课程进行审核，审核通过后课程才可以发布成功，课程包括免费和收费两种形式，对于免费课程用户可以直接选课学习，对于收费课程要在选课后支付成功才可以继续学习。 本项目包括3个端：用户端、机构端、运营端。 核心模块：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。 本项目采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了Mysql，还使用了Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统（要清楚这些中间件在系统中是如何使用的，在哪里使用的）。 划分的微服务包括：内容管理服务、媒资管理服务、搜索服务、订单支付服务、学习中心服务、系统管理服务、认证授权服务、网关服务、注册中心服务、配置中心服务等。 我在这个项目中负责了内容管理、媒资管理、订单支付模块的设计与开发。 个人负责模块的详细说明：内容管理模块，是对平台上的课程进行管理。设计了课程基本信息表、课程营销表、课程计划、课程师资表。培训机构要发布一门课程需要填写课程基本信息、课程营销信息、课程计划信息、课程师资信息，填写完毕后要提交审核，由运营人员进行课程信息的审核，整个审核过程是程序自动审核加入人工确认的方式，通常24小时完成审核。课程审核通过即可发布课程，课程的相关信息会聚合到课程发布表中，这里不仅要将课程信息写到课程发布表还要将课程信息写到索引库、分布式文件系统中，所以这里存在分布式事务的问题，项目使用本地消息表加任务调度的方式去解决这里的分布式事务，保证数据的最终一致性。 ","date":"2025-10-05","objectID":"/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/:1:0","tags":["技术"],"title":"学成在线-面试","uri":"/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/"},{"categories":["开发"],"content":"技术架构 ","date":"2025-10-05","objectID":"/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/:2:0","tags":["技术"],"title":"学成在线-面试","uri":"/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/"},{"categories":["开发"],"content":"初识 分布式的开源搜索引擎 提供 Restful 接口，所有语言均可调用 ELK技术栈： 结合 kibana（可视化）、Logstash、Beats 用于日志分析、事实监控等 ","date":"2025-10-04","objectID":"/elasticsearch/:1:0","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"倒排索引 正向索引： 传统数据库使用，查询需要逐一遍历 倒排索引： document：文档，每条数据就是一个文档 term：词条，由文档按语义划分，有限且唯一 先搜词条，再根据词条找文档 ","date":"2025-10-04","objectID":"/elasticsearch/:1:1","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"IK分词器 作为 ES 插件导入 根据现有词典（可拓展）对文档进行划分 ","date":"2025-10-04","objectID":"/elasticsearch/:1:2","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"基础概念 索引库： 相同类型的文档（Json存储）的集合 映射： 索引库中对文档的约束 mapping 属性 type：字段数据类型 index：是否创建索引 analyzer：分词器 propertis：嵌套的子字段 ","date":"2025-10-04","objectID":"/elasticsearch/:1:3","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"索引库操作 RESTFUL 规范 不同请求方式对应不同请请求类型 创建索引库和mapping的请求语法如下： PUT /索引库名称 { \"mappings\": { \"properties\": { \"字段名1\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"字段名2\": { \"type\": \"keyword\", \"index\": \"false\" }, \"字段名3\": { \"properties\": { \"子字段\": { \"type\": \"keyword\" } } }, // …略 } } } 支持 put、get、delete ","date":"2025-10-04","objectID":"/elasticsearch/:1:4","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"文档操作 新增文档： POST /索引库名/_doc/文档id { \"字段1\": \"值1\", \"字段2\": \"值2\", \"字段3\": { \"子属性1\": \"值3\", \"子属性2\": \"值4\" }, // … } 修改 put 全量修改，先删除再新建 post 增量修改 批处理 POST /_bulk { \"index\" : { \"_index\" : \"索引库名\", \"_id\" : \"1\" } } { \"字段1\" : \"值1\", \"字段2\" : \"值2\" } { \"index\" : { \"_index\" : \"索引库名\", \"_id\" : \"1\" } } { \"字段1\" : \"值1\", \"字段2\" : \"值2\" } { \"index\" : { \"_index\" : \"索引库名\", \"_id\" : \"1\" } } { \"字段1\" : \"值1\", \"字段2\" : \"值2\" } { \"delete\" : { \"_index\" : \"test\", \"_id\" : \"2\" } } { \"update\" : {\"_id\" : \"1\", \"_index\" : \"test\"} } { \"doc\" : {\"field2\" : \"value2\"} } ","date":"2025-10-04","objectID":"/elasticsearch/:1:5","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"DSL 查询 分类： 叶子查询：特定字段查询特定值 复合查询：逻辑方式组合叶子查询 基本语法： GET /indexName/_search { \"query\": { \"查询类型\": { \"查询条件\": \"条件值\" } } } 叶子 全文检索：分词 match 查询 mult_match 允许同时查询多个字段 精确查询：不分词，直接精确匹配 term 查询，整体到词条中寻找 range 地理查询：用于搜索地理位置 复合 基于逻辑运算组合叶子 bool：子句must、should、must_not、filer 基于算法修改查询时的文档相关性算分，从而改变排名 function_score dis_max 排序和分页 排序： 添加 sort 标签，默认按照 _score 排序 分页： 添加 from 、size 深度分页问题： es 一般对数据进行分片存储，导致查询数据时需要汇总各个分片的数据 解决方案： search after，分页时需要排序，每次查询从上一次的排序值开始。但只能向后逐页查询 scrool，将排序数据形成快照，保存在内存 设置上限 高亮显示 在搜索结果中把搜索关键字突出显示 field标签加上pre_tags、post_tags ","date":"2025-10-04","objectID":"/elasticsearch/:1:6","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"Java 客户端 JavaRestClient ","date":"2025-10-04","objectID":"/elasticsearch/:2:0","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"初始化 RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") )); ","date":"2025-10-04","objectID":"/elasticsearch/:2:1","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"Mapping 映射 结合业务分析所需字段（区分是否需要和是否搜索） 搜索字段 排序字段 展示字段 ","date":"2025-10-04","objectID":"/elasticsearch/:2:2","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"索引库操作 基于 RestFul格式： @Test void testCreateHotelIndex() throws IOException { // 1. 创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\"items\"); // 2. 请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是JSON格式请求体 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 3. 发起请求 client.indices().create(request, RequestOptions.DEFAULT); } ","date":"2025-10-04","objectID":"/elasticsearch/:2:3","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"文档操作 新增文档的 API @Test void testIndexDocument() throws IOException { // 1. 创建request对象 IndexRequest request = new IndexRequest(\"indexName\").id(\"1\"); // 2. 准备JSON文档 request.source(\"{\\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}\", XContentType.JSON); // 3. 发送请求 client.index(request, RequestOptions.DEFAULT); } ","date":"2025-10-04","objectID":"/elasticsearch/:2:4","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"文档批处理 add 多个 index，然后统一请求即可 完成批量导入数据 void testBulk() throws IOException { // 1. 创建Bulk请求 BulkRequest request = new BulkRequest(); // 2. 添加要批量提交的请求：这里添加了两个新增文档的请求 request.add(new IndexRequest(\"indexName\") .id(\"101\").source(\"json source\", XContentType.JSON)); request.add(new IndexRequest(\"indexName\") .id(\"102\").source(\"json source2\", XContentType.JSON)); // 3. 发起bulk请求 client.bulk(request, RequestOptions.DEFAULT); } 准备文档数据 准备请求参数 发送请求 ","date":"2025-10-04","objectID":"/elasticsearch/:2:5","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"RTL 查询 SearchRequest 对象，发请求 解析结果 得到 Hits 属性，结果是数组 复合、排序、分页 用指定对象、设置指定参数即可 boolquery、source @Test void testBool() throws IOException { // 1.创建Request SearchRequest request = new SearchRequest(\"items\"); // 2.组织请求参数 // 2.1.准备bool查询 BoolQueryBuilder bool = QueryBuilders.boolQuery(); // 2.2.关键字搜索 bool.must(QueryBuilders.matchQuery(\"name\", \"脱脂牛奶\")); // 2.3.品牌过滤 bool.filter(QueryBuilders.termQuery(\"brand\", \"德亚\")); // 2.4.价格过滤 bool.filter(QueryBuilders.rangeQuery(\"price\").lte(30000)); request.source().query(bool); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } 分页： @Test void testPageAndSort() throws IOException { int pageNo = 1, pageSize = 5; // 1.创建Request SearchRequest request = new SearchRequest(\"items\"); // 2.组织请求参数 // 2.1.搜索条件参数 request.source().query(QueryBuilders.matchQuery(\"name\", \"脱脂牛奶\")); // 2.2.排序参数 request.source().sort(\"price\", SortOrder.ASC); // 2.3.分页参数 request.source().from((pageNo - 1) * pageSize).size(pageSize); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } 高亮： @Test void testHighlight() throws IOException { // 1.创建Request SearchRequest request = new SearchRequest(\"items\"); // 2.组织请求参数 // 2.1.query条件 request.source().query(QueryBuilders.matchQuery(\"name\", \"脱脂牛奶\")); // 2.2.高亮条件 request.source().highlighter( SearchSourceBuilder.highlight() .field(\"name\") .preTags(\"\u003cem\u003e\") .postTags(\"\u003c/em\u003e\") ); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response); } ","date":"2025-10-04","objectID":"/elasticsearch/:2:6","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["开发"],"content":"数据聚合 对文档数据进行统计、分析 桶：对文档做而非女足 度量 Metric：计算某些特定值 管道 Pipeline：以其他聚合的结果为基础做聚合 DSL aggs 定义聚合 GET /items/_search { \"query\": {\"match_all\": {}}, // 可以省略 \"size\": 0, // 设置size为0，结果中不包含文档，只包含聚合结果 \"aggs\": { // 定义聚合 \"cateAgg\": { // 给聚合起个名字 \"terms\": { // 聚合的类型，按照品牌值聚合，所以选择term \"field\": \"category\", // 参与聚合的字段 \"size\": 20 // 希望获取的聚合结果数量 } } } } RestClient 构造聚合 指定名称、类型、字段 request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\"brand_agg\") .field(\"brand\") .size(20) ); ","date":"2025-10-04","objectID":"/elasticsearch/:2:7","tags":["技术"],"title":"ElasticSearch","uri":"/elasticsearch/"},{"categories":["笔记"],"content":"第一章 计算机系统概述 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"计算机系统的发展 计算机系统 = 硬件 + 软件 软件 系统软件：用来管理整个计算机系统 应用软件：按任务需要编制成的程序 硬件 第一台电子数字计算机：ENIAC 逻辑元件（用于处理电信号的最小单元）：电子管 十进制表示，手动编程 无冯 · 诺伊曼结构 第二代：晶体管 元器件：逻辑元件（晶体管），内存（磁芯），外存（磁鼓，磁带） 特点：变址，浮点运算，多路存储器，I/O 处理机，中央交换结构（非总线）。 软件：使用高级语言，提供系统软件。 第三代：中小规模集成电路 元器件：逻辑元件和主存储器均由集成电路实现。 特点：微程序控制，Cache，虚拟存储器，流水线。 代表机种：IBM 360（大型机），DEC PDP-8（小型机），巨型机。 IBM 360（兼容机） 相同/相似的指令集\u0026操作系统。 好处： 原来机器上的程序可以不改动而在新机器上运行，但性能不同。 保持兼容的关键：低端机指令集是高端机的一个子集，称为“向后兼容”。 DEC PDP-8（采用总线结构） 总线结构好处：可扩充性好（允许将新的符合标准的模块插入总线，形成各种配置），节省器件，体积小，价格便宜 第四代：大规模、超大规模集成电路 半导体存储器，微处理器发展迅速。 特点：共享存储器，分布式存储器以及大规模并行系统。 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:1","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"组成 冯诺依曼结构模型 冯诺依曼提出存储程序，取代手动接线。 冯诺依曼结构： 计算机由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。 各基本部件功能： 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令； 控制器应能自动执行指令； 运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算； 操作人员可以通过输入设备和输出设备与主机进行通信。 内部以二进制数表述指令和数据 每条指令由操作码和地址码两部分组成。操作码指出操作的类型，地址码指出操作数的地址。 由一串指令组成程序。 采用存储程序工作方式 将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。 基本部件及其功能 运算器（数据运算）：ALU、GPRs、标志寄存器等。 存储器（数据存储）：存储阵列、地址译码器、读写控制电路 总线（数据传送）：数据线（MDR）、地址线（MAR）和控制线 控制器（控制）：对指令译码生成控制信号 CPU = 运算器 + 控制器 主机 = CPU + 主存 各硬件工作原理 主存储器 主存储器 = 存储体 + MAR + MDR Memory Address Register 存储地址寄存器：指示位置，位数反应存储单元的个数 Memory Data Register 存储数据寄存器：指示存入、取出的具体数据（包括指令） 存储体：数据、指令在存储体内按地址存储，每个存储单元对应一个地址 1B = 1 byte ; 1 b = 1 bit MAR、MDR 逻辑上属于主存，但被集成到 CPU 运算器 实现算数运算、逻辑运算 运算器 = ACC + ALU + MQ + X Accumulator：累加器，存放操作数或运算结果 Multiple-Quotient Register：乘商寄存器，乘除运算时，存放操作数或运算结果 Arithmetic and Logic Unit：算数逻辑单元，通过复杂电路实现算数运算、逻辑运算 X：通用的操作数寄存器，用于存放操作数 控制器 控制器 = CU + IR +PC Control Unit:控制单元，分析指令，给出控制信号 Instruction Register:指令寄存器，存放当前执行的指令 Program Counter:程序计数器，存放下一条指令地址，有自动加1功能 配合 指令和数据 程序启动前，指令和数据都存储在存储器中，形式上没有区别，都是 0/1 序列。 采用存储程序的工作方式，程序由指令组成，启动后计算机自动取出一条条指令并执行，无需人的干预。 指令执行过程中，指令和数据从存储器取到 CPU，指令存在 IR 中，数据在 GPR 中。 指令需要给出的信息 操作码：指令的操作，加减法等 一个或多个源操作数：立即数、寄存器编号、存储地址 目的操作数地址：寄存器编号、存储地址 执行过程 程序执行前 数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放。指令由 OP、ADDR 字段组成，程序起始地址送入 PC。 开始执行程序 根据 PC 取指令送 IR：PC -\u003e MAR -\u003e存储器 -\u003e MDR -\u003e IR 指令译码：IR -\u003e 控制器，控制器译码 取操作数：GPRs 或存储器 -\u003e ALU 执行指令操作：ALU 运算 回写结果到 GPRs 或存储器 修改 PC 的值，使其指向下一条指令 重复上述步骤直到程序完成 软件 系统软件——简化编程，使硬件资源被有效利用 操作系统：硬件资源管理，用户接口 语言处理程序：翻译程序，Linker，Debug… 翻译程序 汇编器（Assembler）：汇编语言源程序-\u003e机器目标程序。或许叫汇编器更好理解？ 编译器（Complier）：高级语言程序-\u003e汇编/机器目标程序。或许叫编译器更好理解？ 解释器（Interpreter）：将高级语言程序语句逐条翻译成机器指令并执行，不生成目标文件。（跳过汇编阶段） 其他实用程序：磁盘碎片整理、备份程序… 机器语言：二进制代码 汇编语言：助记符 高级语言：C、C++、…… 应用软件——解决具体的应用问题 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:2","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"层次结构 语言层次 微指令系统：直接控制硬件执行 机器语言：传统机器M1，执行二进制机器指令 操作系统机器 汇编语言：虚拟机器M2，用汇编语言翻译成机器语言 高级语言：虚拟机器M3，需要编译成汇编、机器语言 上两层视为硬件层 计算机体系结构：讨论如何设计硬件与软件之间的接口 计算机组成原理：讨论如何用硬件实现接口 ISA 指令集体系结构，其作为规约，规定了如何使用硬件。 可执行的指令集合，包括指令格式、操作种类以及对应操作数的规定。 可以接受的操作数类型。 操作数存放的寄存器组结构，例如寄存器名称、编号、长度和用途。 操作数存放的存储空间的大小和编址方式。 操作数在存储空间中按大/小端方式存放。 指令获得操作数的方式，即寻址方式。 指令执行过程的控制方式，例如程序计数器，条件码定义等。 ISA 是计算机系统中必不可少的抽象层。 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:3","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"性能指标 存储器 总容量 = 存储单元个数 * 存储字长(bit) CPU 基本概念 主频：CPU内数字脉冲信号振荡的频率 = 1 / 时钟周期 CPI：执行一条指令需要多少个时钟周期（不同指令，CPI不同） CPU执行时间：执行整个程序的耗时 = (条数 * CPI) / 主频 IPS：每秒执行多少个命令 = 主频 / 平均CPI FLOPS：每秒执行多少次浮点运算 K=Kilo=千=10^3 M=Million=百万=10^6 G=Giga=十亿=10^9 T=Tera=万亿=10^12 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据） 吞吐量：单位时间内处理请求的数量 相应时间：CPU时间 + 等待时间 基准程序：用于测量的程序 MIPS（Million Instructions Per Second）：每秒执行多少百万条指令，着重点在于单条指令。 MIPS 为平均值，其并没有考虑以上三个属性，并且由于： 不同机器指令集不同 程序由不同指令混合而成 指令的频率会动态变换 厂家给出峰值 MIPS 因此，MIPS 表示性能存在局限性。 MFLOPS：每秒执行浮点运算多少百万次，着重在于浮点操作本身。 计算 CPU 执行时间=CPI×程序总指令条数×时钟周期 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:4","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"第二章 数据的机器级表示 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"信息二进制编码 计算机内部数据：二进制表示 机器级数据： 数值数据，无符号/带符号整数，浮点数，十进制数 非数值数据，逻辑数，汉字 二进制编码原因： 制造两个稳态的物理器件容易 二进制编码、计数、运算规则简单。 与逻辑命题对应，便于逻辑运算，方便地用逻辑电路实现算术运算。 机器数：0/1 编码的 0/1 内部 0/1 序列。 真值：机器数真正的值 数值数据表示方法 三要素： 进位计数制：十进制，二进制等转换。 定点浮点表示：定点整数/小数；浮点数（使用一个定点小数和一个定点整数表示） 编码：原码补码反码等。 若不知道三要素，那么便无法得知机器数的具体真值。 进制转换： 二进制 -\u003e 其他：划分位数，对应 十六、八 -\u003e 二：位数对应，补全 十进制 -\u003e 任意位数：求商取余 定点数的表示 常规计数，小数点位置固定。整数、小数分开存储。 无符号数：没有符号位 原码： 有 +0、-0 两种表示形式 反码： 正数与原码相同 若符号位为1，则数值位全部取反 依然有 +0、-0 补码： 将减法抓换为等价的加法（加上补数） = 原码除符号位外，取反后加一（即反码 + 1） 移码： 将每一个数值加上一个偏置常数（ bias） 一般来说，当编码位数为 n **时，bias 取 2^n 标准移码 为什么要用移码来表示阶码？ 便于浮点数加减运算时的对阶操作（比较大小） 与补码的关系：最高位相反，其余位相同 C语言的解析 无符号数变为有符号：不改变数据内容，改变解释方式 长变短：高位截断，保留地位 短变长：符号扩展 负数补1，正数补0 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:1","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"IEEE编码 规定了二进制浮点数算数标准，类似科学计数法简化计数 二进制浮点数 符号：决定数值的正负性 尾数：影响数值的精度。尾数的位数越多，精度越高 阶码：反映小数点的实际位置 基数：K进制通常默认基数为K 规格化：石确保尾数的最高位非0数位刚好在小数点之前 float型：32位单精度 符号 + 阶码 + 尾数：1 + 8 + 23 double型：64位双精度 符号 + 阶码 + 尾数：1 + 11 + 52 float单精度 默认存储规格化尾数，小数点前的1省略（隐含） 基数规定为 2 阶码用移码表示，规定偏置值为 127 如何将十进制真值转换为偏置值为M的移码？ 将十进制真值+偏置值 按“无符号整数”规则转换为指定位数 double双精度 偏置值为1023 表示范围 特殊状态 阶码全 0，或阶码全 1 阶码真值的取值范围为 -126 ~ 127（单精度） 根据数轴，存在： 正上溢、正下溢、负上溢，负下移 上溢置为无穷，下溢置为0 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:2","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"数据表示 十进制数表示 ASCII 码：就是把数字当作字符存储，0-9用30H-39H表示 前分隔：正号用 2B 负号用 2D 放在最前面 后嵌入：将符号嵌入最低位数字的 ASCII 码高 4 位中。 正数不变；负数高 4 位变为 0111。 BCD 码 每 1 位十进制数用 4 位二进制表示。而 4 位二进制数可组合成 16 种状态，只需要选 10 种状态来表示十进制数。 西文字符表示： 复习要点中未提到 十进制数字：0/1/2…/9 10 个 英文字母：A/B/…/Z/a/b/…/z 52 个 专用符号：+/-/%/*/\u0026/…… 33 个 控制字符（不可打印或显示） 33 个 汉字表示 输入码：用于输入汉字。 内码：用于在系统中进行存储、查找、传送等处理 字模点阵或轮廓描述：用于显示/打印 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:3","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"数据的宽度 bit 字节： 现代计算机中，存储器按字节编址 字节是最小可寻址单位 （addressable unit ） LSB 表示最低有效字节，MSB 表示最高有效字节 字 表示被处理信息的单位，用来度量数据类型的宽度 字长 指某特定机器定点运算时数据通路的宽度。 数据通路： CPU 内部进行数据运算、存储和传送的路径以及路径上的部件。 等于 CPU 内部总线的宽度，或运算器的位数，或通用寄存器的宽度。 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:4","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"数据的存储和排列顺序 大小端 小端（ Little Endian）:低字节放低地址 大端（ Big Endian）:高字节放低地址 指令中，操作码和寄存器号的存放顺序不变，只需要考虑立即数的顺序 对齐：要求数据存放的地址必须是相应的边界地址 每次访存只能读写一个字 浪费一定空间，换取存取时间 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:5","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"数据的检错与纠错 大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。 奇偶校验码 海明校验码 循环冗余校验码 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:6","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"第三章运算方法和运算部件 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"加法器 串行进位 传递速度慢 并行进位 用先行进位优化，各进位之间无等待，相互独立并同时产生 但全先行电路复杂，成本高 局部先行进位加法器： 组内并行、组间串行 用多个位数较少的 n 位全先行进位加法器进行串联 多级先行进位加法器： 组内并行、组间并行 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:1","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"ALU的构成 ALU 如何控制实现加、减、与、或等等各种功能； 无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加/减运算部件。 在整数加/减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现 ALU、乘/除运算以及浮点运算。 ALU 的 OF、SF、CF 和 ZF 标志信息如何产生。 零标志 ZF、溢出标志 OF、进/借位标志 CF、符号标志 SF 称为条件标志。 条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中 存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。 溢出条件： 无符号加、减溢出条件：CF=1 带符号加、减溢出条件：OF=1 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:2","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"定点数运算 移位 逻辑移位 针对无符号数 左移 n 位，即乘上位权的 n 次方。 高位溢出丢弃，低位补 0 算数移位 左移与逻辑移位类似，但移到符号位结果更改 右移：低位移出丢弃，但高位补符号位，若移出 1，则发生精度丢失 加减 原码 减法用减法器实现，1 变 0 补码 符号位可以一起参与运算 [A+B]补=[A]补+ [B]补 [A-B]补=[A]补+[-B]补 [-B] 补 = [B] 补的 “取反加 1”，符号位也参与取反 溢出判断：上溢正变负；只有可能同号运算出现；判断是否在合法表示范围内即可 乘法 无符号整数： 模拟手算乘法即可，计算机还需拆分部分积 具体实现： 带符号整数 给无符号整数乘法电路添加一辅助位，让符号位参与运算。 计算机底层判断溢出： 若 2n 位的高 n + 1 位不均相同，则溢出 实现方式 ALU + 移位器 + 寄存器 + 控制逻辑 阵列乘法器 逻辑运算模拟 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:3","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["笔记"],"content":"浮点数运算 浮点数加减运算的对阶原则和方法； 原则：小阶向大阶看齐 方法：阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值 IEEE 754 尾数右移时，要将隐含的“1”移到小数部分，高位补 0，移出的低位保留到特定的“附加位”上 如何计算移码表示的阶码的和与差（标准移码与 IEEE754 移码有什么差别）； 阶码加法公式为： Eb ← Ex + Ey + 129 （ mod 2^8） 阶码减法公式为： Eb ← Ex + [–Ey]补 + 127 （ mod 2^8） 如何计算一个移码数减 1 尾数规格化中的右规和左规方法； 当尾数高位为 0，则需左规：尾数左移一次，阶码减 1，直到 MSB 为 1 每次阶码减 1 后要判断阶码是否下溢 先判断阶码是否为全 0，若是，则直接置阶码下溢；否则，阶码减 1 后判断阶码是否为全 0，若是，则阶码下溢。 当尾数最高位有进位，需右规：尾数右移一位，阶码加 1，直到 MSB 为 1 每次阶码加 1 后要判断阶码是否上溢 先判断阶码是否为全 1，若是，则直接置阶码上溢；否则，阶码加 1 后判断阶码是否为全 1，若是，则阶码上溢。 阶码溢出异常处理： 阶码上溢，则结果溢出； 阶码下溢，则结果为 0 乘法运算结果不需左规！最多右规 1 次！ 除法最多左规 1 次！不需右规！ 尾数的舍入处理常用方法； 就近舍入：舍入为最近可表示的数 若为非中间值：LSB 后 1 位 0 舍 1 入 若为中间值：强迫结果为偶数， LSB= 1.1101110 → 1.1110 (1.1101110 → 1.1110, 110\u003e100, 1.1101+0.0001 = 1.1110) 1.1101011 → 1.1101 (1.1101011 → 1.1101, 011\u003c100, 1.1101+ 0 = 1.1101) 1.1101101 → 1.1110 1.1111100 → 10.0000 (1.1111100 → 10.0000, 100=100, 1.1111+0.0001 = 10.0000) 朝+∞方向舍入：舍入为右边最近可表示数 （正向舍入） 例：-1.1101101 →-1.1101 ； 1.1101101 →1.1110 朝-∞方向舍入：舍入为左边最近可表示数 （负向舍入） 例：-1.1101101 →-1.1110 ； 1.1101101 →1.1101 朝 0 方向舍入：直接截取所需位，后面的位丢弃。这种方法最简单 如何判断结果溢出（上溢和下溢）。 ","date":"2025-10-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:4","tags":["笔记"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["开发"],"content":"初识 MQ ","date":"2025-10-02","objectID":"/mq/:1:0","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"服务调用类型 同步调用 服务 A 同时请求多个服务，导致服务种类的不断扩增，服务的等待耗时增加。 缺点： 扩展性差 性能下降 级联失败问题 异步调用 基于消息通知的方式，包含： 消息发送者：即原来的调用者 消息接收者：接收和处理消息的人 消息代理：管理、暂存转发消息 不再同步调用业务关联度第的服务，而是分别发送消息到 Broker 接触耦合，扩展性强 无需等待，性能好 故障隔离 缓存消息，流量削锋填谷 技术选型 RabbitMQ、ActiveMQ、RocketMQ、Kafka ","date":"2025-10-02","objectID":"/mq/:1:1","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"部署 Docker安装即可 整体架构： publisher：消息发送者 consumer：消息消费者 queue：队列，存储消息 exchange：交换机，负责路由消息 vertual-host：虚拟主机，用于数据隔离 消息发送给交换机，再由交换机分发给对应的 queue，交换机没有消息存贮的能力。 ","date":"2025-10-02","objectID":"/mq/:1:2","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"Java客户端 AMQP：无协议传输 封装为 Spring AMQP 再封装为 SpringRabbit，RabbitTemplate包装类 ","date":"2025-10-02","objectID":"/mq/:2:0","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"收发消息 发送： @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue() { // 队列名称 String queueName = \"simple.queue\"; // 消息 String message = \"hello, spring amqp!\"; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); } 接收： @Slf4j @Component public class SpringRabbitListener { @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueueMessage(String msg) throws InterruptedException { log.info(\"spring 消费者接收到消息: [\" + msg + \"] \"); } } ","date":"2025-10-02","objectID":"/mq/:2:1","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"Work Queues 多个消费者绑定到一个队列 一条消息只能被一个消费者处理 多条消息，默认轮流接收 通过添加消费者来处理超量数据 修改配置 修改 prefetch 来控制消费者预取的消息数量，使性能高的服务器多处理 ","date":"2025-10-02","objectID":"/mq/:2:2","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"交换机 Fanout 广播模式，将接收到的消息路由到每一个与其绑定的 queue Direct 定向路由，根据规则路由到指定的 queue 设置 BindingKey 和 RoutingKey Topic 基于 RoutingKey，但其通常是多个单词的组合，且以.分割，可以使用通配符# * ","date":"2025-10-02","objectID":"/mq/:2:3","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"声明队列交换机 用代码自动完成队列、交换机的创建 基于Bean声明 在消费者端声明： @Configuration public class FanoutConfig { // 声明FanoutExchange交换机 @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\"hmall.fanout\"); } // 声明第1个队列 @Bean public Queue fanoutQueue1(){ return new Queue(\"fanout.queue1\"); } // 绑定队列和交换机 @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } // ... 略，以相同方式声明第2个队列，并完成绑定 } 基于注解声明 优化 Bean 声明中绑定 Key 的冗余代码。 @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"direct.queue1\"), exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT), key = {\"red\", \"blue\"} )) public void listenDirectQueue1(String msg){ System.out.println(\"消费者1接收到Direct消息: [\"+msg+\"] \"); } ","date":"2025-10-02","objectID":"/mq/:2:4","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"消息转换器 负责将对象转换为字节格式传输 问题： 默认序列化由安全风险 信息体积变大 可读性差 解决： 用 Jackson 序列转换器 注意收发一致 ","date":"2025-10-02","objectID":"/mq/:2:5","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"进阶 改进消息可靠性问题 ","date":"2025-10-02","objectID":"/mq/:3:0","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"发送者可靠性 重连 由于网络波动，可能出现发送者连接 MQ 失败。 配置中开启重连机制即可 注意性能损耗 使用合理的重连机制 确认 MQ 接收到消息后，返回 ACK 给发送者。（对性能影响较大） 不同的返回情况、强度 其他情况返回 NACK，告知投递失败 使用： 先开启配置 public confirm type 配置类 @Slf4j @AllArgsConstructor @Configuration public class MqConfig { private final RabbitTemplate rabbitTemplate; @PostConstruct //只在启动时初始化依次 public void init(){ rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() { @Override public void returnedMessage(ReturnedMessage returned) { log.error(\"触发return callback,\"); log.debug(\"exchange: {}\", returned.getExchange()); log.debug(\"routingKey: {}\", returned.getRoutingKey()); log.debug(\"message: {}\", returned.getMessage()); log.debug(\"replyCode: {}\", returned.getReplyCode()); log.debug(\"replyText: {}\", returned.getReplyText()); } }); } } 发送方： @Test void testPublisherConfirm() throws InterruptedException { // 1.创建CorrelationData CorrelationData cd = new CorrelationData(); // 2.给Future添加ConfirmCallback cd.getFuture().addCallback(new ListenableFutureCallback\u003cCorrelationData.Confirm\u003e() { @Override public void onFailure(Throwable ex) { // 2.1.Future发生异常时的处理逻辑，基本不会触发 log.error(\"handle message ack fail\", ex); } @Override public void onSuccess(CorrelationData.Confirm result) { // 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容 if(result.isAck()){ // result.isAck()是boolean类型，true代表ack回执，false代表nack回执 log.debug(\"发送消息成功，收到 ack!\"); }else{ // result.getReason()是String类型，返回nack时的异常描述 log.error(\"发送消息失败，收到 nack，reason：{}\", result.getReason()); } } }); // 3.发送消息 rabbitTemplate.convertAndSend(\"hmall.direct\", \"red1\", \"hello\", cd); } 若发送失败，则尝试重发 ","date":"2025-10-02","objectID":"/mq/:3:1","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"MQ可靠性 问题： 数据丢失 内存空间有限，可能导致消息阻塞、堆积 数据持久化 交换机、队列、消息 消息：内存到上限后，才写出到磁盘，阻塞 一直写出到磁盘 Lazy Queue 惰性队列 接到消息不再写到内存，直接存入磁盘 消费消息时，从磁盘中读取并加载到内存 ","date":"2025-10-02","objectID":"/mq/:3:2","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"消费者可靠性 确认 消费者处理消息结束后，向 MQ 发送回执，告知消息处理状态 ack：成功处理 配置`acknowledge-mode none 接到后直接返回。不安全 manual 手动编写返回逻辑 auto nack：处理失败，需要重发 reject：处理失败并拒绝，MQ 从队列中删除该消息 失败重试 问题：消费者反复调用 MQ 导致性能损耗 解决：消费者出现异常时利用本地调试机制，无需调用 queue 重试耗尽后的策略 直接 reject（默认） 返回 nack，重新入队 将失败消息投递到指定的交换机 业务幂等 程序开发时，同一个业务执行一次和多次对业务状态的影响是一致的。用于确保消息不被多次执行。 解决方案： 给每个消息设置唯一 id ，配置SetMessageId，然后将 id 写入数据库 业务判断：基于业务本身 保证服务间一致性 ","date":"2025-10-02","objectID":"/mq/:3:3","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"延迟消息 实现一致性的兜底方案。 发送者发送消息时指定时间，消费者在指定时间后才收到消息 如支付超时取消 死信交换机 死信： requeue = false 消息无人消费、过期 –\u003e 用于实现延迟消息 消息堆积满了，最早的消息成为死信 死信交换机： 接收死信 消息延迟插件 RabbitMQ的插件，docker部署 计时需要占用 CPU，产生资源消耗 尽可能延时缩短 ","date":"2025-10-02","objectID":"/mq/:3:4","tags":["技术"],"title":"MQ","uri":"/mq/"},{"categories":["开发"],"content":"网关 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:0","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"介绍 网络的关口，负责请求的路由、转发、身份检验。分为阻塞式、响应式。微服务将服务注册到注册中心，网关进行服务拉取返回给前端。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:1","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"使用 创建新模块 引入网关依赖 编写启动类 配置路由 spring: cloud: gateway: routes: - id: item # 路由规则id，自定义，唯一 uri: lb://item-service # 路由目标微服务，lb代表负载均衡 predicates: # 路由断言，判断请求是否符合规则，符合则路由到目标 - Path=/items/** # 以请求路径做判断，以/items开头则符合 - id: xx uri: lb://xx-service predicates: - Path=/xx/** 另有各种路由种类、路由过滤器。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:2","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"登录校验 需要在网关转发之前进行校验，即添加过滤器。 网关底层流程： HandlerMapping 路由映射器 WebHandler 请求处理器，即过滤器处理器 PRE（在这里实现） + POST 阶段 Q: 网关如何将用户信息传递给微服务？ Http 传送 –\u003e 用请求头 Q: 微服务之间如何传递用户信息？ 自定义过滤器 GatewayFilter：指定路由生效 GlobalFilter：全局过滤器，作用于所有路由 @Component public class MyGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 1.获取请求 ServerHttpRequest request = exchange.getRequest(); // 2.过滤器业务处理 System.out.println(\"GlobalFilter pre阶段 执行了。\"); // 3.放行 return chain.filter(exchange); } @Override public int getOrder() { // 过滤器执行顺序，值越小，优先级越高 return 0; } } 网关拦截逻辑： 获取 request 根据 URL 判断是否需要拦截 获取 Token，解析校验 网关传递服务 用 ServerWebExchange 类下的 API 来给请求头添加鉴权信息，再发送给后续服务。 将登录检验封装为工具模块（配置类），统一扫描调用。 配置类的配置：@ConditionalOnClass(DispatcherServlet.class) 只拦截到后端 SpringMVC 的请求（否则其他模块扫描不到），绕过网关。 微服务间传递信息 利用 OpenFeign 的 RequestTemplate 类更改请求头传递，保存请求头。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:3","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"配置管理中心 问题： 微服务重复配置过多，维护成本高 更改配置不方便，需要重启服务、网关 解决： 通过配置管理实现热更新、配置共享 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:2:0","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"配置管理 NACOS 可视化编辑共享配置 包含： 数据库 日志 Swagger …… 微服务拉取共享配置 流程： 启动，加载 bootstrap 引导类 拉取 Nacos 配置 初始化 ApplicationContext上下文 加载 application.yml ，拉取共享配置，合并配置 配置热更新 前提条件 nacos 中要有于微服务名有关的配置文件 微服务中要以特定方式读取需要热更新的配置属性 动态路由 要求： 监听 Nacos 配置变更信息 private final NacosConfigManager nacosConfigManager; public void initRouteConfigListener() throws NacosException { // 1.注册监听器并首次拉取配置 String configInfo = nacosConfigManager.getConfigService() .getConfigAndSignListener(dataId, group, 5000, new Listener() { @Override public Executor getExecutor() { return null; } @Override public void receiveConfigInfo(String configInfo) { // TODO 监听到配置变更，更新一次配置 } }); // TODO 2.首次启动时，更新一次配置 } 再定义 UpdateConfigInfo(),删除旧的路由、重新读取新路由 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:2:1","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"为什么需要拆分？ 单体架构不适合于用户量大、开发人员多的项目 访问资源难以分配，无法分解并发压力 –\u003e 把单体架构拆分为多个独立项目 颗粒度小，团队自治，服务自治，数据隔离 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:1:0","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"服务拆分 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:0","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"前置知识 首先熟悉项目、模块，看流程。 拆分时机 创业型项目先采用单体结构，随规模扩增 拆分原则 高内聚（关联度、完整度高），低耦合（减少对其他服务依赖） 纵向：按业务模块 横向：抽取公共服务，提高复用性 拆分类型 独立 project：适用于大型项目 Maven 聚合，分开打包：较小型项目 注册中心 整合服务调用、服务提供者 提供负载均衡，心跳续约、推送变更（防失效） Nacos 需要提供数据库，配置服务注册 服务发现 -\u003e 挑选示例（负载均衡） -\u003e 调用 OpenFeign 声明式http客户端，简化http请求书写 使用步骤：导入 client 模块 -\u003e 打开开关 -\u003e 写接口 接口的作用是转发 http 请求，作为各个服务间请求数据的中介 连接池：底层请求用的是 Client，效率较低，用连接池优化 最佳实践：1. 将查询接口放到服务提供方 2 . 封装为统一的api模块（耦合度较高） 日志记录：定义类、定义日志级别，声明到注解 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:1","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"拆分步骤 先按模块分析，将实体类区分开 选择拆分类型，建立模块或项目，改依赖 导入并修改启动类、配置类、各种实体类，根据报错再修改 导入service、impl、controller、mapper 重建数据库、配置启动项进行测试 注意 若 service 中还需要注入其他模块的 service，就要配置注册中心。接入 feign 的 api 接口来调用指定服务。在拆分的同时不断完善 feign 的接口（从目标服务的 controller 中抽取）。 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:2","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["算法"],"content":"哈希 适用场景： collections.defaultdict(type) 字典类型，自动添加某类型元素。思考哈希值如何计算、如何存储。 涉及到查重、判断是否存在相似元素时，可以使用。 ","date":"2025-09-30","objectID":"/leetcode/:1:0","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"例题 字母异位词分组 1. collections.defaultdict(list) 满足返回的为各个字符集;通过 mp[key].append(st) 来给字典加入值。 2. \"\".join(sorted(s)) 来排序、求重 3. return list(mp.values()) 直接返回值的列表 最长连续序列 1. 利用集合去重、提高查找速度 2. 分析连续序列所满足的条件、限制的条件：若n-1在序列中，则无需遍历n，利用包含关系来简化算法 ","date":"2025-09-30","objectID":"/leetcode/:1:1","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"双指针 适用场景： 多变量问题，变量间存在某种关系 首尾比较、字符移动 同向、相向遍历问题 通法： 初始化左右指针，并考虑其作用、意义 写循环，考虑边界条件、指针变化规律，注意规范 ","date":"2025-09-30","objectID":"/leetcode/:2:0","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"例题 移动0 1. 由于要将0移到末端，所以右指针需要指向非零数，左指针指向0，两数交换即可 2. 边界条件：右指针到末尾即停止，因为已经没有非零数需要向前移动 盛最多水的容器 1. 暴力思路：直接两层for循环从左向右遍历 2. 思考：有必要依次循环吗？什么情况下会出现最大值？如何趋向最大值？ 3. 优化：计算面积的公式是：(right - left)*min(height[left],height[right]) 那么不妨从 right - left 最大时开始遍历，这时想到双指针。那么往里收缩的条件就变成比较height的大小。如果height更大就直接保留，舍去了很多不必要的情况。 三数之和 1. 难点在于去重，各个值的组合不能重复 2. 思考：\"不能重复\"这一要求能不能转化？ 3. 优化：不妨将数组重新排序，从而让三个数也排序地输出，免去了去重的麻烦。更进一步，a+b+c=0是等式关系，而a确定后，b是递增的，c又是由a、b决定的，故可以将b、c用双指针遍历，一增一减，完全符合要求。 ","date":"2025-09-30","objectID":"/leetcode/:2:1","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["技术杂项"],"content":"查看是否已安装 docker --version 若已安装： yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:1:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"安装依赖工具 yum sudo yum install -y yum-utils device-mapper-persistent-data lvm2 错误：yum-config-manager：找不到命令 yum -y install yum-utils 错误：更新 yum 报错 sudo tee /etc/yum.repos.d/CentOS-Base.repo «-‘EOF’ [base] name=CentOS-$releasever - Base baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 [updates] name=CentOS-$releasever - Updates baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 [extras] name=CentOS-$releasever - Extras baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 EOF ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:2:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"安装docker 添加 docker 官方仓库 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装 bash sudo yum install -y docker-ce docker-ce-cli containerd.io 启动、设置开机自启 sudo systemctl start docker sudo systemctl enable docker ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:3:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"docker 拉取镜像源配置 添加多个镜像源 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://alzgoonw.mirror.aliyuncs.com\", \"https://docker.m.daocloud.io\", \"https://dockerhub.icu\", \"https://docker.anyhub.us.kg\", \"https://docker.1panel.live\" ] } EOF 重新加载并重启 sudo systemctl daemon-reload sudo systemctl restart docker 测试 docker pull hello-world ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:3:1","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["开发"],"content":"SpringBoot 的优势 SpringBoot 是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。 简化操作体现在四个方面 parent 统一控制版本，解决版本冲突问题 starter 整合依赖的固定搭配格式，减少依赖配置 引导类 @SpringBootApplication，用于启动程序、初始化容器 内嵌 Tomcat ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"配置 首先，需要用 maven 来将 SpringBoot 的环境搭建好。也可以从官网下载源文件进行导入。 在 application.properties 中可以更改已导入 starter 的配置。更进一步，可以在 .yml 以及 .yaml 中进行配置，简化书写。 配置中的数据也是可以被使用的，用Spring中的注解@Value读取单个数据，如 @Value(\"{$server.port}\") ，同时，所有的数据封装到了一个 Environment 对象当中，可以调用。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"技术整合 JUnit @SpringBootTest class Springboot04JunitApplicationTests { //注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //执行要测试的对象对应的方法 bookDao.save(); System.out.println(\"two...\"); } } 简化了测试类的编写，自动装配要测试的对象。 Mybatis @Mapper public interface BookDao { @Select(\"select * from tbl_book where id = #{id}\") public Book getById(Integer id); } 导入、配置以后，用一个 Dao 映射端口即可实现 Mybatis 的功能。 Lombok import lombok.Data; @Data public class Book { private Integer id; private String type; private String name; private String description; } 直接通过注解实现 getter、setter 等操作的自动添加。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:2:1","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"基本开发流程 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"架构 JavaWeb 的开发一般为前后端分离开发，此处说明后端开发的架构。 Controller层 接收前端传输过来的数据，并将后端处理后的数据返回给前端，作为前后端联通的桥梁。 @RestController @RequestMapping(\"/books\") public class BookController2 { @Autowired private IBookService bookService; @GetMapping(\"/...\") public List\u003cBook\u003e getAll(){ return bookService.list(); } 指定接收路径、接收参数的格式。 路径变量用 @PathVariable 接收，Json 变量用 @RequestBody 接收，并自动封装到对应的对象中。（如果参数差别过大，可能需要用DTO对象来进行中介，然后再用 BeanUtils 方法来克隆到实体对象） 返回的变量一般封装为 Result 对象传输到前端。 Service层 作为后端逻辑处理的核心，在 Controller 层调用以后，进行一定的加工，调用 Mapper 并把结果再返回给 Controller。 需要先定义一个接口，然后根据接口实现 Impl 类，后续直接 @Autowired即可自动调用。 Mapper层 处理数据库的枢纽，执行指定 SQL 。 复杂的 、动态SQL 语句可映射到 Mapper.xml 文件当中进行编写。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:3:1","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"未完待续 Aspect 切面类，公共字段填充 消息扩展器统一日期格式 Redis + 自动缓存 …… ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"微服务保护 问题： 雪崩问题：某个服务故障，导致整个链路失效 微服务相互调用 没有做好异常处理 所有服务级联失败 解决思路： 尽量避免服务故障、阻塞 做好异常的后备方案 方案： 请求限流 线程隔离：控制业务可用线程数量 服务熔断：将异常比例过高的接口断开，直接走 fallback 失败处理：定义 fallback 处理逻辑 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:0","tags":["技术"],"title":"微服务保护及分布式事务","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["开发"],"content":"Sentinel 整合到微服务中，配置控制台 簇点链路：默认情况下，Sentinel 拦截的只是 Controller 的请求路径，故需要配置其拦截请求方法。 请求限流 设置 QPS，每秒最多请求线程数 Jmeter 请求模拟工具，用于测试压力 线程隔离 服务 B 出现阻塞或故障时，调用服务 B 的服务 A 的资源也可能因此被耗尽，故必须限制服务 A 中调用服务B的线程数。保护服务 A 中其他接口。 Fallback 将 FeignClient 添加到服务，若超限，则调用其中的 FallFactory 的接口。 服务熔断 解决雪崩问题的重要手段。有断路器统计服务调用的异常比例、慢请求比例，若超出阈值则熔断改服务。 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:1","tags":["技术"],"title":"微服务保护及分布式事务","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["开发"],"content":"分布式事务 分布式系统中，一个业务需要多个服务共同完成，则这多个服务需要同时成功或失败。 解决思路： 各个子事务之间能感知到彼此的状态 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:0","tags":["技术"],"title":"微服务保护及分布式事务","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["开发"],"content":"Seata Seata架构 TC：事务协调者，协调全局事务提交或回滚 TM：事务管理器，定义全局事务的范围，开始提交或回滚（入口） RM：资源管理器，与 TC 交谈以注册事务状态 部署 TC 服务 seata 用 docker 部署，然后注册到 Nacos 上 微服务集成 Seata 在 application.yml 中添加配置，让微服务找到 TC 地址 抽取共享配置到 nacos、划分事务组 seata: registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址 type: nacos # 注册中心类型 nacos nacos: server-addr: 192.168.150.101:8848 # nacos地址 namespace: \"\" # namespace，默认为空 group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP application: seata-server # seata服务名称 username: nacos password: nacos tx-service-group: hmall # 事务组名称 service: vgroup-mapping: # 事务组与tc集群的映射关系 hmall: \"default\" XA 模式 步骤： RM 注册分支事务到 TC RM 执行 sql 但不提交 RM 报告执行状态到 TC TC 检查各分支执行状态，RM 等待 TC 指令 问题： 需要锁定数据库资源，需要等待，性能较差 AT 模式 弥补 XA 模式中资源锁定周期过长的缺陷 步骤： 注册分支事务 记录数据快照 执行 sql 并提交 报告事务状态 删除快照 / 根据快照恢复数据 问题： 短暂的数据不一致 使用： 对每个服务创建一个 undo_log 表 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:1","tags":["技术"],"title":"微服务保护及分布式事务","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":null,"content":"欢迎来到我的网站 本网站主要用于记录技术文章以及个人生活。 始于2025.9.18 Calendar ","date":"0001-01-01","objectID":"/page/about/:0:0","tags":null,"title":"关于","uri":"/page/about/"},{"categories":null,"content":"功能待完善 ","date":"0001-01-01","objectID":"/categories/%E5%BC%80%E5%8F%91/:0:0","tags":null,"title":"开发","uri":"/categories/%E5%BC%80%E5%8F%91/"}]