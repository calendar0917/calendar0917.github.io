[{"categories":["开发"],"content":"网关 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:0","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"介绍 网络的关口，负责请求的路由、转发、身份检验。分为阻塞式、响应式。微服务将服务注册到注册中心，网关进行服务拉取返回给前端。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:1","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"使用 创建新模块 引入网关依赖 编写启动类 配置路由 spring: cloud: gateway: routes: - id: item # 路由规则id，自定义，唯一 uri: lb://item-service # 路由目标微服务，lb代表负载均衡 predicates: # 路由断言，判断请求是否符合规则，符合则路由到目标 - Path=/items/** # 以请求路径做判断，以/items开头则符合 - id: xx uri: lb://xx-service predicates: - Path=/xx/** 另有各种路由种类、路由过滤器。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:2","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"登录校验 需要在网关转发之前进行校验，即添加过滤器。 网关底层流程： HandlerMapping 路由映射器 WebHandler 请求处理器，即过滤器处理器 PRE（在这里实现） + POST 阶段 Q: 网关如何将用户信息传递给微服务？ Http 传送 –\u003e 用请求头 Q: 微服务之间如何传递用户信息？ 自定义过滤器 GatewayFilter：指定路由生效 GlobalFilter：全局过滤器，作用于所有路由 @Component public class MyGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 1.获取请求 ServerHttpRequest request = exchange.getRequest(); // 2.过滤器业务处理 System.out.println(\"GlobalFilter pre阶段 执行了。\"); // 3.放行 return chain.filter(exchange); } @Override public int getOrder() { // 过滤器执行顺序，值越小，优先级越高 return 0; } } 网关拦截逻辑： 获取 request 根据 URL 判断是否需要拦截 获取 Token，解析校验 网关传递服务 用 ServerWebExchange 类下的 API 来给请求头添加鉴权信息，再发送给后续服务。 将登录检验封装为工具模块（配置类），统一扫描调用。 配置类的配置：@ConditionalOnClass(DispatcherServlet.class) 只拦截到后端 SpringMVC 的请求（否则其他模块扫描不到），绕过网关。 微服务间传递信息 利用 OpenFeign 的 RequestTemplate 类更改请求头传递，保存请求头。 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:3","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"配置管理中心 问题： 微服务重复配置过多，维护成本高 更改配置不方便，需要重启服务、网关 解决： 通过配置管理实现热更新、配置共享 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:2:0","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"配置管理 NACOS 可视化编辑共享配置 包含： 数据库 日志 Swagger …… 微服务拉取共享配置 流程： 启动，加载 bootstrap 引导类 拉取 Nacos 配置 初始化 ApplicationContext上下文 加载 application.yml ，拉取共享配置，合并配置 配置热更新 前提条件 nacos 中要有于微服务名有关的配置文件 微服务中要以特定方式读取需要热更新的配置属性 动态路由 要求： 监听 Nacos 配置变更信息 private final NacosConfigManager nacosConfigManager; public void initRouteConfigListener() throws NacosException { // 1.注册监听器并首次拉取配置 String configInfo = nacosConfigManager.getConfigService() .getConfigAndSignListener(dataId, group, 5000, new Listener() { @Override public Executor getExecutor() { return null; } @Override public void receiveConfigInfo(String configInfo) { // TODO 监听到配置变更，更新一次配置 } }); // TODO 2.首次启动时，更新一次配置 } 再定义 UpdateConfigInfo(),删除旧的路由、重新读取新路由 ","date":"2025-10-01","objectID":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:2:1","tags":["技术"],"title":"网关及配置中心","uri":"/%E7%BD%91%E5%85%B3%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["开发"],"content":"为什么需要拆分？ 单体架构不适合于用户量大、开发人员多的项目 访问资源难以分配，无法分解并发压力 –\u003e 把单体架构拆分为多个独立项目 颗粒度小，团队自治，服务自治，数据隔离 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:1:0","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"服务拆分 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:0","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"前置知识 首先熟悉项目、模块，看流程。 拆分时机 创业型项目先采用单体结构，随规模扩增 拆分原则 高内聚（关联度、完整度高），低耦合（减少对其他服务依赖） 纵向：按业务模块 横向：抽取公共服务，提高复用性 拆分类型 独立 project：适用于大型项目 Maven 聚合，分开打包：较小型项目 注册中心 整合服务调用、服务提供者 提供负载均衡，心跳续约、推送变更（防失效） Nacos 需要提供数据库，配置服务注册 服务发现 -\u003e 挑选示例（负载均衡） -\u003e 调用 OpenFeign 声明式http客户端，简化http请求书写 使用步骤：导入 client 模块 -\u003e 打开开关 -\u003e 写接口 接口的作用是转发 http 请求，作为各个服务间请求数据的中介 连接池：底层请求用的是 Client，效率较低，用连接池优化 最佳实践：1. 将查询接口放到服务提供方 2 . 封装为统一的api模块（耦合度较高） 日志记录：定义类、定义日志级别，声明到注解 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:1","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["开发"],"content":"拆分步骤 先按模块分析，将实体类区分开 选择拆分类型，建立模块或项目，改依赖 导入并修改启动类、配置类、各种实体类，根据报错再修改 导入service、impl、controller、mapper 重建数据库、配置启动项进行测试 注意 若 service 中还需要注入其他模块的 service，就要配置注册中心。接入 feign 的 api 接口来调用指定服务。在拆分的同时不断完善 feign 的接口（从目标服务的 controller 中抽取）。 ","date":"2025-10-01","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/:2:2","tags":["技术"],"title":"微服务拆分","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/"},{"categories":["算法"],"content":"哈希 适用场景： collections.defaultdict(type) 字典类型，自动添加某类型元素。思考哈希值如何计算、如何存储。 涉及到查重、判断是否存在相似元素时，可以使用。 ","date":"2025-09-30","objectID":"/leetcode/:1:0","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"例题 字母异位词分组 1. collections.defaultdict(list) 满足返回的为各个字符集;通过 mp[key].append(st) 来给字典加入值。 2. \"\".join(sorted(s)) 来排序、求重 3. return list(mp.values()) 直接返回值的列表 最长连续序列 1. 利用集合去重、提高查找速度 2. 分析连续序列所满足的条件、限制的条件：若n-1在序列中，则无需遍历n，利用包含关系来简化算法 ","date":"2025-09-30","objectID":"/leetcode/:1:1","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"双指针 适用场景： 多变量问题，变量间存在某种关系 首尾比较、字符移动 同向、相向遍历问题 通法： 初始化左右指针，并考虑其作用、意义 写循环，考虑边界条件、指针变化规律，注意规范 ","date":"2025-09-30","objectID":"/leetcode/:2:0","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["算法"],"content":"例题 移动0 1. 由于要将0移到末端，所以右指针需要指向非零数，左指针指向0，两数交换即可 2. 边界条件：右指针到末尾即停止，因为已经没有非零数需要向前移动 盛最多水的容器 1. 暴力思路：直接两层for循环从左向右遍历 2. 思考：有必要依次循环吗？什么情况下会出现最大值？如何趋向最大值？ 3. 优化：计算面积的公式是：(right - left)*min(height[left],height[right]) 那么不妨从 right - left 最大时开始遍历，这时想到双指针。那么往里收缩的条件就变成比较height的大小。如果height更大就直接保留，舍去了很多不必要的情况。 三数之和 1. 难点在于去重，各个值的组合不能重复 2. 思考：\"不能重复\"这一要求能不能转化？ 3. 优化：不妨将数组重新排序，从而让三个数也排序地输出，免去了去重的麻烦。更进一步，a+b+c=0是等式关系，而a确定后，b是递增的，c又是由a、b决定的，故可以将b、c用双指针遍历，一增一减，完全符合要求。 ","date":"2025-09-30","objectID":"/leetcode/:2:1","tags":["算法"],"title":"LeetCod Hot100","uri":"/leetcode/"},{"categories":["技术杂项"],"content":"查看是否已安装 docker --version 若已安装： yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:1:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"安装依赖工具 yum sudo yum install -y yum-utils device-mapper-persistent-data lvm2 错误：yum-config-manager：找不到命令 yum -y install yum-utils 错误：更新 yum 报错 sudo tee /etc/yum.repos.d/CentOS-Base.repo «-‘EOF’ [base] name=CentOS-$releasever - Base baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 [updates] name=CentOS-$releasever - Updates baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 [extras] name=CentOS-$releasever - Extras baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 EOF ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:2:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"安装docker 添加 docker 官方仓库 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装 bash sudo yum install -y docker-ce docker-ce-cli containerd.io 启动、设置开机自启 sudo systemctl start docker sudo systemctl enable docker ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:3:0","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["技术杂项"],"content":"docker 拉取镜像源配置 添加多个镜像源 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://alzgoonw.mirror.aliyuncs.com\", \"https://docker.m.daocloud.io\", \"https://dockerhub.icu\", \"https://docker.anyhub.us.kg\", \"https://docker.1panel.live\" ] } EOF 重新加载并重启 sudo systemctl daemon-reload sudo systemctl restart docker 测试 docker pull hello-world ","date":"2025-09-29","objectID":"/%E9%85%8D%E7%BD%AEdocker/:3:1","tags":["技术"],"title":"配置docker","uri":"/%E9%85%8D%E7%BD%AEdocker/"},{"categories":["开发"],"content":"SpringBoot 的优势 SpringBoot 是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。 简化操作体现在四个方面 parent 统一控制版本，解决版本冲突问题 starter 整合依赖的固定搭配格式，减少依赖配置 引导类 @SpringBootApplication，用于启动程序、初始化容器 内嵌 Tomcat ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"配置 首先，需要用 maven 来将 SpringBoot 的环境搭建好。也可以从官网下载源文件进行导入。 在 application.properties 中可以更改已导入 starter 的配置。更进一步，可以在 .yml 以及 .yaml 中进行配置，简化书写。 配置中的数据也是可以被使用的，用Spring中的注解@Value读取单个数据，如 @Value(\"{$server.port}\") ，同时，所有的数据封装到了一个 Environment 对象当中，可以调用。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"技术整合 JUnit @SpringBootTest class Springboot04JunitApplicationTests { //注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //执行要测试的对象对应的方法 bookDao.save(); System.out.println(\"two...\"); } } 简化了测试类的编写，自动装配要测试的对象。 Mybatis @Mapper public interface BookDao { @Select(\"select * from tbl_book where id = #{id}\") public Book getById(Integer id); } 导入、配置以后，用一个 Dao 映射端口即可实现 Mybatis 的功能。 Lombok import lombok.Data; @Data public class Book { private Integer id; private String type; private String name; private String description; } 直接通过注解实现 getter、setter 等操作的自动添加。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:2:1","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"基本开发流程 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"架构 JavaWeb 的开发一般为前后端分离开发，此处说明后端开发的架构。 Controller层 接收前端传输过来的数据，并将后端处理后的数据返回给前端，作为前后端联通的桥梁。 @RestController @RequestMapping(\"/books\") public class BookController2 { @Autowired private IBookService bookService; @GetMapping(\"/...\") public List\u003cBook\u003e getAll(){ return bookService.list(); } 指定接收路径、接收参数的格式。 路径变量用 @PathVariable 接收，Json 变量用 @RequestBody 接收，并自动封装到对应的对象中。（如果参数差别过大，可能需要用DTO对象来进行中介，然后再用 BeanUtils 方法来克隆到实体对象） 返回的变量一般封装为 Result 对象传输到前端。 Service层 作为后端逻辑处理的核心，在 Controller 层调用以后，进行一定的加工，调用 Mapper 并把结果再返回给 Controller。 需要先定义一个接口，然后根据接口实现 Impl 类，后续直接 @Autowired即可自动调用。 Mapper层 处理数据库的枢纽，执行指定 SQL 。 复杂的 、动态SQL 语句可映射到 Mapper.xml 文件当中进行编写。 ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:3:1","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["开发"],"content":"未完待续 Aspect 切面类，公共字段填充 消息扩展器统一日期格式 Redis + 自动缓存 …… ","date":"2025-09-22","objectID":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","tags":["技术"],"title":"SpringBoot简明教程","uri":"/springboot%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"欢迎来到我的网站 本网站主要用于记录技术文章以及个人生活。 始于2025.9.18 Calendar ","date":"0001-01-01","objectID":"/page/about/:0:0","tags":null,"title":"关于","uri":"/page/about/"}]